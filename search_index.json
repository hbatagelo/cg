[["game.html", "6 Desenvolvendo um jogo 2D", " 6 Desenvolvendo um jogo 2D Neste capítulo, usaremos o pipeline gráfico do OpenGL e funções das bibliotecas auxiliares da ABCg (GLM, ImGui, SDL) para desenvolver um jogo com gráficos 2D. Veremos como especificar a geometria de objetos de cena usando diferentes formatos de Vertex Buffer Objects (VBOs), como trabalhar com mais de um par de vertex/fragment shaders, e como usar variáveis uniformes (uniform variables) para modificar a cor, posição e orientação dos objetos sem precisar reconstruir os VBOs. Também trabalharemos com aspectos não relacionados ao pipeline, mas que são necessários para dar animação e interação ao jogo: Como responder a eventos do mouse e teclado; Como calcular a colisão entre os objetos do jogo; Como usar temporizadores para animar os objetos. O resultado será um jogo estilo Asteroids, como mostrado a seguir. Para simplificar, o jogo não terá efeitos sonoros1. A nave pode ser controlada pelo teclado ou mouse: A orientação é ajustada pela posição do mouse, setas para os lados ou teclas A e D; A aceleração é ativada com o botão direito do mouse, seta para cima ou tecla W; Os tiros são disparados com o botão esquerdo do mouse ou barra de espaço. Observação Como a página do jogo está embutida neste livro online, só é possível controlar a nave pelo mouse. Para a aplicação ter o foco do teclado, abra o link original. Antes de começar a desenvolver o jogo, acompanharemos na seção 6.1 o passo a passo de desenvolvimento de um projeto mais simples, que desenha polígonos regulares coloridos em posições aleatórias da janela. O projeto explora conceitos que serão aplicados no jogo. Em particular, os polígonos regulares servirão de base para criarmos os asteroides e os tiros da espaçonave. Também usaremos temporizadores e variáveis uniformes de forma muito parecida com o que veremos nesse primeiro projeto. É possível incluir sons usando as funções de áudio da SDL, mas neste curso não utilizaremos tais funcionalidades.↩︎ "],["regularpolygons.html", "6.1 Polígonos regulares", " 6.1 Polígonos regulares Este projeto é um aprimoramento do projeto coloredtriangles da seção 5.4. No lugar de desenharmos triângulos (GL_TRIANGLES), desenharemos polígonos regulares 2D formados por leques de triângulos (GL_TRIANGLE_FAN). Para cada quadro de exibição, será renderizado um polígono regular colorido em uma posição aleatória do viewport. O número de lados de cada polígono também será escolhido aleatoriamente. A aplicação ficará como a seguir: Configuração inicial A configuração inicial é a mesma dos projetos anteriores. Apenas mude o nome do projeto para regularpolygons e inclua a linha add_subdirectory(regularpolygons) em abcg/examples/CMakeLists.txt. O arquivo abcg/examples/regularpolygons/CMakeLists.txt ficará assim: project(regularpolygons) add_executable(${PROJECT_NAME} main.cpp window.cpp) enable_abcg(${PROJECT_NAME}) Este projeto também terá os arquivos main.cpp, window.cpp e window.hpp. main.cpp O conteúdo aqui é praticamente idêntico ao do projeto coloredtriangles. Continuaremos com o double buffering desabilitado de modo a desenhar cada novo polígono sobre o conteúdo anterior do framebuffer. #include &quot;window.hpp&quot; int main(int argc, char **argv) { try { abcg::Application app(argc, argv); Window window; window.setOpenGLSettings({.samples = 2, .doubleBuffering = false}); window.setWindowSettings({ .width = 600, .height = 600, .title = &quot;Regular Polygons&quot;, }); app.run(window); } catch (std::exception const &amp;exception) { fmt::print(stderr, &quot;{}\\n&quot;, exception.what()); return -1; } return 0; } window.hpp Aqui também há poucas mudanças em relação ao projeto anterior: #ifndef WINDOW_HPP_ #define WINDOW_HPP_ #include &lt;random&gt; #include &quot;abcgOpenGL.hpp&quot; class Window : public abcg::OpenGLWindow { protected: void onCreate() override; void onPaint() override; void onPaintUI() override; void onResize(glm::ivec2 const &amp;size) override; void onDestroy() override; private: glm::ivec2 m_viewportSize{}; GLuint m_VAO{}; GLuint m_VBOPositions{}; GLuint m_VBOColors{}; GLuint m_program{}; std::default_random_engine m_randomEngine; abcg::Timer m_timer; int m_delay{200}; void setupModel(int sides); }; #endif Observe que há novamente dois VBOs: um para a posição e outro para a cor dos vértices (linhas 20 e 21). Na linha 27, a variável m_delay é utilizada para especificar o intervalo de tempo, em milissegundos, entre a renderização dos polígonos. window.cpp A definição de Window::onCreate é a mesma do projeto anterior, mas com o conteúdo do vertex shader modificado: #include &quot;window.hpp&quot; void Window::onCreate() { auto const *vertexShader{R&quot;gl(#version 300 es layout(location = 0) in vec2 inPosition; layout(location = 1) in vec4 inColor; uniform vec2 translation; uniform float scale; out vec4 fragColor; void main() { vec2 newPosition = inPosition * scale + translation; gl_Position = vec4(newPosition, 0, 1); fragColor = inColor; } )gl&quot;}; auto const *fragmentShader{R&quot;gl(#version 300 es precision mediump float; in vec4 fragColor; out vec4 outColor; void main() { outColor = fragColor; } )gl&quot;}; m_program = abcg::createOpenGLProgram( {{.source = vertexShader, .stage = abcg::ShaderStage::Vertex}, {.source = fragmentShader, .stage = abcg::ShaderStage::Fragment}}); abcg::glClearColor(0, 0, 0, 1); abcg::glClear(GL_COLOR_BUFFER_BIT); m_randomEngine.seed( std::chrono::steady_clock::now().time_since_epoch().count()); } No projeto coloredtriangles, o vertex shader estava assim: #version 300 es layout(location = 0) in vec2 inPosition; layout(location = 1) in vec4 inColor; out vec4 fragColor; void main() { gl_Position = vec4(inPosition, 0, 1); fragColor = inColor; } Neste projeto o código está assim: #version 300 es layout(location = 0) in vec2 inPosition; layout(location = 1) in vec4 inColor; uniform vec2 translation; uniform float scale; out vec4 fragColor; void main() { vec2 newPosition = inPosition * scale + translation; gl_Position = vec4(newPosition, 0, 1); fragColor = inColor; } A principal mudança é o uso de duas variáveis uniformes, identificadas pela palavra-chave uniform. São elas: translation: um fator de translação (deslocamento) da geometria; scale: um fator de escala da geometria. O conteúdo de translation e scale é definido em onPaint antes da chamada do comando de renderização. Lembre-se que variáveis uniformes são variáveis globais do shader que não mudam de valor de um vértice para outro, ao contrário do que ocorre com as variáveis inPosition e inColor. Observe o conteúdo de main: void main() { vec2 newPosition = inPosition * scale + translation; gl_Position = vec4(newPosition, 0, 1); fragColor = inColor; } A posição original do vértice (inPosition) é multiplicada por scale e somada com translation para gerar uma nova posição (newPosition), que é a posição final do vértice passada para gl_Position. Na expressão inPosition * scale + translation, inPosition * scale resulta na aplicação do fator de escala nas coordenadas \\(x\\) e \\(y\\) do vértice. Como isso é feito para cada vértice da geometria, o resultado será a mudança do tamanho do objeto. Se o fator de escala for 1, não haverá mudança de escala. Se for 0.5, o tamanho do objeto será reduzido pela metade em \\(x\\) e em \\(y\\). Se for 2.0, o tamanho será dobrado em \\(x\\) e em \\(y\\), e assim por diante. O resultado de inPosition * scale é somado com translation. Isso significa que, após a mudança de escala, a geometria será deslocada no plano pelas coordenadas \\((x,y)\\) da translação. Ao aplicar a escala e a translação do vertex shader, podemos usar um mesmo VBO para renderizar o objeto em posições e escalas diferentes, como mostra a figura 6.1: Figura 6.1: Resultado da transformação dos vértices de um triângulo usando diferentes fatores de escala e translação. Observação O uso de variáveis uniformes e transformações geométricas no vertex shader pode reduzir significativamente o consumo de memória dos dados gráficos. Para citar um exemplo, suponha que queremos renderizar uma cena no estilo do jogo Minecraft composta por 100 mil cubos. A estratégia mais ingênua para renderizar essa cena é criar um único VBO contendo os vértices dos 100 mil cubos. Se usarmos GL_TRIANGLES, cada lado do cubo terá de ser renderizado como 2 triângulos, isto é, precisaremos de 6 vértices (3 vértices por triângulo). Como um cubo tem 6 lados, teremos então 36 vértices por cubo. Logo, nosso VBO de 100 mil cubos terá 3600000 vértices2. Ao usar variáveis uniformes, podemos criar um VBO para apenas um cubo e renderizar esse cubo 100 mil vezes, cada um com um fator de escala e translação diferente. No fim, o número de vértices processados será igual, mas o uso de memória terá uma redução de 5 ordens de magnitude! Vamos agora à definição de Window::onPaintGL: void Window::onPaint() { if (m_timer.elapsed() &lt; m_delay / 1000.0) return; m_timer.restart(); // Create a regular polygon with number of sides in the range [3,20] std::uniform_int_distribution intDist(3, 20); auto const sides{intDist(m_randomEngine)}; setupModel(sides); abcg::glViewport(0, 0, m_viewportSize.x, m_viewportSize.y); abcg::glUseProgram(m_program); // Pick a random xy position from (-1,-1) to (1,1) std::uniform_real_distribution rd1(-1.0f, 1.0f); glm::vec2 const translation{rd1(m_randomEngine), rd1(m_randomEngine)}; auto const translationLocation{ abcg::glGetUniformLocation(m_program, &quot;translation&quot;)}; abcg::glUniform2fv(translationLocation, 1, &amp;translation.x); // Pick a random scale factor (1% to 25%) std::uniform_real_distribution rd2(0.01f, 0.25f); auto const scale{rd2(m_randomEngine)}; auto const scaleLocation{abcg::glGetUniformLocation(m_program, &quot;scale&quot;)}; abcg::glUniform1f(scaleLocation, scale); // Render abcg::glBindVertexArray(m_VAO); abcg::glDrawArrays(GL_TRIANGLE_FAN, 0, sides + 2); abcg::glBindVertexArray(0); abcg::glUseProgram(0); } Na linha 44, o tempo contado por m_timer é comparado com m_delay. Se o tempo ainda não atingiu m_delay, a função retorna. Caso contrário, o temporizador é reiniciado na linha 46 e a execução continua nas linhas seguintes. Na linha 51, setupModel(sides) é chamada para criar o VBO de um polígono regular de sides lados. O número de lados é escolhido aletoriamente do intervalo \\([3,20]\\). Nas linhas 57 a 68 são definidos os valores das variáveis uniformes do shader: // Pick a random xy position from (-1,-1) to (1,1) std::uniform_real_distribution rd1(-1.0f, 1.0f); glm::vec2 const translation{rd1(m_randomEngine), rd1(m_randomEngine)}; auto const translationLocation{ abcg::glGetUniformLocation(m_program, &quot;translation&quot;)}; abcg::glUniform2fv(translationLocation, 1, &amp;translation.x); // Pick a random scale factor (1% to 25%) std::uniform_real_distribution rd2(0.01f, 0.25f); auto const scale{rd2(m_randomEngine)}; auto const scaleLocation{abcg::glGetUniformLocation(m_program, &quot;scale&quot;)}; abcg::glUniform1f(scaleLocation, scale); Na linha 59, translation contém coordenadas 2D aleatórias no intervalo \\([-1,1)\\). Na linha 66, scale é um fator de escala aleatório no intervalo \\([0.01, 0.25)\\). Nas linhas 60 e 67, translationLocation e scaleLocation contêm os identificadores de localização das variáveis uniformes do shader. Esse valores são obtidos com glGetUniformLocation passando o identificador do programa de shader como primeiro argumento (m_program) e o nome da variável uniforme como segundo argumento. A atribuição dos valores das variáveis uniformes é feita nas linhas 62 e 68. As funções glUniform* têm como primeiro parâmetro a localização da variável uniforme que será modificada, seguida de uma lista de parâmetros que depende do sufixo no fim de glUniform: Em glUniform2fv, 2fv significa que a variável uniforme é um arranjo de tuplas de dois valores do tipo float, isto é, um arranjo de vec2. Nesse caso, o segundo parâmetro é a quantidade de vec2 que deverão ser copiados para a variável uniforme do shader. O argumento é 1 porque translation não é apenas um vec2. O terceiro parâmetro é o endereço do primeiro elemento do conjunto de dados que serão copiados. Em glUniform1f, 1f significa que a variável uniforme é apenas um valor do tipo float. Nesse caso, o segundo parâmetro é simplesmente o valor float. Observação O formato geral de glUniform é glUniform{1|2|3|4}{f|i|ui}[v]: {1|2|3|4} define o número de componentes do tipo de dado: 1 para float, int, unsigned int e bool; 2 para vec2, ivec2, uvec2, bvec2; 3 para vec3, ivec3, uvec3, bvec3; 4 para vec4, ivec4, uvec4, bvec4. {f|i|ui} define o tipo de dado de cada componente: f para float, vec2, vec3, vec4; i para int, ivec2, ivec3, ivec4; ui para unsigned int, uvec2, uvec3, uvec4. Tanto f, i e ui podem ser usados para copiar dados para variáveis uniformes booleanas (bool, bvec2, bvec3, bvec4). Nesse caso, true é qualquer valor diferente de zero. Se o v final não é especificado, então {1|2|3|4} é também o número de parâmetros após o identificador de localização. Por exemplo: // Variável uniform é um float ou bool glUniform1f(loc, 3.14f); // Variável uniform é um unsigned int ou bool glUniform1ui(loc, 42); // Variável uniform é um vec2 ou bvec2 glUniform2f(loc, 0.0f, 10.5f); // Variável uniform é um ivec4 ou bvec4 glUniform4i(loc, -1, 2, 10, 3); Se o v é especificado, o segundo parâmetro é o número de elementos do arranjo, e o terceiro parâmetro é o ponteiro para os dados. Por exemplo: // Variável uniform é um float ou bool float pi{3.14f}; glUniform1fv(loc, 1, &amp;pi); // Variável uniform é um unsigned int ou bool unsigned int answer{42}; glUniform1uiv(loc, 1, &amp;answer); // Variável uniform é um vec2 ou bvec2 glm::vec2 foo{0.0f, 10.5f}; glUniform2fv(loc, 1, &amp;foo.x); // Variável uniform é um ivec4[2] ou bvec4[2] std::array bar{glm::ivec4{-1, 2, 10, 3}, glm::ivec4{7, -5, 1, 90}}; glUniform4iv(loc, 2, &amp;bar.at(0).x); Nas linhas 71 a 73 temos a chamada ao comando de renderização: // Render abcg::glBindVertexArray(m_VAO); abcg::glDrawArrays(GL_TRIANGLE_FAN, 0, sides + 2); abcg::glBindVertexArray(0); O VAO é vinculado na linha 71. O resultado é a ativação e configuração da ligação dos VBOs com o programa de shader. O comando de renderização é chamado na linha 72. Observe o uso da constante GL_TRIANGLE_FAN. O número de vértices é sides + 2 porque definiremos nossos polígonos de tal modo que o número de vértices será sempre o número de lados mais dois, como mostra a figura 6.2 para a definição de um pentágono: Figura 6.2: Pentágono formado por um leque de sete vértices. No pentágono, o vértice de índice 6 tem a mesma posição do vértice de índice 1 para “fechar” o leque de triângulos. Na verdade, o leque poderia definir um pentágono com apenas cinco vértices, como mostra a figura 6.3: Figura 6.3: Pentágono formado por um leque de cinco vértices. A escolha de manter o vértice de índice 0 no centro é proposital pois permite simular um efeito de gradiente de cor parecido com um gradiente radial. Para isto, basta atribuir uma cor ao vértice 0, e outra cor aos demais vértices. Como os atributos dos vértices são interpolados linearmente pelo rasterizador para cada fragmento gerado, o resultado será um degradê de cor. A figura 6.4 mostra um exemplo usando amarelo no vértice central e azul nos demais vértices: Figura 6.4: Pentágono com gradiente de cor formado através da interpolação do atributo de cor dos vértices. Continuando com a definição das funções membro da classe Window, definiremos Window::onPaintUI usando o código a seguir. O código é bem parecido com o do projeto anterior. A diferença é que, no lugar de ImGui::ColorEdit3, criaremos um slider para controlar o valor de m_delay e criaremos um botão para limpar a janela: void Window::onPaintUI() { abcg::OpenGLWindow::onPaintUI(); { auto const widgetSize{ImVec2(200, 72)}; ImGui::SetNextWindowPos(ImVec2(m_viewportSize.x - widgetSize.x - 5, m_viewportSize.y - widgetSize.y - 5)); ImGui::SetNextWindowSize(widgetSize); auto const windowFlags{ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar}; ImGui::Begin(&quot; &quot;, nullptr, windowFlags); ImGui::PushItemWidth(140); ImGui::SliderInt(&quot;Delay&quot;, &amp;m_delay, 0, 200, &quot;%d ms&quot;); ImGui::PopItemWidth(); if (ImGui::Button(&quot;Clear window&quot;, ImVec2(-1, 30))) { abcg::glClear(GL_COLOR_BUFFER_BIT); } ImGui::End(); } } A definição de Window::onResize e Window::onDestroy é idêntica à do projeto anterior: void Window::onResize(glm::ivec2 const &amp;size) { m_viewportSize = size; abcg::glClear(GL_COLOR_BUFFER_BIT); } void Window::onDestroy() { abcg::glDeleteProgram(m_program); abcg::glDeleteBuffers(1, &amp;m_VBOPositions); abcg::glDeleteBuffers(1, &amp;m_VBOColors); abcg::glDeleteVertexArrays(1, &amp;m_VAO); } Vamos agora à definição da função Window::setupModel. O código completo é mostrado abaixo, mas analisaremos cada trecho em seguida: void Window::setupModel(int sides) { // Release previous resources, if any abcg::glDeleteBuffers(1, &amp;m_VBOPositions); abcg::glDeleteBuffers(1, &amp;m_VBOColors); abcg::glDeleteVertexArrays(1, &amp;m_VAO); // Select random colors for the radial gradient std::uniform_real_distribution rd(0.0f, 1.0f); glm::vec3 const color1{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)}; glm::vec3 const color2{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)}; // Minimum number of sides is 3 sides = std::max(3, sides); std::vector&lt;glm::vec2&gt; positions; std::vector&lt;glm::vec3&gt; colors; // Polygon center positions.emplace_back(0, 0); colors.push_back(color1); // Border vertices auto const step{M_PI * 2 / sides}; for (auto const angle : iter::range(0.0, M_PI * 2, step)) { positions.emplace_back(std::cos(angle), std::sin(angle)); colors.push_back(color2); } // Duplicate second vertex positions.push_back(positions.at(1)); colors.push_back(color2); // Generate VBO of positions abcg::glGenBuffers(1, &amp;m_VBOPositions); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOPositions); abcg::glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(glm::vec2), positions.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Generate VBO of colors abcg::glGenBuffers(1, &amp;m_VBOColors); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOColors); abcg::glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(glm::vec3), colors.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Get location of attributes in the program auto const positionAttribute{ abcg::glGetAttribLocation(m_program, &quot;inPosition&quot;)}; auto const colorAttribute{abcg::glGetAttribLocation(m_program, &quot;inColor&quot;)}; // Create VAO abcg::glGenVertexArrays(1, &amp;m_VAO); // Bind vertex attributes to current VAO abcg::glBindVertexArray(m_VAO); abcg::glEnableVertexAttribArray(positionAttribute); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOPositions); abcg::glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); abcg::glEnableVertexAttribArray(colorAttribute); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOColors); abcg::glVertexAttribPointer(colorAttribute, 3, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // End of binding to current VAO abcg::glBindVertexArray(0); } No início da função, os VBOs e o VAO são liberados caso tenham sido criados anteriormente: // Release previous resources, if any abcg::glDeleteBuffers(1, &amp;m_VBOPositions); abcg::glDeleteBuffers(1, &amp;m_VBOColors); abcg::glDeleteVertexArrays(1, &amp;m_VAO); Em seguida, temos o código que cria os vértices do polígono regular (arranjos positions e colors): // Select random colors for the radial gradient std::uniform_real_distribution rd(0.0f, 1.0f); glm::vec3 const color1{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)}; glm::vec3 const color2{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)}; // Minimum number of sides is 3 sides = std::max(3, sides); std::vector&lt;glm::vec2&gt; positions; std::vector&lt;glm::vec3&gt; colors; // Polygon center positions.emplace_back(0, 0); colors.push_back(color1); // Border vertices auto const step{M_PI * 2 / sides}; for (auto const angle : iter::range(0.0, M_PI * 2, step)) { positions.emplace_back(std::cos(angle), std::sin(angle)); colors.push_back(color2); } // Duplicate second vertex positions.push_back(positions.at(1)); colors.push_back(color2); Duas cores RGB são sorteadas nas linhas 124 e 126. color1 é utilizada na definição do vértice do centro (linhas 137), e color2 é utilizada para os demais vértices (linha 143). Nas linhas 140 a 144, a posição dos vértices é calculada usando a equação paramétrica de um círculo unitário na origem: \\[ \\begin{eqnarray} x&amp;=&amp;cos(t),\\\\ y&amp;=&amp;sin(t), \\end{eqnarray} \\] onde \\(t\\) é o ângulo (angle) que varia de \\(0\\) a \\(2\\pi\\) usando um tamanho do passo (step) igual à divisão de \\(2\\pi\\) pelo número de lados do polígono. A definição dos VBOs é semelhante à forma utilizada no projeto anterior. Nas linhas 175 a 185 é definido como os dados dos VBOs serão mapeados para a entrada do vertex shader. Vamos nos concentrar na definição do mapeamento de m_VBOPositions (o mapeamento de m_VBOColors é similar): abcg::glEnableVertexAttribArray(positionAttribute); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOPositions); abcg::glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); Na linha 175, glEnableVertexAttribArray habilita o atributo de posição do vértice (inPosition) para ser utilizado durante a renderização. Em seguida, glBindBuffer vincula o VBO m_VBOPositions, que contém os dados das posições dos vértices. Na linha 177, glVertexAttribPointer define como os dados do VBO serão mapeados para o atributo. Lembre-se que o VBO é apenas um arranjo linear de bytes copiados pela função glBufferData. Com glVertexAttribPointer, informamos ao OpenGL como esses bytes devem ser mapeados para uma variável de atributo de entrada do vertex shader. A assinatura de glVertexAttribPointer é a seguinte: void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer); Os parâmetros são: index: índice do atributo que será modificado. No nosso caso (linha 175) é positionAttribute. size: número de componentes do atributo. No nosso caso é 2 pois inPosition é um vec2, isto é, um atributo de dois componentes. type: tipo de dado de cada valor do VBO. Usamos GL_FLOAT pois cada coordenada \\(x\\) e \\(y\\) do VBO de posições é um float. normalized: flag que indica se valores inteiros devem ser normalizados para \\([-1,1]\\) (para valores com sinal) ou \\([0,1]\\) (para valores sem sinal) quando forem enviados ao atributo. Usamos GL_FALSE porque nossas coordenadas são valores do tipo float; stride: é o número de bytes entre o início do atributo de um vértice e o início do atributo do próximo vértice no arranjo linear. O argumento 0 que utilizamos indica que não há bytes extras entre uma posição \\((x,y)\\) e a posição \\((x,y)\\) do vértice seguinte. pointer: apesar do nome, não é um ponteiro, mas um deslocamento em bytes a partir do início do arranjo linear, e que corresponde à posição do primeiro componente do atributo. Usamos nullptr, que corresponde a zero, pois não há bytes extras no início do VBO antes da primeira posição \\((x,y)\\). Observação Os parâmetros stride e pointer de glVertexAttribPointer podem ser utilizados para especificar o mapeamento de VBOs que contém dados intercalados (interleaved data). Nosso m_VBOPositions não usa dados intercalados. O arranjo contém apenas posições \\((x,y)\\) em sequência. Assim, para um triângulo (três vértices), o VBO representa um arranjo no formato \\[[\\underline{x,\\; y},\\; \\; x,\\; y,\\; \\; x,\\; y],\\] onde cada grupo de \\((x, y)\\) é a posição de um vértice, e tanto \\(x\\) quanto \\(y\\) são do tipo float3. Da mesma forma, m_VBOColors não usa dados intercalados. Para a definição das cores dos vértices de um triângulo, o arranjo tem o formato: \\[[\\underline{r,\\; g,\\; b},\\; \\; r,\\; g,\\; b,\\; \\; r,\\; g,\\; b],\\] onde cada grupo de \\((r,g,b)\\) define a cor de um vértice, e \\(r\\), \\(g\\) e \\(b\\) também são do tipo float. Quando os dados não são intercalados, podemos especificar 0 como argumento de stride, que é o que fizemos. Além disso, pointer também é 0. Suponha agora que os dados tenham sido intercalados em um único VBO no seguinte formato: \\[[\\underline{x,\\; y,\\; r,\\; g,\\; b},\\; \\; x,\\; y,\\; r,\\; g,\\; b,\\; \\; x,\\; y,\\; r,\\; g,\\; b].\\] Agora, o atributo de posição \\((x,y)\\) tem um stride que corresponde à quantidade de bytes contida em \\((x,y,r,g,b)\\). Esse valor é 20 se cada float tiver 4 bytes (5 \\(\\times\\) 4 = 20 bytes). pointer continua sendo 0, pois não há deslocamento no início do arranjo. O atributo de cor \\((r,g,b)\\) também tem um stride de 20 bytes. Entretanto, pointer (deslocamento a partir do início) precisa ser 8, pois \\(x\\) e \\(y\\) ocupam 8 bytes antes do início do primeiro grupo de \\((r,g,b)\\). Suponha agora um único VBO no formato a seguir: \\[[\\underline{x,\\; y},\\; \\; x,\\; y,\\; \\; x,\\; y,\\; \\; \\underline{r,\\; g,\\; b},\\; \\; r,\\; g,\\; b,\\; \\; r,\\; g,\\; b].\\] Nesse VBO, o stride da posição pode ser 0, pois após um grupo de \\((x,y)\\) há imediatamente outro \\((x,y)\\)4. O stride da cor também pode ser 0 pelo mesmo raciocínio. Entretanto, o pointer para o atributo de cor precisa ser 24 (3 vértices \\(\\times\\) 8 bytes por vértices = 24 bytes), pois o primeiro grupo de \\((r,g,b)\\) ocorre apenas depois de três grupos de \\((x,y)\\). Com todas essas opções de formatação de VBOs, não há uma forma mais certa ou mais recomendada de organizar os dados. É possível que algum driver use algum formato de forma mais eficiente, mas isso só pode ser determinado através de medição de tempo. Na prática, use o formato que melhor fizer sentido para o caso de uso. Para simplificar, fizemos as contas supondo 4 bytes por float, mas lembre-se sempre de usar sizeof(float) pois o tamanho de um float pode variar dependendo da arquitetura. O código completo de window.cpp é mostrado a seguir: #include &quot;window.hpp&quot; void Window::onCreate() { auto const *vertexShader{R&quot;gl(#version 300 es layout(location = 0) in vec2 inPosition; layout(location = 1) in vec4 inColor; uniform vec2 translation; uniform float scale; out vec4 fragColor; void main() { vec2 newPosition = inPosition * scale + translation; gl_Position = vec4(newPosition, 0, 1); fragColor = inColor; } )gl&quot;}; auto const *fragmentShader{R&quot;gl(#version 300 es precision mediump float; in vec4 fragColor; out vec4 outColor; void main() { outColor = fragColor; } )gl&quot;}; m_program = abcg::createOpenGLProgram( {{.source = vertexShader, .stage = abcg::ShaderStage::Vertex}, {.source = fragmentShader, .stage = abcg::ShaderStage::Fragment}}); abcg::glClearColor(0, 0, 0, 1); abcg::glClear(GL_COLOR_BUFFER_BIT); m_randomEngine.seed( std::chrono::steady_clock::now().time_since_epoch().count()); } void Window::onPaint() { if (m_timer.elapsed() &lt; m_delay / 1000.0) return; m_timer.restart(); // Create a regular polygon with number of sides in the range [3,20] std::uniform_int_distribution intDist(3, 20); auto const sides{intDist(m_randomEngine)}; setupModel(sides); abcg::glViewport(0, 0, m_viewportSize.x, m_viewportSize.y); abcg::glUseProgram(m_program); // Pick a random xy position from (-1,-1) to (1,1) std::uniform_real_distribution rd1(-1.0f, 1.0f); glm::vec2 const translation{rd1(m_randomEngine), rd1(m_randomEngine)}; auto const translationLocation{ abcg::glGetUniformLocation(m_program, &quot;translation&quot;)}; abcg::glUniform2fv(translationLocation, 1, &amp;translation.x); // Pick a random scale factor (1% to 25%) std::uniform_real_distribution rd2(0.01f, 0.25f); auto const scale{rd2(m_randomEngine)}; auto const scaleLocation{abcg::glGetUniformLocation(m_program, &quot;scale&quot;)}; abcg::glUniform1f(scaleLocation, scale); // Render abcg::glBindVertexArray(m_VAO); abcg::glDrawArrays(GL_TRIANGLE_FAN, 0, sides + 2); abcg::glBindVertexArray(0); abcg::glUseProgram(0); } void Window::onPaintUI() { abcg::OpenGLWindow::onPaintUI(); { auto const widgetSize{ImVec2(200, 72)}; ImGui::SetNextWindowPos(ImVec2(m_viewportSize.x - widgetSize.x - 5, m_viewportSize.y - widgetSize.y - 5)); ImGui::SetNextWindowSize(widgetSize); auto const windowFlags{ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar}; ImGui::Begin(&quot; &quot;, nullptr, windowFlags); ImGui::PushItemWidth(140); ImGui::SliderInt(&quot;Delay&quot;, &amp;m_delay, 0, 200, &quot;%d ms&quot;); ImGui::PopItemWidth(); if (ImGui::Button(&quot;Clear window&quot;, ImVec2(-1, 30))) { abcg::glClear(GL_COLOR_BUFFER_BIT); } ImGui::End(); } } void Window::onResize(glm::ivec2 const &amp;size) { m_viewportSize = size; abcg::glClear(GL_COLOR_BUFFER_BIT); } void Window::onDestroy() { abcg::glDeleteProgram(m_program); abcg::glDeleteBuffers(1, &amp;m_VBOPositions); abcg::glDeleteBuffers(1, &amp;m_VBOColors); abcg::glDeleteVertexArrays(1, &amp;m_VAO); } void Window::setupModel(int sides) { // Release previous resources, if any abcg::glDeleteBuffers(1, &amp;m_VBOPositions); abcg::glDeleteBuffers(1, &amp;m_VBOColors); abcg::glDeleteVertexArrays(1, &amp;m_VAO); // Select random colors for the radial gradient std::uniform_real_distribution rd(0.0f, 1.0f); glm::vec3 const color1{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)}; glm::vec3 const color2{rd(m_randomEngine), rd(m_randomEngine), rd(m_randomEngine)}; // Minimum number of sides is 3 sides = std::max(3, sides); std::vector&lt;glm::vec2&gt; positions; std::vector&lt;glm::vec3&gt; colors; // Polygon center positions.emplace_back(0, 0); colors.push_back(color1); // Border vertices auto const step{M_PI * 2 / sides}; for (auto const angle : iter::range(0.0, M_PI * 2, step)) { positions.emplace_back(std::cos(angle), std::sin(angle)); colors.push_back(color2); } // Duplicate second vertex positions.push_back(positions.at(1)); colors.push_back(color2); // Generate VBO of positions abcg::glGenBuffers(1, &amp;m_VBOPositions); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOPositions); abcg::glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(glm::vec2), positions.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Generate VBO of colors abcg::glGenBuffers(1, &amp;m_VBOColors); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOColors); abcg::glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(glm::vec3), colors.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Get location of attributes in the program auto const positionAttribute{ abcg::glGetAttribLocation(m_program, &quot;inPosition&quot;)}; auto const colorAttribute{abcg::glGetAttribLocation(m_program, &quot;inColor&quot;)}; // Create VAO abcg::glGenVertexArrays(1, &amp;m_VAO); // Bind vertex attributes to current VAO abcg::glBindVertexArray(m_VAO); abcg::glEnableVertexAttribArray(positionAttribute); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOPositions); abcg::glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); abcg::glEnableVertexAttribArray(colorAttribute); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBOColors); abcg::glVertexAttribPointer(colorAttribute, 3, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // End of binding to current VAO abcg::glBindVertexArray(0); } O código completo do projeto pode ser baixado deste link. Agora que vimos como usar variáveis uniformes para fazer transformações geométricas no vertex shader e como organizar os dados de um VBO de diferentes maneiras, vamos ao jogo! Como veremos posteriomente, é possível reduzir esse número com o uso de geometria indexada, mas ainda assim o consumo de memória seria alto para este caso.↩︎ Os dados que correspondem ao primeiro vértice são sublinhados para facilitar a visualização. Nos exemplos subsequentes, os dados do primeiro vértice também são sublinhados.↩︎ O stride nesse caso também pode ser 8 bytes (4 bytes para \\(x\\), mais 4 para \\(y\\)), mas o argumento 0 serve para indicar que os atributos estão agrupados de forma “apertada”.↩︎ "],["asteroids.html", "6.2 Asteroids", " 6.2 Asteroids O cenário do jogo Asteroids será composto pelos seguintes objetos: Uma nave espacial, formada por GL_TRIANGLES; Asteroides, formados por GL_TRIANGLE_FAN; Tiros, formados por GL_TRIANGLE_FAN; Estrelas de fundo, formadas por GL_POINTS. Como nas aplicações feitas até agora, trabalharemos somente com gráficos 2D. As coordenadas de todos os objetos do jogo serão especificadas no chamado NDC (espaço normalizado do dispositivo). Como vimos na seção 5.3, para que as primitivas sejam renderizadas, as coordenadas em NDC devem estar dentro do volume de visão canônico, que é um cubo de \\((-1, -1, -1)\\) a \\((1, 1, 1)\\). Também vimos que coordenadas em NDC são mapeadas para o espaço da janela, de modo que o ponto \\((-1,-1)\\) é mapeado para o canto inferior esquerdo do viewport, e \\((1,1)\\) é mapeado para o canto superior direito, de acordo com o especificado em glViewport. A figura 6.5 ilustra o posicionamento de objetos da cena recortados pela região visível do NDC. Figura 6.5: Objetos de cena na região visível do NDC. No jogo Asteroids original, a nave se movimenta pela tela enquanto a câmera virtual permanece fixa. Quando a nave sai dos limites da tela, reaparece no lado oposto. No nosso projeto, a nave se manterá fixa no centro da tela, enquanto todo o resto se moverá ao seu redor. O espaço será finito como no Asteroids original, e terá o tamanho da região que vai de \\((-1,-1)\\) a \\((1,1)\\). Se um asteroide sair do lado esquerdo da tela, reaparecerá no lado direito (observe que isso acontece na figura 6.5). Um truque simples para obter o efeito de replicação do espaço é renderizar a cena nove vezes, uma vez para célula de uma grade 3x3 na qual apenas a célula do meio corresponde à região de \\((-1,-1)\\) a \\((1,1)\\). Isso é ilustrado na figura 6.6: Figura 6.6: Replicando a cena em torno da região visível do NDC. Não é necessário replicar os objetos que não saem da tela, como a nave. No nosso caso, os tiros também não serão replicados e deixarão de existir assim que saírem da tela. Embora esse truque de replicação de cena funcione bem para este jogo simples, em cenas mais complexas é recomendável fazer testes de proximidade para não desenhar os objetos que estão totalmente fora da área visível. Isso evita processamento desnecessário no pipeline gráfico. Organização do projeto Nosso jogo possui vários objetos de cena, e portanto possui potencialmente vários VBOs, VAOs e variáveis de propriedades desses objetos. Precisamos pensar bem em como organizar tudo isso. O código pode ficar bastante confuso se definirmos tudo na classe Window como fizemos nos projetos anteriores. Organização das classes Para organizar melhor o projeto, separaremos os elementos de cena do jogo nas seguintes classes: Ship: classe que representará a nave espacial (VAO, VBO e atributos como translação, orientação e velocidade). StarLayers: classe que gerenciará as camadas de estrelas usadas para fazer o efeito de paralaxe de fundo5. StarLayers conterá um arranjo de objetos do tipo StarLayer, sendo que cada StarLayer definirá o VBO de pontos de uma camada de estrelas. Bullets: classe que gerencia os tiros. A classe terá uma lista de instâncias de uma estrutura Bullet, sendo que cada Bullet representará as propriedades de um tiro (translação, velocidade, etc). Todos os tiros compartilharão um mesmo VBO definido como membro de Bullets. Asteroids: classe que gerenciará os asteroides. Asteroids conterá uma lista de instâncias de uma estrutura Asteroid, sendo que cada Asteroid definirá o VBO e as propriedades de um asteroide. As classes Ship, StarLayers, Bullets e Asteroids terão funções públicas create, paint e destroy que serão chamadas respectivamente nas funções onCreate, onPaint e onDestroy de Window. Definiremos também uma classe GameData para permitir o compartilhamento dos dados de estado do jogo entre Window e as outras classes. Organização dos arquivos O diretório de projeto abcg/examples/asteroids terá a seguinte estrutura: asteroids/ │ asteroids.cpp │ asteroids.hpp │ bullets.cpp │ bullets.hpp │ CMakeLists.txt │ gamedata.hpp │ main.cpp │ window.hpp │ window.cpp │ ship.cpp │ ship.hpp │ starlayers.cpp │ starlayers.hpp │ └───assets/ │ Inconsolata-Medium.ttf │ objects.frag │ objects.vert │ stars.frag └ stars.vert O subdiretório assets terá os seguintes arquivos de recursos utilizados no jogo: Inconsolata-Medium.ttf: fonte Inconsolata utilizada na mensagem “Game Over” e “You Win”. É a mesma fonte que utilizados no projeto tictactoe (seção 3.4). stars.vert e stars.frag: código-fonte do vertex shader e fragment shader utilizados para renderizar as estrelas. objects.vert e objects.frag: código-fonte do vertex shader e fragment shader utilizados em todos os outros objetos: nave, asteroides e tiros. Poderíamos continuar definindo os shaders através de strings, como fizemos até agora, mas o projeto fica mais organizado desta nova forma. Observação Quando o projeto é compilado para WebAssembly, o conteúdo de assets é transformado em um arquivo .data no diretório public. Assim, os arquivos resultantes de um projeto chamado proj são: proj.data: arquivo de recursos (assets); proj.js: arquivo JavaScript que deve ser chamado pelo html; proj.wasm: binário WebAssembly. Configuração inicial Em abcg/examples, crie o subdiretório asteroids. No arquivo abcg/examples/CMakeLists.txt, inclua a linha add_subdirectory(asteroids). Crie o arquivo abcg/examples/asteroids/CMakeLists.txt com o seguinte conteúdo: project(asteroids) add_executable(${PROJECT_NAME} main.cpp window.cpp asteroids.cpp bullets.cpp ship.cpp starlayers.cpp) enable_abcg(${PROJECT_NAME}) Crie todos os arquivos .cpp e .hpp (de asteroids.cpp até starlayers.cpp). Por enquanto eles ficarão vazios. Crie o subdiretório assets e baixe/copie a fonte .ttf. Crie também os arquivos .frag e .vert. Vamos editá-los em seguida. main.cpp Não há nada de realmente novo no conteúdo de main.cpp. Apenas desativaremos o contador de FPS e o botão de tela cheia. O código ficará assim: #include &quot;window.hpp&quot; int main(int argc, char **argv) { try { abcg::Application app(argc, argv); Window window; window.setOpenGLSettings({.samples = 4}); window.setWindowSettings({ .width = 600, .height = 600, .showFPS = false, .showFullscreenButton = false, .title = &quot;Asteroids&quot;, }); app.run(window); } catch (std::exception const &amp;exception) { fmt::print(stderr, &quot;{}\\n&quot;, exception.what()); return -1; } return 0; } gamedata.hpp Neste arquivo definiremos uma estrutura GameData que descreve o estado atual do jogo e o estado dos dispositivos de entrada: #ifndef GAMEDATA_HPP_ #define GAMEDATA_HPP_ #include &lt;bitset&gt; enum class Input { Right, Left, Down, Up, Fire }; enum class State { Playing, GameOver, Win }; struct GameData { State m_state{State::Playing}; std::bitset&lt;5&gt; m_input; // [fire, up, down, left, right] }; #endif m_state pode ser: State::Playing: a aplicação está em modo de jogo, com a nave respondendo aos comandos do jogador; State::GameOver: o jogador perdeu. Nesse caso a nave não é exibida e não responde aos comandos do jogador; State::Win: o jogador ganhou. A nave também não é exibida neste estado. m_input é uma máscara de 5 bits setados em resposta a eventos dos dispositivos de entrada. Por exemplo, o bit 0 corresponde a Input::Right e está setado enquanto o usuário pressiona a seta para a direita ou a tecla D. Esse estado é atualizado pela função membro Window::onEvent que veremos adiante. A classe Window manterá um objeto GameData que será compartilhado com outras classes (Ship, Bullets, Asteroids, etc) sempre que elas precisarem ler ou modificar o estado do jogo. objects.vert Esse é o shader utilizado na renderização da nave, asteroides e tiros. O conteúdo será como a seguir: #version 300 es layout(location = 0) in vec2 inPosition; uniform vec4 color; uniform float rotation; uniform float scale; uniform vec2 translation; out vec4 fragColor; void main() { float sinAngle = sin(rotation); float cosAngle = cos(rotation); vec2 rotated = vec2(inPosition.x * cosAngle - inPosition.y * sinAngle, inPosition.x * sinAngle + inPosition.y * cosAngle); vec2 newPosition = rotated * scale + translation; gl_Position = vec4(newPosition, 0, 1); fragColor = color; } Observe que os vértices só possuem um atributo inPosition do tipo vec2. Esse atributo corresponde à posição \\((x,y)\\) do vértice. A saída do vertex shader é uma cor RGBA definida pela variável uniforme color. Isso significa que, usando esse shader, todos os vértices terão a mesma cor. O código de main é similar ao do vertex shader do projeto regularpolygons, mas dessa vez a posição é modificada não apenas por um fator de escala e translação, mas também por uma rotação. As linhas 13 a 16 fazem com que a posição inPosition seja rodada pelo ângulo rotation (em radianos) no sentido anti-horário. O resultado é uma nova posição rotated que é então transformada pela escala e translação (linha 18). Em capítulos futuros, veremos a teoria das transformações geométricas e os passos necessários para se chegar à expressão das linhas 15 e 16. Observação Todos os objetos do jogo são desenhados em tons de cinza, mas não há nada nos shaders que impeça que utilizemos cores. O aspecto preto e branco do jogo é só uma escolha estética para lembrar o antigo Asteroids do arcade. objects.frag O conteúdo desse fragment shader que acompanha objects.vert é o mesmo dos projetos anteriores. A cor de entrada é copiada para a cor de saída: #version 300 es precision mediump float; in vec4 fragColor; out vec4 outColor; void main() { outColor = fragColor; } Nave Para simplificar, faremos primeiramente o código para desenhar e animar a nave. Em seguida incluiremos o código das estrelas, asteroides, e por fim os tiros e a detecção de colisões. window.hpp O conteúdo de window.hpp ficará como a seguir: #ifndef WINDOW_HPP_ #define WINDOW_HPP_ #include &lt;random&gt; #include &quot;abcgOpenGL.hpp&quot; #include &quot;asteroids.hpp&quot; #include &quot;bullets.hpp&quot; #include &quot;ship.hpp&quot; #include &quot;starlayers.hpp&quot; class Window : public abcg::OpenGLWindow { protected: void onEvent(SDL_Event const &amp;event) override; void onCreate() override; void onUpdate() override; void onPaint() override; void onPaintUI() override; void onResize(glm::ivec2 const &amp;size) override; void onDestroy() override; private: glm::ivec2 m_viewportSize{}; GLuint m_objectsProgram{}; GameData m_gameData; Ship m_ship; abcg::Timer m_restartWaitTimer; ImFont *m_font{}; std::default_random_engine m_randomEngine; void restart(); }; #endif m_objectsProgram é o identificador do par de shaders objects.vert e objects.frag. m_gameData é a instância de GameData com o estado do jogo e dos dispositivos de entrada. m_ship é a instância da classe Ship que gerencia a nave. m_restartWaitTimer é um temporizador utilizado para fazer com que o jogo seja reiniciado em cinco segundos após o fim de jogo. m_font representa a fonte que será utilizada pela ImGui para escrever “Game Over” e “Win” na tela. Observe que há uma nova função membro onEvent que substitui uma função virtual da classe base. onEvent é chamada pela ABCg sempre que ocorre algum evento da SDL, incluindo os eventos dos dispositivos de entrada. Neste projeto, usaremos onEvent para atualizar a máscara de bits m_input de m_gameData. Na linha 38 há a declaração de uma função membro restart. Essa função será chamada sempre que quisermos reiniciar o estado do jogo. Há também a função membro onUpdate na linha 17. onUpdate é chamada pela ABCg imediatamente antes de cada onPaint. Nessa função incluiremos o código responsável por atualizar a posição dos objetos da cena para torná-la animada. Observação Poderíamos ter colocado o código de onUpdate em onPaint diretamente, mas o programa fica mais organizado fazendo essa separação entre a animação e a renderização. onPaint não tem exatamente a mesma funcionalidade de onUpdate: onPaint não é chamada quando a janela está minimizada, enquanto onUpdate é chamada incondicionalmente. window.cpp Em window.cpp, começaremos com a definição de Window::onEvent: #include &quot;window.hpp&quot; void Window::onEvent(SDL_Event const &amp;event) { // Keyboard events if (event.type == SDL_KEYDOWN) { if (event.key.keysym.sym == SDLK_SPACE) m_gameData.m_input.set(gsl::narrow&lt;size_t&gt;(Input::Fire)); if (event.key.keysym.sym == SDLK_UP || event.key.keysym.sym == SDLK_w) m_gameData.m_input.set(gsl::narrow&lt;size_t&gt;(Input::Up)); if (event.key.keysym.sym == SDLK_DOWN || event.key.keysym.sym == SDLK_s) m_gameData.m_input.set(gsl::narrow&lt;size_t&gt;(Input::Down)); if (event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_a) m_gameData.m_input.set(gsl::narrow&lt;size_t&gt;(Input::Left)); if (event.key.keysym.sym == SDLK_RIGHT || event.key.keysym.sym == SDLK_d) m_gameData.m_input.set(gsl::narrow&lt;size_t&gt;(Input::Right)); } if (event.type == SDL_KEYUP) { if (event.key.keysym.sym == SDLK_SPACE) m_gameData.m_input.reset(gsl::narrow&lt;size_t&gt;(Input::Fire)); if (event.key.keysym.sym == SDLK_UP || event.key.keysym.sym == SDLK_w) m_gameData.m_input.reset(gsl::narrow&lt;size_t&gt;(Input::Up)); if (event.key.keysym.sym == SDLK_DOWN || event.key.keysym.sym == SDLK_s) m_gameData.m_input.reset(gsl::narrow&lt;size_t&gt;(Input::Down)); if (event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_a) m_gameData.m_input.reset(gsl::narrow&lt;size_t&gt;(Input::Left)); if (event.key.keysym.sym == SDLK_RIGHT || event.key.keysym.sym == SDLK_d) m_gameData.m_input.reset(gsl::narrow&lt;size_t&gt;(Input::Right)); } // Mouse events if (event.type == SDL_MOUSEBUTTONDOWN) { if (event.button.button == SDL_BUTTON_LEFT) m_gameData.m_input.set(gsl::narrow&lt;size_t&gt;(Input::Fire)); if (event.button.button == SDL_BUTTON_RIGHT) m_gameData.m_input.set(gsl::narrow&lt;size_t&gt;(Input::Up)); } if (event.type == SDL_MOUSEBUTTONUP) { if (event.button.button == SDL_BUTTON_LEFT) m_gameData.m_input.reset(gsl::narrow&lt;size_t&gt;(Input::Fire)); if (event.button.button == SDL_BUTTON_RIGHT) m_gameData.m_input.reset(gsl::narrow&lt;size_t&gt;(Input::Up)); } if (event.type == SDL_MOUSEMOTION) { glm::ivec2 mousePosition; SDL_GetMouseState(&amp;mousePosition.x, &amp;mousePosition.y); glm::vec2 direction{mousePosition.x - m_viewportSize.x / 2, -(mousePosition.y - m_viewportSize.y / 2)}; m_ship.m_rotation = std::atan2(direction.y, direction.x) - M_PI_2; } } Os dados do evento são descritos pelo parâmetro event que é uma estrutura SDL_Event da SDL. Os eventos do teclado são divididos em eventos de pressionamento de teclas (SDL_KEYDOWN), tratados nas linhas 5 a 16, e liberação de teclas (SDL_KEYUP), nas linhas 17 a 28. De acordo com as teclas pressionadas/liberadas, os bits de m_gameData.m_input são setados/resetados. Os eventos do mouse são divididos em eventos de pressionamento (SDL_MOUSEBUTTONDOWN) e liberação (SDL_MOUSEBUTTONUP) dos botões, e eventos de movimentação do mouse (SDL_MOUSEMOTION). Quando ocorre a movimentação do mouse, as coordenadas \\((x,y)\\) do cursor são lidas com SDL_GetMouseState (linha 45) e convertidas para um vetor direction (linhas 47 e 48) definido pelo ponto que sai do centro da janela e vai até a posição do cursor. A coordenada \\(y\\) é invertida na linha 48 porque, no sistema de coordenadas do mouse, o eixo \\(y\\) é positivo para baixo, enquanto que no OpenGL é positivo para cima. Na linha 50, o ângulo de rotação da nave é definido como o ângulo subentendido pelo vetor direction. A função atan2 retorna o ângulo entre o vetor direction e o eixo \\(x\\) positivo. Desse valor é subtraído \\(\\pi/2\\) (90 graus) pois a orientação inicial da nave já é de 90 graus (a nave está “olhando” na direção do eixo \\(y\\) e não na direção do eixo \\(x\\)). Vamos agora à definição de Window::onCreate: void Window::onCreate() { auto const assetsPath{abcg::Application::getAssetsPath()}; // Load a new font auto const filename{assetsPath + &quot;Inconsolata-Medium.ttf&quot;}; m_font = ImGui::GetIO().Fonts-&gt;AddFontFromFileTTF(filename.c_str(), 60.0f); if (m_font == nullptr) { throw abcg::RuntimeError(&quot;Cannot load font file&quot;); } // Create program to render the other objects m_objectsProgram = abcg::createOpenGLProgram({{.source = assetsPath + &quot;objects.vert&quot;, .stage = abcg::ShaderStage::Vertex}, {.source = assetsPath + &quot;objects.frag&quot;, .stage = abcg::ShaderStage::Fragment}}); abcg::glClearColor(0, 0, 0, 1); #if !defined(__EMSCRIPTEN__) abcg::glEnable(GL_PROGRAM_POINT_SIZE); #endif // Start pseudo-random number generator m_randomEngine.seed( std::chrono::steady_clock::now().time_since_epoch().count()); restart(); } Nas linhas 57 a 62 é carregada a fonte TrueType da pasta assets. O tamanho da fonte é definido como 60.0f na chamada à função AddFontFromFileTTF da ImGui. Internamente, a ImGui renderiza cada letra em uma textura que pode ser utilizada posteriormente em onPaintUI para produzir texto com essa fonte e tamanho. Esses dados ficam armazenados em m_font. Na linha 66 é chamada a função createOpenGLProgram da ABCg para compilar e ligar os shaders objects.vert e objects.frag. O restante do código de Window::onCreate contém funções que já usamos em projetos anteriores. Na linha 81 é chamada a função membro restart que reinicia o estado do jogo. A definição de Window::restart ficará como a seguir: void Window::restart() { m_gameData.m_state = State::Playing; m_ship.create(m_objectsProgram); } A função Window::onUpdate será definida como segue: void Window::onUpdate() { auto const deltaTime{gsl::narrow_cast&lt;float&gt;(getDeltaTime())}; // Wait 5 seconds before restarting if (m_gameData.m_state != State::Playing &amp;&amp; m_restartWaitTimer.elapsed() &gt; 5) { restart(); return; } m_ship.update(m_gameData, deltaTime); } Na linha 91, getDeltaTime é uma função membro de abcg::OpenGLWindow que retorna o tempo que se passou, em segundos, desde a última chamada a onPaint (é o “delta” de tempo entre os quadros de exibição). Na linha 100, esse tempo é passado para a função update da nave, junto com o estado do jogo em m_gameData para atualizar a animação da nave. Importante O valor retornado por abcg::OpenGLWindow::getDeltaTime deve ser utilizado para fazer com que a animação dos objetos seja sincronizada pelo tempo e não pela velocidade do computador. Suponha que queremos animar o deslocamento de um asteroide, de x = 0 para a coordenada x = 10 em dois segundos. Para fazer isso, poderíamos incluir a seguinte expressão em onUpdate: x += (10.0 / 2.0) * getDeltaTime(); Isso faz com que x cresça a uma taxa de 5 unidades por segundo, independentemente da velocidade do computador. Em um computador lento, que renderiza a uma taxa de, digamos, 10 FPS, getDeltaTime retornará 0.1 a cada quadro. Em um computador com GPU mais rápida, que renderiza a uma taxa de 100 FPS, getDeltaTime retornará 0.01 a cada quadro. Nos dois casos, a acumulação de getDeltaTime durante um segundo será exatamante 1. Em resumo, sempre utilize getDeltaTime para atualizar os parâmetros de uma animação. Nunca suponha que a velocidade de renderização será fixa. A definição de Window::onPaint ficará assim: void Window::onPaint() { abcg::glClear(GL_COLOR_BUFFER_BIT); abcg::glViewport(0, 0, m_viewportSize.x, m_viewportSize.y); m_ship.paint(m_gameData); } A nave é renderizada usando a função paint que implementaremos em Ship. Em Window::onPaintUI, mostraremos o texto de “Game Over” e “Win” de acordo com o estado do jogo: void Window::onPaintUI() { abcg::OpenGLWindow::onPaintUI(); { auto const size{ImVec2(300, 85)}; auto const position{ImVec2((m_viewportSize.x - size.x) / 2.0f, (m_viewportSize.y - size.y) / 2.0f)}; ImGui::SetNextWindowPos(position); ImGui::SetNextWindowSize(size); ImGuiWindowFlags const flags{ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs}; ImGui::Begin(&quot; &quot;, nullptr, flags); ImGui::PushFont(m_font); if (m_gameData.m_state == State::GameOver) { ImGui::Text(&quot;Game Over!&quot;); } else if (m_gameData.m_state == State::Win) { ImGui::Text(&quot;*You Win!*&quot;); } ImGui::PopFont(); ImGui::End(); } } Nas linhas 119 a 121 definimos os flags da janela da ImGui usando ImGuiWindowFlags_NoBackground para a janela ficar invisível e ImGuiWindowFlags_NoInputs para não receber entrada do teclado. O conteúdo da janela continua visível, de modo que ImGui::Text mostrará o texto sobreposto na tela. Todo o texto exibido entre ImGui::PushFont(m_font) (linha 123) e ImGui::PopFont() (linha 131), usa a fonte m_font, que é a fonte Inconsolata de tamanho 60 criada em Window::onCreate. As funções Window::onResize e Window::onDestroy ficarão como a seguir: void Window::onResize(glm::ivec2 const &amp;size) { m_viewportSize = size; abcg::glClear(GL_COLOR_BUFFER_BIT); } void Window::onDestroy() { abcg::glDeleteProgram(m_objectsProgram); m_ship.destroy(); } Não há nada de novo em Window::onResize. É o mesmo código já utilizado em outros projetos. Em Window::onDestroy, m_objectsProgram é liberado e a função destroy de m_ship é chamada para liberar os recursos da nave. ship.h A definição da classe Ship ficará como a seguir: #ifndef SHIP_HPP_ #define SHIP_HPP_ #include &quot;abcgOpenGL.hpp&quot; #include &quot;gamedata.hpp&quot; class Ship { public: void create(GLuint program); void paint(GameData const &amp;gameData); void destroy(); void update(GameData const &amp;gameData, float deltaTime); glm::vec4 m_color{1}; float m_rotation{}; float m_scale{0.125f}; glm::vec2 m_translation{}; glm::vec2 m_velocity{}; abcg::Timer m_trailBlinkTimer; abcg::Timer m_bulletCoolDownTimer; private: GLuint m_program{}; GLint m_translationLoc{}; GLint m_colorLoc{}; GLint m_scaleLoc{}; GLint m_rotationLoc{}; GLuint m_VAO{}; GLuint m_VBO{}; GLuint m_EBO{}; }; #endif As propriedades da nave são definidas nas linhas 15 a 19: cor, ângulo de rotação, fator de escala, translação e vetor de velocidade. Os temporizadores definidos nas linhas 21 e 224 são utilizados para controlar o tempo de piscagem dos foguetes da nave em aceleração, e o tempo de espera entre um tiro e outro. As variáveis nas linhas 26 a 29 receberão o resultado de glGetUniformLocation para as variáveis uniformes do vertex shader. Isso será feito em Ship::create. ship.cpp Aqui definiremos Ship::create, Ship::paint, Ship::destroy e Ship::update. A definição de Ship::create no início do arquivo contém o código que cria o VBO e o VAO da nave: #include &quot;ship.hpp&quot; #include &lt;glm/gtx/fast_trigonometry.hpp&gt; #include &lt;glm/gtx/rotate_vector.hpp&gt; void Ship::create(GLuint program) { destroy(); m_program = program; // Get location of uniforms in the program m_colorLoc = abcg::glGetUniformLocation(m_program, &quot;color&quot;); m_rotationLoc = abcg::glGetUniformLocation(m_program, &quot;rotation&quot;); m_scaleLoc = abcg::glGetUniformLocation(m_program, &quot;scale&quot;); m_translationLoc = abcg::glGetUniformLocation(m_program, &quot;translation&quot;); // Reset ship attributes m_rotation = 0.0f; m_translation = glm::vec2(0); m_velocity = glm::vec2(0); // clang-format off std::array positions{ // Ship body glm::vec2{-02.5f, +12.5f}, glm::vec2{-15.5f, +02.5f}, glm::vec2{-15.5f, -12.5f}, glm::vec2{-09.5f, -07.5f}, glm::vec2{-03.5f, -12.5f}, glm::vec2{+03.5f, -12.5f}, glm::vec2{+09.5f, -07.5f}, glm::vec2{+15.5f, -12.5f}, glm::vec2{+15.5f, +02.5f}, glm::vec2{+02.5f, +12.5f}, // Cannon (left) glm::vec2{-12.5f, +10.5f}, glm::vec2{-12.5f, +04.0f}, glm::vec2{-09.5f, +04.0f}, glm::vec2{-09.5f, +10.5f}, // Cannon (right) glm::vec2{+09.5f, +10.5f}, glm::vec2{+09.5f, +04.0f}, glm::vec2{+12.5f, +04.0f}, glm::vec2{+12.5f, +10.5f}, // Thruster trail (left) glm::vec2{-12.0f, -07.5f}, glm::vec2{-09.5f, -18.0f}, glm::vec2{-07.0f, -07.5f}, // Thruster trail (right) glm::vec2{+07.0f, -07.5f}, glm::vec2{+09.5f, -18.0f}, glm::vec2{+12.0f, -07.5f}, }; // Normalize for (auto &amp;position : positions) { position /= glm::vec2{15.5f, 15.5f}; } std::array const indices{0, 1, 3, 1, 2, 3, 0, 3, 4, 0, 4, 5, 9, 0, 5, 9, 5, 6, 9, 6, 8, 8, 6, 7, // Cannons 10, 11, 12, 10, 12, 13, 14, 15, 16, 14, 16, 17, // Thruster trails 18, 19, 20, 21, 22, 23}; // clang-format on // Generate VBO abcg::glGenBuffers(1, &amp;m_VBO); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); abcg::glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Generate EBO abcg::glGenBuffers(1, &amp;m_EBO); abcg::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_EBO); abcg::glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // Get location of attributes in the program GLint positionAttribute{abcg::glGetAttribLocation(m_program, &quot;inPosition&quot;)}; // Create VAO abcg::glGenVertexArrays(1, &amp;m_VAO); // Bind vertex attributes to current VAO abcg::glBindVertexArray(m_VAO); abcg::glEnableVertexAttribArray(positionAttribute); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); abcg::glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); abcg::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_EBO); // End of binding to current VAO abcg::glBindVertexArray(0); } Observe que destroy é chamada logo no início da função para liberar o VBO e o VAO anterior, caso existam. Nas linhas 12 a 15, a localização das variáveis uniformes é salva para ser utilizada posteriormente na renderização. O arranjo positions (linhas 23 a 48) contém a posição dos vértices da nave. São 24 vértices (de 0 a 23), como mostra a figura 6.7. Esses vértices são ligados para formar 14 triângulos. A imagem foi dividida em duas para facilitar a visualização, pois há sobreposição de triângulos: Os vértices de 0 a 9 definem o corpo da nave; Os vértices de índices 10 a 17 definem os canhões de tiro; Os vértices de 18 a 23 definem dois triângulos que representam o fogo dos foguetes. Esses dois triângulos só serão desenhados quando a nave estiver acelerando. Figura 6.7: Geometria da nave. As coordenadas \\(x\\) em positions estão no intervalo \\([-15.5, 15.5]\\). Nas linhas 51 a 53, esse intervalo é mapeado para \\([-1,1]\\) de modo que a nave fique dentro da região visível do viewport. Após a normalização, a nave já poderá ser vista no viewport, mas ainda estará muito grande. Para chegar ao tamanho final, a escala é ajustada no shader usando m_scale, que é 0.125 (valor definido na linha 17 de ship.h). Observação Poderíamos ter definido positions diretamente com os valores normalizados. Não há um motivo especial para as coordenadas originais da nave variarem de -15.5 a 15.5. Só é assim porque esse foi o tamanho utilizado quando a nave foi modelada pela primeira vez em um software de edição de gráficos vetoriais. Na figura 6.7, todos os vértices ligados por linhas pontilhadas fazem parte de mais de um triângulo. Por exemplo, o vértice de índice 0 é compartilhado por quatro triângulos. Para evitar ter de criar quatro vértices na mesma posição, um para cada triângulo, vamos usar o conceito de geometria indexada. Nas linhas 55 a 70 é definido um arranjo de índices aos vértices. Cada grupo de três índices define um triângulo (compare com a figura 6.7). O VBO que contém os dados de positions é criado nas linhas 74 a 78. Nas linhas 81 a 85 é criado um element buffer object (EBO), que é o buffer de índices do VBO. O EBO armazena os dados de indices. Quando o comando de renderização é chamado com GL_TRIANGLES, cada sequência de três índices do EBO é utilizada para criar um triângulo. No restante do código de create, o VAO é criado para salvar a vinculação do VBO e o mapeamento do VBO para o atributo de entrada do vertex shader. Note que o VAO também salva a vinculação do EBO na linha 102. Quando o VAO for utilizado em paint, toda a configuração entre as linhas 94 a 105 será aplicada ao pipeline. O código de Ship::paint ficará como a seguir: void Ship::paint(const GameData &amp;gameData) { if (gameData.m_state != State::Playing) return; abcg::glUseProgram(m_program); abcg::glBindVertexArray(m_VAO); abcg::glUniform1f(m_scaleLoc, m_scale); abcg::glUniform1f(m_rotationLoc, m_rotation); abcg::glUniform2fv(m_translationLoc, 1, &amp;m_translation.x); // Restart thruster blink timer every 100 ms if (m_trailBlinkTimer.elapsed() &gt; 100.0 / 1000.0) m_trailBlinkTimer.restart(); if (gameData.m_input[static_cast&lt;size_t&gt;(Input::Up)]) { // Show thruster trail during 50 ms if (m_trailBlinkTimer.elapsed() &lt; 50.0 / 1000.0) { abcg::glEnable(GL_BLEND); abcg::glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // 50% transparent abcg::glUniform4f(m_colorLoc, 1, 1, 1, 0.5f); abcg::glDrawElements(GL_TRIANGLES, 14 * 3, GL_UNSIGNED_INT, nullptr); abcg::glDisable(GL_BLEND); } } abcg::glUniform4fv(m_colorLoc, 1, &amp;m_color.r); abcg::glDrawElements(GL_TRIANGLES, 12 * 3, GL_UNSIGNED_INT, nullptr); abcg::glBindVertexArray(0); abcg::glUseProgram(0); } Note que paint retorna imediatamente caso o jogo não esteja no estado State::Playing. A escala, ângulo de rotação e translação da nave são enviadas às variáveis uniformes nas linhas 115 a 117. Na linha 120, o temporizador m_trailBlinkTimer é reiniciado a cada 100 milissegundos. Ele é utilizado quando a nave está acelerando, de modo a mostrar o rastro de fogo do foguete durante 50 milissegundos, intercalado com uma pausa também de 50 milissegundos. Para desenhar o rastro de fogo, todos os 14 triângulos da geometria da nave são exibidos usando transparência de 50% (linhas 125 a 133). Isso é necessário pois não é possível desenhar só os dois triângulos finais. Para isso precisaríamos ter de criar um outro VBO, o que daria mais trabalho. Na linha 138 é renderizado o corpo da nave sem o rastro do foguete, isto é, só são renderizados os primeiros 12 triângulos. Nessa renderização, a nave é renderizada com cor opaca, sobrepondo a renderização anterior da nave 50% transparente. Note que a função de renderização é glDrawElements. Essa função deve ser utilizada no lugar de glDrawArrays sempre que quisermos desenhar geometria indexada. A função Ship::destroy contém apenas a liberação do VBO, EBO e VAO: void Ship::destroy() { abcg::glDeleteBuffers(1, &amp;m_VBO); abcg::glDeleteBuffers(1, &amp;m_EBO); abcg::glDeleteVertexArrays(1, &amp;m_VAO); } Na função Ship::update é onde são atualizados os atributos de orientação e velocidade da nave de acordo com o estado de GameData::m_input: void Ship::update(GameData const &amp;gameData, float deltaTime) { // Rotate if (gameData.m_input[gsl::narrow&lt;size_t&gt;(Input::Left)]) m_rotation = glm::wrapAngle(m_rotation + 4.0f * deltaTime); if (gameData.m_input[gsl::narrow&lt;size_t&gt;(Input::Right)]) m_rotation = glm::wrapAngle(m_rotation - 4.0f * deltaTime); // Apply thrust if (gameData.m_input[gsl::narrow&lt;size_t&gt;(Input::Up)] &amp;&amp; gameData.m_state == State::Playing) { // Thrust in the forward vector auto const forward{glm::rotate(glm::vec2{0.0f, 1.0f}, m_rotation)}; m_velocity += forward * deltaTime; } } A rotação (linhas 153 a 156) é feita a uma taxa de 4 radianos por segundo (note o uso do deltaTime). A função glm::wrapAngle é utilizada para fazer com que o valor sempre fique no intervalo circular \\([0,2\\pi]\\). O #include &lt;glm/gtx/fast_trigonometry.hpp&gt; na linha 3 de ship.cpp serve para incluir essa função da biblioteca GLM. A aceleração é atualizada no if da linha 159. Na linha 162 é calculado um vetor que indica a direção para onde a nave está apontando (vetor forward). Isso é obtido aplicando uma rotação no vetor \\((0, 1)\\)6 usando o ângulo atual da nave. Uma vez calculado o vetor forward, ele é adicionado ao vetor de velocidade m_velocity na linha 163. Observe novamente o uso do deltaTime. Como forward é um vetor unitário, a velocidade será incrementada em uma unidade por segundo. Observe que o #include na linha 4 de ship.cpp (#include &lt;glm/gtx/rotate_vector.hpp&gt;) inclui a função glm::rotate da biblioteca GLM. Visualmente, a nave ficará presa no centro do viewport, mas os outros objetos da cena (asteroides, estrelas e tiros) usarão m_velocity (na verdade, -m_velocity) para serem deslocados. Se o código for construído neste momento, o resultado será como mostrado a seguir (use o link original caso queria controlar a nave pelo teclado): O código do projeto pode ser baixado deste link. Estrelas As estrelas serão desenhadas como pontos (GL_POINTS) e usarão os shaders stars.vert e stars.frag definidos a seguir. stars.vert #version 300 es layout(location = 0) in vec2 inPosition; layout(location = 1) in vec3 inColor; uniform vec2 translation; uniform float pointSize; out vec4 fragColor; void main() { gl_PointSize = pointSize; gl_Position = vec4(inPosition.xy + translation, 0, 1); fragColor = vec4(inColor, 1); } Os atributos de entrada são uma posição \\((x,y)\\) (inPosition) e uma cor RGB (inColor). Em main, a cor de entrada é copiada para o atributo de saída (fragColor) como uma cor RGBA onde A é 1. A posição do ponto é deslocada por translation, e o tamanho do ponto é definido por pointSize. stars.frag #version 300 es precision mediump float; in vec4 fragColor; out vec4 outColor; void main() { float intensity = 1.0 - length(gl_PointCoord - vec2(0.5)) * 2.0; outColor = fragColor * intensity; } O processamento principal deste shader ocorre na definição da variável intensity. Para compreendermos o que está acontecendo, lembre-se primeiro que o tamanho de um ponto (gl_PointSize) é dado em pixels. O ponto é na verdade um quadrado centralizado na posição de cada ponto. O fragment shader explora esse fato para exibir um gradiente radial no quadrado de modo a simular o formato circular de uma estrela. A variável embutida gl_PointCoord contém as coordenadas do fragmento dentro do quadrado. Na configuração padrão, \\((0,0)\\) é o canto superior esquerdo, e \\((1,1)\\) é o canto inferior direito (figura 6.8). Figura 6.8: Quadrado gerado em torno de um ponto de GL_POINTS, e coordenadas de gl_PointCoord dentro do quadrado formado. A expressão length(gl_PointCoord - vec2(0.5)) calcula a distância euclidiana até o centro do quadrado. Na direção em \\(x\\) e \\(y\\), essa distância está no intervalo \\([0,0.5]\\). A distância é convertida em uma intensidade de luz armazenada em intensity, sendo que a intensidade é máxima (1) no centro do quadrado. A cor de saída é multiplicada por essa intensidade. Se o quadrado for branco, o resultado será como o mostrado na figura 6.9). Figura 6.9: Gradiente radial produzido por stars.frag no quadrado de um ponto definido com GL_POINTS. Atualizando window.hpp Para a implementação das estrelas, precisamos definir em Window o identificador dos shaders m_starsProgram e a instância de StarLayers. O código atualizado ficará como a seguir: #ifndef WINDOW_HPP_ #define WINDOW_HPP_ #include &lt;random&gt; #include &quot;abcgOpenGL.hpp&quot; #include &quot;asteroids.hpp&quot; #include &quot;bullets.hpp&quot; #include &quot;ship.hpp&quot; #include &quot;starlayers.hpp&quot; class Window : public abcg::OpenGLWindow { protected: void onEvent(SDL_Event const &amp;event) override; void onCreate() override; void onUpdate() override; void onPaint() override; void onPaintUI() override; void onResize(glm::ivec2 const &amp;size) override; void onDestroy() override; private: glm::ivec2 m_viewportSize{}; GLuint m_starsProgram{}; GLuint m_objectsProgram{}; GameData m_gameData; Ship m_ship; StarLayers m_starLayers; abcg::Timer m_restartWaitTimer; ImFont *m_font{}; std::default_random_engine m_randomEngine; void restart(); }; #endif Atualizando window.cpp Precisamos atualizar também as funções membro de Window: Em Window::onCreate, inclua o seguinte código para compilar os novos shaders: // Create program to render the stars m_starsProgram = abcg::createOpenGLProgram({{.source = assetsPath + &quot;stars.vert&quot;, .stage = abcg::ShaderStage::Vertex}, {.source = assetsPath + &quot;stars.frag&quot;, .stage = abcg::ShaderStage::Fragment}}); Em Window::restart, inclua a chamada a StarLayers::create junto com a chamada a Ship::create feita anteriormente: m_starLayers.create(m_starsProgram, 25); m_ship.create(m_objectsProgram); Em Window::onUpdate, chame a função StarLayers::update depois de Ship::update, assim: m_ship.update(m_gameData, deltaTime); m_starLayers.update(m_ship, deltaTime); Em Window::onPaint, chame StarLayers::paint antes de Ship::paint, assim: m_starLayers.paint(); m_ship.paint(m_gameData); Por fim, modifique Window::onDestroy da seguinte forma: void Window::onDestroy() { abcg::glDeleteProgram(m_starsProgram); abcg::glDeleteProgram(m_objectsProgram); m_ship.destroy(); m_starLayers.destroy(); } starlayers.hpp A definição da classe StarLayers ficará assim: #ifndef STARLAYERS_HPP_ #define STARLAYERS_HPP_ #include &lt;array&gt; #include &lt;random&gt; #include &quot;abcgOpenGL.hpp&quot; #include &quot;gamedata.hpp&quot; #include &quot;ship.hpp&quot; class StarLayers { public: void create(GLuint program, int quantity); void paint(); void destroy(); void update(const Ship &amp;ship, float deltaTime); private: GLuint m_program{}; GLint m_pointSizeLoc{}; GLint m_translationLoc{}; struct StarLayer { GLuint m_VAO{}; GLuint m_VBO{}; float m_pointSize{}; int m_quantity{}; glm::vec2 m_translation{}; }; std::array&lt;StarLayer, 5&gt; m_starLayers; std::default_random_engine m_randomEngine; }; #endif Nas linhas 24 a 31 é definida a estrutura StarLayer. Ela contém o VBO e VAO dos pontos que formam uma “camada” de estrelas. Além disso contém o tamanho (m_pointSize) e quantidade (m_quantity) dos pontos, e um fator de translação (m_translation) utilizado para deslocar todos os pontos da camada (isto é, todos os vértices do VBO). Na linha 33 é definido um arranjo de cinco objetos StarLayer, pois renderizaremos cinco camadas sobrepostas de estrelas. starlayers.cpp O arquivo começa com a definição de StarLayers::create: #include &quot;starlayers.hpp&quot; void StarLayers::create(GLuint program, int quantity) { destroy(); // Initialize pseudorandom number generator and distributions m_randomEngine.seed( std::chrono::steady_clock::now().time_since_epoch().count()); std::uniform_real_distribution distPos(-1.0f, 1.0f); std::uniform_real_distribution distIntensity(0.5f, 1.0f); auto &amp;re{m_randomEngine}; // Shortcut m_program = program; // Get location of uniforms in the program m_pointSizeLoc = abcg::glGetUniformLocation(m_program, &quot;pointSize&quot;); m_translationLoc = abcg::glGetUniformLocation(m_program, &quot;translation&quot;); // Get location of attributes in the program auto const positionAttribute{ abcg::glGetAttribLocation(m_program, &quot;inPosition&quot;)}; auto const colorAttribute{abcg::glGetAttribLocation(m_program, &quot;inColor&quot;)}; for (auto &amp;&amp;[index, layer] : iter::enumerate(m_starLayers)) { // Create data for the stars of this layer layer.m_pointSize = 10.0f / (1.0f + index); layer.m_quantity = quantity * (gsl::narrow&lt;int&gt;(index) + 1); layer.m_translation = {}; std::vector&lt;glm::vec3&gt; data; for ([[maybe_unused]] auto _ : iter::range(0, layer.m_quantity)) { data.emplace_back(distPos(re), distPos(re), 0); data.push_back(glm::vec3(distIntensity(re))); } // Generate VBO abcg::glGenBuffers(1, &amp;layer.m_VBO); abcg::glBindBuffer(GL_ARRAY_BUFFER, layer.m_VBO); abcg::glBufferData(GL_ARRAY_BUFFER, data.size() * sizeof(glm::vec3), data.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Create VAO abcg::glGenVertexArrays(1, &amp;layer.m_VAO); // Bind vertex attributes to current VAO abcg::glBindVertexArray(layer.m_VAO); abcg::glBindBuffer(GL_ARRAY_BUFFER, layer.m_VBO); abcg::glEnableVertexAttribArray(positionAttribute); abcg::glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, sizeof(glm::vec3) * 2, nullptr); abcg::glEnableVertexAttribArray(colorAttribute); abcg::glVertexAttribPointer(colorAttribute, 3, GL_FLOAT, GL_FALSE, sizeof(glm::vec3) * 2, reinterpret_cast&lt;void *&gt;(sizeof(glm::vec3))); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // End of binding to current VAO abcg::glBindVertexArray(0); } } O laço da linha 24 itera sobre cada elemento de m_starLayers. A expressão na linha 26 faz com que os pontos tenham tamanho 10 na 1ª camada, 5 na 2ª camada, 2.5 na 3ª camada, e assim sucessivamente. Na linha 27, a quantidade de pontos é dobrada a cada camada. Na linha 30 é criado um arranjo data com dados dos pontos da camada. Os dados ficarão intercalados no formato \\[[\\underline{x,y,0,r,g,b},x,y,0,r,g,b,\\dots],\\] onde \\((x,y,0)\\) é a posição do ponto, e \\((r,g,b)\\) é a cor do ponto. Dentro do laço, as coordenadas \\(x\\) e \\(y\\) são escolhidas de forma aleatória dentro do intervalo \\([-1,1)\\). A cor é um tom de cinza escolhido aleatoriamente do intervalo \\([0.5,1)\\). Os dados de data são copiados para o VBO através de glBufferData na linha 39. Observe nas linhas 49 a 57 como é feito o mapeamento do VBO com os atributos inPosition (do tipo vec2) e inColor (do tipo vec4) do vertex shader. O stride do VBO é sizeof(glm::vec3) * 2 (isto é, dois vec3). Na linha 56, o deslocamento no início do VBO é sizeof(glm::vec3) (isto é, apenas um vec3). A conversão de tipo é necessária porque o parâmetro de deslocamento é do tipo void const * ao invés de um inteiro (é assim por razões históricas). A definição de StarLayers::paint ficará como a seguir: void StarLayers::paint() { abcg::glUseProgram(m_program); abcg::glEnable(GL_BLEND); abcg::glBlendFunc(GL_ONE, GL_ONE); for (auto const &amp;layer : m_starLayers) { abcg::glBindVertexArray(layer.m_VAO); abcg::glUniform1f(m_pointSizeLoc, layer.m_pointSize); for (auto const i : {-2, 0, 2}) { for (auto const j : {-2, 0, 2}) { abcg::glUniform2f(m_translationLoc, layer.m_translation.x + j, layer.m_translation.y + i); abcg::glDrawArrays(GL_POINTS, 0, layer.m_quantity); } } abcg::glBindVertexArray(0); } abcg::glDisable(GL_BLEND); abcg::glUseProgram(0); } Observe que os pontos são desenhados com o modo de mistura de cor habilitado. Na linha 68, a definição da função de mistura com fatores GL_ONE faz com que as cores produzidas pelo fragment shader sejam somadas com as cores atuais do framebuffer. Isso produz um efeito cumulativo de intensidade da luz quando estrelas de camadas diferentes são renderizadas na mesma posição. Os laços aninhados nas linhas 74 e 75 produzem índices i e j que são usados em layer.m_translation para replicar o desenho das estrelas em uma grade 3x3 em torno da região visível do NDC, como vimos no início da seção. Na linha 86, o modo de mistura de cor é desabilitado para não afetar a renderização dos outros objetos de cena que são totalmente opacos. Em StarLayers::destroy são liberados os VBOs e VAOs de todas as instâncias de StarLayer: void StarLayers::destroy() { for (auto &amp;layer : m_starLayers) { abcg::glDeleteBuffers(1, &amp;layer.m_VBO); abcg::glDeleteVertexArrays(1, &amp;layer.m_VAO); } } Vamos agora à definição de StarLayers::update: void StarLayers::update(const Ship &amp;ship, float deltaTime) { for (auto &amp;&amp;[index, layer] : iter::enumerate(m_starLayers)) { auto const layerSpeedScale{1.0f / (index + 2.0f)}; layer.m_translation -= ship.m_velocity * deltaTime * layerSpeedScale; // Wrap-around if (layer.m_translation.x &lt; -1.0f) layer.m_translation.x += 2.0f; if (layer.m_translation.x &gt; +1.0f) layer.m_translation.x -= 2.0f; if (layer.m_translation.y &lt; -1.0f) layer.m_translation.y += 2.0f; if (layer.m_translation.y &gt; +1.0f) layer.m_translation.y -= 2.0f; } } A translação (m_translation) de cada camada é atualizada na linha 101 de acordo com a velocidade da nave. Se a nave está indo para a frente, então a camada de estrelas deve ir para trás: por isso a subtração. A velocidade é multiplicada por um fator de escala layerSpeedScale para fazer com que a primeira camada seja mais rápida que a segunda, e assim sucessivamente para produzir o efeito de paralaxe. Nas linhas 104 a 111 há uma série de condicionais que testam se os pontos saíram dos limites da região visível do NDC. Se saíram, são deslocados para o lado oposto. Nesse momento, o jogo ficará como a seguir (link original): O código pode ser baixado deste link. Asteroides Para incluir a implementação dos asteroides, vamos primeiramente atualizar OpenGLWindow. Atualizando window.hpp Adicione a definição de m_asteroids junto às definições dos outros objetos (m_ship e m_starLayers), assim: Asteroids m_asteroids; Ship m_ship; StarLayers m_starLayers; Atualizando window.cpp Em Window::restart, chame create de m_asteroids junto com a chamada a create dos objetos anteriores: m_starLayers.create(m_starsProgram, 25); m_ship.create(m_objectsProgram); m_asteroids.create(m_objectsProgram, 3); Em Window::onUpdate, chame update de m_asteroids após update de m_ship: m_ship.update(m_gameData, deltaTime); m_starLayers.update(m_ship, deltaTime); m_asteroids.update(m_ship, deltaTime); Em Window::onPaint, chame paint de m_asteroids logo após paint de m_starLayers: m_starLayers.paint(); m_asteroids.paint(); m_ship.paint(m_gameData); Em Window::onDestroy, chame destroy de m_asteroids junto com a chamada a destroy dos outros objetos: m_asteroids.destroy(); m_ship.destroy(); m_starLayers.destroy(); Observação A ordem em que a função paint de cada objeto é chamada é importante porque o objeto renderizado por último será desenhado sobre os anteriores que já estão no framebuffer. Essa forma de renderizar os objetos na ordem do mais distante para o mais próximo é chamada de “algoritmo do pintor” pois é similar ao modo como um pintor desenha sobre uma tela: os elementos mais ao fundo são desenhados antes dos elementos mais à frente. asteroids.hpp A definição da classe Asteroids ficará assim: #ifndef ASTEROIDS_HPP_ #define ASTEROIDS_HPP_ #include &lt;list&gt; #include &lt;random&gt; #include &quot;abcgOpenGL.hpp&quot; #include &quot;gamedata.hpp&quot; #include &quot;ship.hpp&quot; class Asteroids { public: void create(GLuint program, int quantity); void paint(); void destroy(); void update(const Ship &amp;ship, float deltaTime); struct Asteroid { GLuint m_VAO{}; GLuint m_VBO{}; float m_angularVelocity{}; glm::vec4 m_color{1}; bool m_hit{}; int m_polygonSides{}; float m_rotation{}; float m_scale{}; glm::vec2 m_translation{}; glm::vec2 m_velocity{}; }; std::list&lt;Asteroid&gt; m_asteroids; Asteroid makeAsteroid(glm::vec2 translation = {}, float scale = 0.25f); private: GLuint m_program{}; GLint m_colorLoc{}; GLint m_rotationLoc{}; GLint m_translationLoc{}; GLint m_scaleLoc{}; std::default_random_engine m_randomEngine; std::uniform_real_distribution&lt;float&gt; m_randomDist{-1.0f, 1.0f}; }; #endif Entre as linhas 19 a 31 é definida a estrutura Asteroid. Cada asteroide tem seu próprio VAO e VBO. Além disso, Asteroid possui uma velocidade angular, uma cor, número de lados, ângulo de rotação, escala, translação, vetor de velocidade, e um flag m_hit que indica se o asteroide foi acertado por um tiro. Na linha 33 é definida uma lista de objetos Asteroid. O número de elementos dessa lista será modificado de acordo com os asteroides que forem acertados pelos tiros. Cada vez que um asteroide for acertado, ele será retirado da lista. Entretanto, se o asteroide for grande, simularemos que ele foi quebrado em vários pedaços fazendo com asteroides menores sejam inseridos na lista. A função makeAsteroid declarada na linha 35 será utilizada para criar um novo asteroide para ser inserido na lista m_asteroids. Os parâmetros translation e scale permitirão configurar a posição e o fator de escala do novo asteroide. asteroids.cpp O arquivo começa com a definição de Asteroids::create: #include &quot;asteroids.hpp&quot; #include &lt;glm/gtx/fast_trigonometry.hpp&gt; void Asteroids::create(GLuint program, int quantity) { destroy(); m_randomEngine.seed( std::chrono::steady_clock::now().time_since_epoch().count()); m_program = program; // Get location of uniforms in the program m_colorLoc = abcg::glGetUniformLocation(m_program, &quot;color&quot;); m_rotationLoc = abcg::glGetUniformLocation(m_program, &quot;rotation&quot;); m_scaleLoc = abcg::glGetUniformLocation(m_program, &quot;scale&quot;); m_translationLoc = abcg::glGetUniformLocation(m_program, &quot;translation&quot;); // Create asteroids m_asteroids.clear(); m_asteroids.resize(quantity); for (auto &amp;asteroid : m_asteroids) { asteroid = makeAsteroid(); // Make sure the asteroid won&#39;t collide with the ship do { asteroid.m_translation = {m_randomDist(m_randomEngine), m_randomDist(m_randomEngine)}; } while (glm::length(asteroid.m_translation) &lt; 0.5f); } } Na linha 21, a lista de asteroides é iniciada com uma quantidade quantity de objetos do tipo Asteroid. Essa lista é então iterada no laço da linha 23 e o conteúdo de cada asteroide é substituído por Asteroids::makeAsteroid. No laço das linhas 27 a 30 é escolhida uma posição aleatória para o asteroide, mas uma posição longe o suficiente da nave: não queremos que o jogo comece com o asteroide colidindo com a nave! A definição de Asteroids::paint ficará como a seguir: void Asteroids::paint() { abcg::glUseProgram(m_program); for (auto const &amp;asteroid : m_asteroids) { abcg::glBindVertexArray(asteroid.m_VAO); abcg::glUniform4fv(m_colorLoc, 1, &amp;asteroid.m_color.r); abcg::glUniform1f(m_scaleLoc, asteroid.m_scale); abcg::glUniform1f(m_rotationLoc, asteroid.m_rotation); for (auto i : {-2, 0, 2}) { for (auto j : {-2, 0, 2}) { abcg::glUniform2f(m_translationLoc, asteroid.m_translation.x + j, asteroid.m_translation.y + i); abcg::glDrawArrays(GL_TRIANGLE_FAN, 0, asteroid.m_polygonSides + 2); } } abcg::glBindVertexArray(0); } abcg::glUseProgram(0); } A lista m_asteroids é iterada e cada asteroide é renderizado 9 vezes (em uma grade 3x3), como fizemos com as estrelas. Em Asteroids::destroy são liberados os VBOs e VAOs dos asteroides: void Asteroids::destroy() { for (auto &amp;asteroid : m_asteroids) { abcg::glDeleteBuffers(1, &amp;asteroid.m_VBO); abcg::glDeleteVertexArrays(1, &amp;asteroid.m_VAO); } } Vamos agora à definição de Asteroids::update: void Asteroids::update(const Ship &amp;ship, float deltaTime) { for (auto &amp;asteroid : m_asteroids) { asteroid.m_translation -= ship.m_velocity * deltaTime; asteroid.m_rotation = glm::wrapAngle( asteroid.m_rotation + asteroid.m_angularVelocity * deltaTime); asteroid.m_translation += asteroid.m_velocity * deltaTime; // Wrap-around if (asteroid.m_translation.x &lt; -1.0f) asteroid.m_translation.x += 2.0f; if (asteroid.m_translation.x &gt; +1.0f) asteroid.m_translation.x -= 2.0f; if (asteroid.m_translation.y &lt; -1.0f) asteroid.m_translation.y += 2.0f; if (asteroid.m_translation.y &gt; +1.0f) asteroid.m_translation.y -= 2.0f; } } Na linha 68, a translação (m_translation) de cada asteroide é modificada pelo vetor de velocidade da nave, como fizemos com as estrelas. Na linha 69, a rotação é atualizada de acordo com a velocidade angular. Na linha 71, a translação do asteroide é modificada novamente, mas agora considerando a velocidade do próprio asteroide. As condicionais das linhas 74 a 80 fazem com que as coordenadas de m_translation permaneçam no intervalo circular de -1 a 1. A definição de Asteroids::makeAsteroid ficará como a seguir: Asteroids::Asteroid Asteroids::makeAsteroid(glm::vec2 translation, float scale) { Asteroid asteroid; auto &amp;re{m_randomEngine}; // Shortcut // Randomly pick the number of sides std::uniform_int_distribution randomSides(6, 20); asteroid.m_polygonSides = randomSides(re); // Get a random color (actually, a grayscale) std::uniform_real_distribution randomIntensity(0.5f, 1.0f); asteroid.m_color = glm::vec4(randomIntensity(re)); asteroid.m_color.a = 1.0f; asteroid.m_rotation = 0.0f; asteroid.m_scale = scale; asteroid.m_translation = translation; // Get a random angular velocity asteroid.m_angularVelocity = m_randomDist(re); // Get a random direction glm::vec2 const direction{m_randomDist(re), m_randomDist(re)}; asteroid.m_velocity = glm::normalize(direction) / 7.0f; // Create geometry data std::vector&lt;glm::vec2&gt; positions{{0, 0}}; auto const step{M_PI * 2 / asteroid.m_polygonSides}; std::uniform_real_distribution randomRadius(0.8f, 1.0f); for (auto const angle : iter::range(0.0, M_PI * 2, step)) { auto const radius{randomRadius(re)}; positions.emplace_back(radius * std::cos(angle), radius * std::sin(angle)); } positions.push_back(positions.at(1)); // Generate VBO abcg::glGenBuffers(1, &amp;asteroid.m_VBO); abcg::glBindBuffer(GL_ARRAY_BUFFER, asteroid.m_VBO); abcg::glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(glm::vec2), positions.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Get location of attributes in the program auto const positionAttribute{ abcg::glGetAttribLocation(m_program, &quot;inPosition&quot;)}; // Create VAO abcg::glGenVertexArrays(1, &amp;asteroid.m_VAO); // Bind vertex attributes to current VAO abcg::glBindVertexArray(asteroid.m_VAO); abcg::glBindBuffer(GL_ARRAY_BUFFER, asteroid.m_VBO); abcg::glEnableVertexAttribArray(positionAttribute); abcg::glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // End of binding to current VAO abcg::glBindVertexArray(0); return asteroid; } Na linha 105 é escolhida uma velocidade angular aleatória no intervalo \\([-1, 1)\\). Essa velocidade será interpretada como sendo em radianos por segundo. Na linha 109 é escolhido um vetor unitário aleatório para definir a velocidade do asteroide. As componentes do vetor são divididas por 7 de modo que cada asteroide inicie com uma velocidade de 1/7 unidades de espaço por segundo. O restante do código cria a geometria do asteroide. O código é bem parecido com o que foi utilizado para criar o polígono regular no projeto regularpolygons. A diferença é que agora usamos a equação paramétrica do círculo com raio \\(r\\) \\[ \\begin{eqnarray} x&amp;=&amp;r cos(t),\\\\ y&amp;=&amp;r sin(t), \\end{eqnarray} \\] e selecionamos um \\(r\\) aleatório do intervalo \\([0.8, 1)\\) para cada vértice do polígono. Nesse momento, o jogo ficará como a seguir (link original): O código pode ser baixado deste link. Tiros e colisões Até agora o jogo ainda não tem detecção de colisão com os asteroides. Faremos isso a seguir. Atualizando window.hpp Adicione a definição de m_bullets junto à definição dos outros objetos: Asteroids m_asteroids; Bullets m_bullets; Ship m_ship; StarLayers m_starLayers; Adicione também a declaração das seguintes funções adicionais de Window: void checkCollisions(); void checkWinCondition(); checkCollisions será utilizada para verificar as colisões; checkWinCondition será utilizada para verificar se o jogador ganhou (isto é, se não há mais asteroides). Atualizando window.cpp Em Window::restart, inclua a chamada à função create de m_bullets junto com create dos objetos anteriores, assim: m_starLayers.create(m_starsProgram, 25); m_ship.create(m_objectsProgram); m_asteroids.create(m_objectsProgram, 3); m_bullets.create(m_objectsProgram); Em Window::onUpdate, chame update de m_bullets em qualquer lugar após a chamada de update de m_ship. Por exemplo: m_ship.update(m_gameData, deltaTime); m_starLayers.update(m_ship, deltaTime); m_asteroids.update(m_ship, deltaTime); m_bullets.update(m_ship, m_gameData, deltaTime); Após esses updates, inclua a seguinte condicional que chama as funções de detecção de colisão e verificação da condição de vitória se o jogo está no estado State::Playing: if (m_gameData.m_state == State::Playing) { checkCollisions(); checkWinCondition(); } Em Window::onPaint, chame paint de m_bullets logo após a chamada de paint de m_asteroids: m_starLayers.paint(); m_asteroids.paint(); m_bullets.paint(); m_ship.paint(m_gameData); Em Window::onDestroy, chame destroy de m_bullets junto com destroy dos outros objetos: m_asteroids.destroy(); m_bullets.destroy(); m_ship.destroy(); m_starLayers.destroy(); Vamos agora definir Window::checkCollisions como a seguir: void Window::checkCollisions() { // Check collision between ship and asteroids for (auto const &amp;asteroid : m_asteroids.m_asteroids) { auto const asteroidTranslation{asteroid.m_translation}; auto const distance{ glm::distance(m_ship.m_translation, asteroidTranslation)}; if (distance &lt; m_ship.m_scale * 0.9f + asteroid.m_scale * 0.85f) { m_gameData.m_state = State::GameOver; m_restartWaitTimer.restart(); } } // Check collision between bullets and asteroids for (auto &amp;bullet : m_bullets.m_bullets) { if (bullet.m_dead) continue; for (auto &amp;asteroid : m_asteroids.m_asteroids) { for (auto const i : {-2, 0, 2}) { for (auto const j : {-2, 0, 2}) { auto const asteroidTranslation{asteroid.m_translation + glm::vec2(i, j)}; auto const distance{ glm::distance(bullet.m_translation, asteroidTranslation)}; if (distance &lt; m_bullets.m_scale + asteroid.m_scale * 0.85f) { asteroid.m_hit = true; bullet.m_dead = true; } } } } // Break asteroids marked as hit for (auto const &amp;asteroid : m_asteroids.m_asteroids) { if (asteroid.m_hit &amp;&amp; asteroid.m_scale &gt; 0.10f) { std::uniform_real_distribution randomDist{-1.0f, 1.0f}; std::generate_n(std::back_inserter(m_asteroids.m_asteroids), 3, [&amp;]() { glm::vec2 const offset{randomDist(m_randomEngine), randomDist(m_randomEngine)}; auto const newScale{asteroid.m_scale * 0.5f}; return m_asteroids.makeAsteroid( asteroid.m_translation + offset * newScale, newScale); }); } } m_asteroids.m_asteroids.remove_if([](auto const &amp;a) { return a.m_hit; }); } } Nas linhas 174 a 184 é feita a detecção de colisão entre a nave e cada asteroide: // Check collision between ship and asteroids for (auto const &amp;asteroid : m_asteroids.m_asteroids) { auto const asteroidTranslation{asteroid.m_translation}; auto const distance{ glm::distance(m_ship.m_translation, asteroidTranslation)}; if (distance &lt; m_ship.m_scale * 0.9f + asteroid.m_scale * 0.85f) { m_gameData.m_state = State::GameOver; m_restartWaitTimer.restart(); } } A detecção de colisão é feita através da comparação da distância euclidiana (glm::distance) entre as coordenadas de translação dos objetos. Essas coordenadas podem ser consideradas como a posição do centro dos objetos na cena (como ilustrado pelos pontos \\(P_s\\) e \\(P_a\\) na figura 6.10: Figura 6.10: Detecção de colisão entre nave e asteroide através da comparação de distância entre círculos. \\(P_s\\) e \\(P_a\\) também podem ser considerados como centros de círculos. O fator de escala de cada objeto corresponde ao raio do círculo (\\(r_s\\) e \\(r_a\\)). Assim, podemos detectar a colisão através de uma simples comparação da distância \\(|P_s-P_a|\\) com a soma dos fatores de escala. Só há colisão se a distância for menor ou igual a \\(r_s+r_a\\). Esse tipo de teste é bem mais simples e eficiente (embora menos preciso) do que comparar a interseção entre os triângulos que formam os objetos. Note, na linha 180, que \\(r_s\\) e \\(r_a\\) são de fato os fatores m_scale de cada objeto, mas multiplicados por 0.9f (para a nave) e 0.85f (para o asteroide). Isso é feito para diminuir um pouco o raio dos círculos e fazer com que exista uma tolerância de sobreposição antes de ocorrer a colisão. Veja, na figura 6.10, que dessa forma os objetos não ficam inscritos nos círculos. Os valores 0.9 e 0.85 foram determinados empiricamente. O laço for da linha 187 itera sobre os tiros. Dentro desse laço há outro (linha 191) que itera sobre os asteroides para verificar se há colisão entre cada tiro e os asteroides: // Check collision between bullets and asteroids for (auto &amp;bullet : m_bullets.m_bullets) { if (bullet.m_dead) continue; for (auto &amp;asteroid : m_asteroids.m_asteroids) { for (auto const i : {-2, 0, 2}) { for (auto const j : {-2, 0, 2}) { auto const asteroidTranslation{asteroid.m_translation + glm::vec2(i, j)}; auto const distance{ glm::distance(bullet.m_translation, asteroidTranslation)}; if (distance &lt; m_bullets.m_scale + asteroid.m_scale * 0.85f) { asteroid.m_hit = true; bullet.m_dead = true; } } } } A verificação da interseção é calculada novamente através da comparação da distância entre círculos. Note que os testes de distância são feitos dentro de laços aninhados parecidos com os que foram utilizados para replicar a renderização dos asteroides na grade 3x3 em torno da região visível do viewport. De fato, o teste de colisão de um tiro com um asteroide precisa considerar essa replicação, pois um asteroide que está saindo à esquerda do viewport pode ser atingido por um tiro no lado oposto, à direita. Se um tiro acertou um asteroide, o m_hit do asteroide e o m_dead do tiro tornam-se true. Observe agora as linhas 207 a 219: // Break asteroids marked as hit for (auto const &amp;asteroid : m_asteroids.m_asteroids) { if (asteroid.m_hit &amp;&amp; asteroid.m_scale &gt; 0.10f) { std::uniform_real_distribution randomDist{-1.0f, 1.0f}; std::generate_n(std::back_inserter(m_asteroids.m_asteroids), 3, [&amp;]() { glm::vec2 const offset{randomDist(m_randomEngine), randomDist(m_randomEngine)}; auto const newScale{asteroid.m_scale * 0.5f}; return m_asteroids.makeAsteroid( asteroid.m_translation + offset * newScale, newScale); }); } } Neste código, os asteroides com m_hit == true são testados para verificar se são suficientemente grandes (m_scale &gt; 0.10f). Se sim, três novos asteroides menores são criados e inseridos na lista m_asteroids.m_asteroids. std::generate é uma função da biblioteca padrão do C++. Ela chama um número de vezes (nesse caso 3 vezes) a expressão lambda passada como último argumento. O valor de retorno da expressão lambda é inserido no fim de m_asteroids.m_asteroids usando a função auxiliar std::back_inserter. Na linha 221, os asteroides que estavam com m_hit == true são removidos da lista usando std::remove_if: m_asteroids.m_asteroids.remove_if( [](const Asteroids::Asteroid &amp;a) { return a.m_hit; }); Isso é tudo para a detecção de colisão. Vamos agora à definição de Window::checkWinCondition, que ficará como a seguir: void Window::checkWinCondition() { if (m_asteroids.m_asteroids.empty()) { m_gameData.m_state = State::Win; m_restartWaitTimer.restart(); } } A vitória ocorre quando a lista de asteroides está vazia. Nesse caso, o estado do jogo é modificado para State::Win e o temporizador m_restartWaitTimer é reiniciado. Como resultado, o jogo será reiniciado após cinco segundos (essa verificação é feita em Window::onUpdate). Enquanto isso, o texto de vitória será exibido em Window::onPaintUI. bullets.hpp A definição da classe Bullets ficará como a seguir: #ifndef BULLETS_HPP_ #define BULLETS_HPP_ #include &lt;list&gt; #include &quot;abcgOpenGL.hpp&quot; #include &quot;gamedata.hpp&quot; #include &quot;ship.hpp&quot; class OpenGLWindow; class Bullets { public: void create(GLuint program); void paint(); void destroy(); void update(Ship &amp;ship, const GameData &amp;gameData, float deltaTime); struct Bullet { bool m_dead{}; glm::vec2 m_translation{}; glm::vec2 m_velocity{}; }; std::list&lt;Bullet&gt; m_bullets; float m_scale{0.015f}; private: GLuint m_program{}; GLint m_colorLoc{}; GLint m_rotationLoc{}; GLint m_translationLoc{}; GLint m_scaleLoc{}; GLuint m_VAO{}; GLuint m_VBO{}; }; #endif Nas linhas 20 a 24 é definida a estrutura Bullet. Observe que o VAO e VBO não está em Bullet, mas em Bullets, pois todos os tiros utilizam o mesmo VBO. Na linha 26 é definida a lista de tiros atualmente na cena. O número de elementos desta lista será alterado de acordo com a quantidade de tiros visíveis. Na linha 28 é definido o fator de escala comum a todos os tiros. bullets.cpp O arquivo começa com a definição de Bullets::create: #include &quot;bullets.hpp&quot; #include &lt;glm/gtx/rotate_vector.hpp&gt; void Bullets::create(GLuint program) { destroy(); m_program = program; // Get location of uniforms in the program m_colorLoc = abcg::glGetUniformLocation(m_program, &quot;color&quot;); m_rotationLoc = abcg::glGetUniformLocation(m_program, &quot;rotation&quot;); m_scaleLoc = abcg::glGetUniformLocation(m_program, &quot;scale&quot;); m_translationLoc = abcg::glGetUniformLocation(m_program, &quot;translation&quot;); // Get location of attributes in the program auto const positionAttribute{ abcg::glGetAttribLocation(m_program, &quot;inPosition&quot;)}; m_bullets.clear(); // Create geometry data auto const sides{10}; std::vector&lt;glm::vec2&gt; positions{{0, 0}}; auto const step{M_PI * 2 / sides}; for (auto const angle : iter::range(0.0, M_PI * 2, step)) { positions.emplace_back(std::cos(angle), std::sin(angle)); } positions.push_back(positions.at(1)); // Generate VBO of positions abcg::glGenBuffers(1, &amp;m_VBO); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); abcg::glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(glm::vec2), positions.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Create VAO abcg::glGenVertexArrays(1, &amp;m_VAO); // Bind vertex attributes to current VAO abcg::glBindVertexArray(m_VAO); abcg::glEnableVertexAttribArray(positionAttribute); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); abcg::glVertexAttribPointer(positionAttribute, 2, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // End of binding to current VAO abcg::glBindVertexArray(0); } A lista de tiros é inicializada como vazia na linha 20. O restante do código é para criar o VBO que será compartilhado por todos os tiros. O VBO contém vértices de um polígono regular de 10 lados e usa o mesmo código que utilizamos no projeto regularpolygons. A definição de Bullets::paint ficará como a seguir: void Bullets::paint() { abcg::glUseProgram(m_program); abcg::glBindVertexArray(m_VAO); abcg::glUniform4f(m_colorLoc, 1, 1, 1, 1); abcg::glUniform1f(m_rotationLoc, 0); abcg::glUniform1f(m_scaleLoc, m_scale); for (auto const &amp;bullet : m_bullets) { abcg::glUniform2f(m_translationLoc, bullet.m_translation.x, bullet.m_translation.y); abcg::glDrawArrays(GL_TRIANGLE_FAN, 0, 12); } abcg::glBindVertexArray(0); abcg::glUseProgram(0); } Todos os tiros têm a mesma cor (linha 58), ângulo de rotação (linha 59) e fator de escala (linha 60). A lista de tiros é iterada no laço das linhas 62 a 67. Cada tiro é renderizado como um GL_TRIANGLE_FAN. Em Bullets::destroy é liberado o VBO e VAO: void Bullets::destroy() { abcg::glDeleteBuffers(1, &amp;m_VBO); abcg::glDeleteVertexArrays(1, &amp;m_VAO); } Vamos agora à definição de Bullets::update: void Bullets::update(Ship &amp;ship, const GameData &amp;gameData, float deltaTime) { // Create a pair of bullets if (gameData.m_input[gsl::narrow&lt;size_t&gt;(Input::Fire)] &amp;&amp; gameData.m_state == State::Playing) { // At least 250 ms must have passed since the last bullets if (ship.m_bulletCoolDownTimer.elapsed() &gt; 250.0 / 1000.0) { ship.m_bulletCoolDownTimer.restart(); // Bullets are shot in the direction of the ship&#39;s forward vector auto const forward{glm::rotate(glm::vec2{0.0f, 1.0f}, ship.m_rotation)}; auto const right{glm::rotate(glm::vec2{1.0f, 0.0f}, ship.m_rotation)}; auto const cannonOffset{(11.0f / 15.5f) * ship.m_scale}; auto const bulletSpeed{2.0f}; Bullet bullet{.m_dead = false, .m_translation = ship.m_translation + right * cannonOffset, .m_velocity = ship.m_velocity + forward * bulletSpeed}; m_bullets.push_back(bullet); bullet.m_translation = ship.m_translation - right * cannonOffset; m_bullets.push_back(bullet); // Moves ship in the opposite direction ship.m_velocity -= forward * 0.1f; } } for (auto &amp;bullet : m_bullets) { bullet.m_translation -= ship.m_velocity * deltaTime; bullet.m_translation += bullet.m_velocity * deltaTime; // Kill bullet if it goes off screen if (bullet.m_translation.x &lt; -1.1f) bullet.m_dead = true; if (bullet.m_translation.x &gt; +1.1f) bullet.m_dead = true; if (bullet.m_translation.y &lt; -1.1f) bullet.m_dead = true; if (bullet.m_translation.y &gt; +1.1f) bullet.m_dead = true; } // Remove dead bullets m_bullets.remove_if([](auto const &amp;p) { return p.m_dead; }); } Um par de tiros é criado a cada disparo. O temporizador m_bulletCoolDownTimer é utilizado para fazer com que os disparos ocorram em intervalos de no mínimo 250 milissegundos. Observe, na linha 102, que subtraímos da velocidade da nave o vetor de direção dos tiros. Isso produz um efeito de recuo da nave. Quanto mais tiros são disparados, mais a nave será deslocada para trás. Nas linhas 106 a 119 são atualizadas as coordenadas de translação de cada tiro. Nas linhas 107 e 108, os tiros são atualizados de acordo com a velocidade da nave e a velocidade do próprio tiro. Nas linhas 110 a 118, verificamos se o tiro saiu da tela. Se sim, o flag m_dead torna-se true. A comparação é feita com -1.1f/+1.1f no lugar de -1.0f/+1.0f para ter certeza que todo o polígono do tiro (e não só seu centro) saiu da tela. Na linha 122, todos os tiros com m_dead == true são removidos da lista. Isso é tudo! Eis o jogo completo (link original): O código do projeto completo pode ser baixado deste link. As estrelas das camadas superiores se moverão mais rapidamente do que as estrelas das camadas inferiores, dando a sensação de profundidade do espaço.↩︎ O vetor é \\((0, 1)\\) pois a nave está alinhada ao eixo \\(y\\) positivo em sua orientação original.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
