[["index.html", "MCTA008-17 Computação Gráfica Apresentação", " MCTA008-17 Computação Gráfica Harlen Batagelo (harlen.batagelo@ufabc.edu.br) Universidade Federal do ABC 3º quadrimestre de 2022 Apresentação Caro/a estudante, Este site contém as notas de aula da disciplina MCTA008-17 Computação Gráfica para o 3º quadrimestre de 2022. O conteúdo foi elaborado originalmente para o ensino remoto dos Quadrimestres Suplementares seguindo o formato de um livro interativo voltado ao estudo autodirigido. Neste quadrimestre ele será usado como material de apoio às aulas presenciais. Os capítulos estão divididos em tópicos teóricos sobre o processo de geração de imagens no computador, e partes práticas de desenvolvimento de aplicações gráficas interativas usando C++ com a API gráfica OpenGL. Para informações sobre o cronograma das atividades e critérios de avaliação, consulte o plano de ensino disponível no Moodle. Bons estudos! — Harlen "],["pré-requisitos.html", "Pré-requisitos", " Pré-requisitos Para acompanhar a disciplina é recomendável ter conhecimento prévio do conteúdo abordado nas disciplinas de Algoritmos e Estruturas de Dados I e Geometria Analítica. As atividades práticas avaliativas serão desenvolvidas na linguagem C++. Embora não seja necessário ter fluência em C++, é recomendável ter proficiência em programação em C e familiaridade com conceitos básicos de programação orientada a objetos. Também é recomendável ter familiaridade com o Git e com o uso de alguma plataforma de hospedagem de repositórios Git tal como o GitHub, GitLab ou Bitbucket. Você deverá ser capaz de gerenciar seus próprios repositórios ao longo do quadrimestre. Atividades práticas Para realizar as atividades práticas é necessário ter um computador com sistema operacional 64 bits (Windows 10 ou superior, Linux ou macOS) e placa de vídeo compatível com OpenGL 3.3 ou superior. O OpenGL 3.3 é suportado em placas gráficas da família Nvidia GeForce 400 (2010) ou mais recentes, AMD Radeon HD 5000 (2009) em diante e Intel HD Graphics a partir dos processadores Intel de 7ª geração (2012). Caso a sua placa de vídeo seja de uma geração a partir de 2012, provavelmente ela deve suportar OpenGL 3.3. Se não suportar, há a possibilidade de simular o processamento gráfico em software através do driver Gallium llvmpipe da biblioteca Mesa. Visualizando este site Parte do conteúdo deste site requer um navegador com suporte a WebGL 2.0. Para informações detalhadas sobre o suporte do seu navegador a WebGL 2.0, consulte o WebGL Report. Dica Para garantir a visualização correta do conteúdo WebGL 2.0, utilize a versão mais recente do Google Chrome ou Mozilla Firefox. Além disso, use o navegador em um computador desktop ou laptop. Embora o site funcione em tablets e smartphones, pode ser difícil interagir com o conteúdo WebGL nesses dispositivos. Dependendo das configurações de DPI utilizadas no sistema de janelas, podem ocorrer problemas de redimensionamento dos elementos de interface no Chrome e em navegadores baseados no Chromium, como o Microsoft Edge ou Brave. Por exemplo, o cubo exibido acima pode ser redimensionado e as arestas podem apresentar distorções, parecendo mais serrilhadas que o normal: No Chrome, isso pode ser resolvido iniciando o navegador com a opção /high-dpi-support=1 /force-device-scale-factor=1 na linha de comando, ou então incluindo essas opções no atalho, ou simplesmente ajustando o zoom. Importante O Apple Safari possui suporte a WebGL 2.0 a partir da versão 15, mas o desempenho das aplicações pode ser muito baixo quando comparado a outros navegadores. Consulte o suporte a WebGL 2.0 em diferentes navegadores em https://caniuse.com/webgl2. "],["config.html", "1 Configuração do ambiente", " 1 Configuração do ambiente Neste capítulo veremos como configurar o ambiente de desenvolvimento para realizar as atividades práticas no computador. Qualquer que seja a plataforma – Linux, macOS ou Windows – será necessário instalar as seguintes ferramentas e bibliotecas conforme as instruções que veremos nas próximas seções: CMake, para automatizar a geração de scripts de compilação e ligação de forma independente de plataforma. Emscripten, para compilar código C++ e gerar binário em WebAssembly de modo a executar as aplicações no navegador. Git, para clonar do GitHub o repositório do SDK do Emscripten e da biblioteca de desenvolvimento que usaremos na disciplina. Também é recomendável usar o Git para o controle de versão das atividades que serão feitas ao longo do quadrimestre. GLEW, para carregamento das funções da API gráfica OpenGL. Simple DirectMedia Layer (SDL) 2.0, para gerenciamento de dispositivos de vídeo, dispositivos de entrada, áudio, entre outros componentes de hardware. SDL_image 2.0, para leitura de arquivos de imagem. Precisaremos também de um compilador recente com suporte a C++20, como o GCC 11, Clang 13, ou MSVC 19. Acompanhe nas seções a seguir o passo a passo da instalação desses recursos de acordo com o sistema operacional utilizado: Seção 1.1 para instalação no Linux; Seção 1.2 para instalação no macOS; Seção 1.3 para instalar no Windows. Não é necessário usar um IDE ou editor específico de código-fonte para o desenvolvimento das atividades. A compilação pode ser disparada através de scripts de linha de comando. Entretanto, como um exemplo, veremos na seção 1.4 como fazer a configuração básica do Visual Studio Code para o desenvolvimento de aplicações C++ com CMake. Na seção 1.5 veremos como instalar o framework (ABCg) criado especialmente para esta disciplina. O framework será utilizado em todas as atividades do curso para facilitar o desenvolvimento das aplicações gráficas. Dica Preferencialmente, configure o ambiente de desenvolvimento no sistema operacional nativo. Entretanto, caso o seu computador tenha recursos de processamento e memória suficientes, é possível configurar todo o ambiente em uma máquina virtual. O VMware Workstation Player (Windows e Linux) e VMWare Fusion Player (macOS) possuem suporte a aceleração gráfica 3D e são adequados para desenvolver as atividades da disciplina. Tanto o VMWare Workstation Player quanto o Fusion Player podem ser utilizados gratuitamente através de uma licença de uso pessoal. O Windows Subsystem for Linux 2 (WSL 2) também suporta aceleração gráfica através do Direct3D 12. É possível também configurar o ambiente de desenvolvimento em um container Docker. Entretanto, o suporte a gráficos com aceleração de hardware em um container Docker exige o uso do Linux e do NVIDIA Container Toolkit, que só funciona com GPUs da NVIDIA. "],["linux.html", "1.1 Linux", " 1.1 Linux As ferramentas e bibliotecas necessárias para o desenvolvimento das atividades da disciplina estão disponíveis nos repositórios de pacotes das principais distribuições Linux. A seguir veremos como instalar os pacotes na versão para desktop do Ubuntu 22.04 LTS. Há pacotes equivalentes em outras distribuições. Em um terminal, execute os passos a seguir. Atualize o sistema: sudo apt update &amp;&amp; sudo apt upgrade Instale o pacote build-essential (GCC, GDB, Make, etc): sudo apt install build-essential Instale o CMake e Git: sudo apt install cmake git Instale as bibliotecas GLEW, SDL 2.0 e SDL_image 2.0: sudo apt install libglew-dev libsdl2-dev libsdl2-image-dev Dica É recomendável instalar também as ferramentas Clang-Tidy e ClangFormat. Elas podem ser utilizadas em linha de comando ou no seu editor de código de preferência para fazer a formatação automática e linting de código C++. Instale o Clang-Tidy e ClangFormat com o seguinte comando: sudo apt install clang-tidy clang-format Outra ferramenta recomendada é o Ccache. Ela serve para acelerar a recompilação das atividades através da manutenção de um cache das compilações anteriores: Instale o pacote ccache: sudo apt install ccache Atualize os links simbólicos dos compiladores instalados: sudo /usr/sbin/update-ccache-symlinks Execute o comando a seguir para fazer com que o caminho do Ccache seja prefixado ao PATH sempre que um novo terminal for aberto: echo &#39;export PATH=&quot;/usr/lib/ccache:$PATH&quot;&#39; &gt;&gt; ~/.bashrc Reabra o terminal ou execute source ~/.bashrc. Para testar se o Ccache está ativado, execute o comando which g++. A saída deverá incluir o caminho /usr/lib/ccache/, como a seguir: /usr/lib/ccache/g++ Verificando o OpenGL O suporte ao OpenGL vem integrado no kernel do Linux através dos drivers de código aberto da biblioteca Mesa (drivers Intel/AMD/Nouveau). Para as placas da NVIDIA e AMD há a possibilidade de instalar os drivers proprietários do repositório nonfree (repositório restricted no Ubuntu), ou diretamente dos sites dos fabricantes: AMD ou NVIDIA. Os drivers proprietários, especialmente os da NVIDIA, geralmente têm desempenho superior aos de código aberto. Para verificar a versão do OpenGL suportada pelos drivers instalados, instale primeiro o pacote mesa-utils: sudo apt install mesa-utils Execute o comando: glxinfo | grep version O resultado deverá ser parecido com o seguinte: server glx version string: 1.4 client glx version string: 1.4 GLX version: 1.4 Max core profile version: 4.1 Max compat profile version: 4.1 Max GLES1 profile version: 1.1 Max GLES[23] profile version: 2.0 OpenGL core profile version string: 4.1 (Core Profile) Mesa 21.0.3 OpenGL core profile shading language version string: 4.10 OpenGL version string: 4.1 (Compatibility Profile) Mesa 21.0.3 OpenGL shading language version string: 4.10 OpenGL ES profile version string: OpenGL ES 2.0 Mesa 21.0.3 OpenGL ES profile shading language version string: OpenGL ES GLSL ES 1.0.16 Importante A versão em OpenGL version string ou OpenGL core profile version string deve ser 3.3 ou superior. Caso não seja, instale os drivers proprietários e certifique-se de que sua placa de vídeo tem os requisitos necessários para o OpenGL 3.3. Atualizando o GCC As atividades da disciplina farão uso de um framework de desenvolvimento que exige um compilador com suporte a C++20. Esse requisito é atendido se instalarmos uma versão recente do GCC, como o GCC 11 ou posterior. A versão padrão do GCC no Ubuntu 22.04 LTS é compatível com C++20. Então, se você seguiu as instruções de instalação até aqui usando o Ubuntu 22.04 ou uma versão mais recente, não é necessário atualizar o GCC. Caso sua versão do Ubuntu seja mais antiga que a 22.04, verifique qual é a saída de g++ --version. Por exemplo, no Ubuntu 20.04 o GCC padrão é o 9.3 e saída será assim: g++ (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Neste caso é necessário instalar uma versão mais recente. Para isso, adicione primeiro o PPA ubuntu-toolchain-r/test: sudo apt install software-properties-common sudo add-apt-repository ppa:ubuntu-toolchain-r/test Agora podemos instalar o GCC 11: sudo apt install gcc-11 g++-11 A instalação do GCC 11 não substitui a versão mais antiga já instalada. Entretanto, é necessário criar links simbólicos de gcc e g++ para a versão mais recente. Uma forma simples de fazer isso é através do comando update-alternatives. Primeiro, execute o comando a seguir para definir um valor de prioridade (neste caso, 100) para o GCC 11: sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100 --slave /usr/bin/g++ g++ /usr/bin/g++-11 Use o comando a seguir para definir um valor de prioridade mais baixo (por exemplo, 90) para a versão anterior do GCC, que neste exemplo é a versão 9: sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 Agora, execute o comando a seguir para escolher qual versão do GCC instalada será utilizada por padrão: sudo update-alternatives --config gcc Na lista de versões instaladas, selecione o GCC 11 caso ainda não esteja selecionado. Isso criará os links simbólicos. Para testar se a versão correta do GCC está sendo utilizada, execute g++ --version novamente. A saída deverá ser parecida com a seguinte: g++ (Ubuntu 11.2.0-1ubuntu1~20.04) 11.2.0 Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Instalando o Emscripten Vá a um diretório onde queira instalar o SDK do Emscripten. Por exemplo, o diretório home: cd Clone o repositório do SDK: git clone https://github.com/emscripten-core/emsdk.git Entre no diretório recém-criado: cd emsdk Baixe e instale o SDK atualizado (latest): ./emsdk install latest Ative o SDK latest para o usuário atual: ./emsdk activate latest Configure as variáveis de ambiente e PATH do compilador para o terminal atual: source ./emsdk_env.sh Execute o comando emcc --version. A saída deverá ser parecida com a seguinte: emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 3.1.18 (d5ca9bba6513763d5bdddbd0efff759332bd85d7) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Importante O passo 6 precisa ser refeito sempre que um novo terminal for aberto. Para não precisarmos fazer isso manualmente, automatize o processo com o seguinte comando: echo &#39;source &quot;./emsdk/emsdk_env.sh&quot; &gt; /dev/null 2&gt;&amp;1&#39; &gt;&gt; ~/.bashrc Isso adiciona source \"./emsdk/emsdk_env.sh &gt; /dev/null 2&gt;&amp;1\" ao final de ~/.bashrc, fazendo com que o script emsdk_env.sh seja executado automaticamente toda vez que um novo terminal for aberto (ajuste o caminho caso o Emscripten não esteja em ~/emsdk). Uma curiosidade: o trecho &gt; /dev/null 2&gt;&amp;1 serve para omitir a saída padrão (stdout) e o erro padrão (stderr), isto é, o script é executado em modo silencioso. "],["macos.html", "1.2 macOS", " 1.2 macOS Em um terminal, execute os passos a seguir: Execute o comando gcc. Se o GCC não estiver instalado, aparecerá uma caixa de diálogo solicitando a instalação das ferramentas de desenvolvimento de linha de comando. Clique em “Install”. Esse procedimento também instalará outras ferramentas, como o Make e Git. Para verificar se o GCC foi instalado, execute gcc --version. A saída deverá ser parecida com a seguinte (note que o GCC é apenas um atalho para o Apple Clang): Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk/usr/include/c++/4.2.1 Apple clang version 12.0.0 (clang-1200.0.32.28) Target: x86_64-apple-darwin19.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin Se o procedimento acima não funcionar (as instruções acima foram testadas no macOS Catalina), baixe o Command Line Tools for Xcode usando sua conta de desenvolvedor do Apple Developer, ou execute xcode-select --version no terminal. Em versões mais antigas do macOS pode ser necessário instalar o Xcode. Para instalar os demais pacotes de bibliotecas e ferramentas, instale o Homebrew com o seguinte comando: /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; Instale o CMake: brew install cmake Instale o GLEW, SDL 2.0 e SDL_image 2.0: brew install glew brew install sdl2 brew install sdl2_image Está pronto! Dica Opcionalmente, instale o Ccache para acelerar a recompilação das atividades: Instale o Ccache usando o Homebrew: brew install ccache Anote a saída de echo $(brew --prefix) (por exemplo, /usr/local). Abra o modo de edição do PATH: sudo nano /etc/paths Insira como primeira linha o caminho $(brew --prefix)/opt/ccache/libexec, onde $(brew --prefix) é a saída do passo 2. Por exemplo, /usr/local/opt/ccache/libexec. Salve (Ctrl+X e Y) e reinicie o terminal. Para testar, digite which gcc. A saída deverá ser um caminho que inclui o Ccache, como a seguir: /usr/local/opt/ccache/libexec/gcc Instalando o Emscripten Vá ao diretório home: cd Clone o repositório do SDK do Emscripten: git clone https://github.com/emscripten-core/emsdk.git Entre no diretório recém-criado: cd emsdk Baixe e instale o SDK atualizado (latest): ./emsdk install latest Ative o SDK latest para o usuário atual: ./emsdk activate latest Configure as variáveis de ambiente e PATH do compilador para o terminal atual: source ./emsdk_env.sh Execute o comando emcc --version. A saída deverá ser parecida com a seguinte: emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 3.1.18 (d5ca9bba6513763d5bdddbd0efff759332bd85d7) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Importante Refaça o passo 6 sempre que abrir um terminal. Como alternativa, insira o comando a seguir na última linha de ~/.zshrc (se estiver usando o shell Zsh no macOS Catalina ou posterior) ou ~/.bashrc (se estiver usando o shell Bash em versões anteriores) para que o script seja executado automaticamente toda vez que um terminal for aberto: source ./emsdk/emsdk_env.sh &gt; /dev/null 2&gt;&amp;1 O trecho &gt; /dev/null 2&gt;&amp;1 serve para omitir a saída padrão (stdout) e o erro padrão (stderr). "],["windows.html", "1.3 Windows", " 1.3 Windows Para a instalação das ferramentas e bibliotecas de desenvolvimento no Windows, utilizaremos o MSYS2. MSYS2 é um ambiente de terminal tipo Unix com acesso a um repositório de ferramentas e bibliotecas de desenvolvimento de aplicações nativas em Windows através do gerenciador de pacotes pacman. Essas ferramentas e bibliotecas incluem o CMake, Git, GLEW, SDL 2.0 e SDL_image 2.0, entre outras que vamos utilizar na disciplina. O MSYS2 também permite instalar o MinGW-W64. Com isso conseguiremos usar o compilador GCC para gerar binários nativos para o Windows 64 bits e poderemos também usar o GDB para depurar nossos programas. Por que não o Visual Studio? Poderíamos instalar as ferramentas de desenvolvimento sem precisar do MSYS2. O Visual Studio é uma alternativa ao GCC e tem a vantagem de ser um IDE completo. A desvantagem é que a instalação das dependências é mais complexa, intrusiva e suscetível a incompatibilidades decorrentes das diferentes configurações do Windows. Daremos preferência ao MSYS2 pois a instalação é mais simples e a experiência de uso das ferramentas é mais parecida com a das outras plataformas. Siga os passos a seguir para instalar o MSYS2 e as ferramentas/bibliotecas de desenvolvimento: Baixe o instalador de https://www.msys2.org, execute-o e siga as instruções de instalação. Abra o shell do MSYS2 (aplicativo “MSYS2 MSYS” no menu Iniciar) e execute o seguinte comando: pacman -S git mingw-w64-x86_64-ccache mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-gdb mingw-w64-x86_64-ninja mingw-w64-x86_64-glew mingw-w64-x86_64-SDL2 mingw-w64-x86_64-SDL2_image Isso instalará as ferramentas Git, Ccache, CMake, Ninja (o Ninja substitui o GNU Make no Windows), GCC e GDB (do MinGW-W64), e as bibliotecas GLEW, SDL 2.0 e SDL_image 2.0. Opcionalmente, instale o pacote mingw-w64-x86_64-glslang com o comando a seguir. Isso instalará a ferramenta glslangValidator que poderá ser usada como linter de código na linguagem GLSL (linguagem de shader que será utilizada na disciplina): pacman -S mingw-w64-x86_64-glslang Ao terminar a instalação, feche o shell do MSYS2. Baixe o instalador do Python 3 para Windows 64 bits e execute-o. No restante do texto usaremos como exemplo a versão 3.10, mas qualquer versão a partir da 3.6 é suportada. Durante a instalação, certifique-se de ativar a opção “Add Python 3.10 to PATH”. Após a instalação, abra o Prompt de Comando (cmd.exe) e execute o comando where python para exibir os diferentes caminhos em que o python é alcançado pela variável de ambiente Path. O resultado deverá ser parecido com o seguinte: C:\\&gt;where python C:\\Users\\ufabc\\AppData\\Local\\Programs\\Python\\Python310\\python.exe C:\\Users\\ufabc\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe O primeiro caminho exibido deve ser o caminho do executável do Python que acabou de ser instalado. Neste caso está correto, pois o Python foi instalado no local padrão do instalador que é %LocalAppData%\\Programs\\Python\\Python310 (neste exemplo, o nome do usuário é ufabc). No menu inicial, procure por “Editar variáveis de ambiente para a sua conta”. Edite a variável Path do usuário atual e inclua os caminhos para mingw64\\bin e usr\\bin do MSYS2. Por exemplo, se o MSYS2 foi instalado em C:\\msys64, inclua os seguintes caminhos no Path1: C:\\msys64\\usr\\bin C:\\msys64\\mingw64\\bin Edite a ordem dos caminhos de tal forma que os caminhos do Python sejam listados antes dos caminhos do MSYS2, como mostra a figura a seguir. Essa ordem é importante pois o MSYS2 também instala o Python 3, mas queremos usar o Python do Windows: Para testar se o MSYS2 foi instalado corretamente, abra o Prompt de Comando e execute o comando g++ --version. A saída deverá ser parecida com a seguinte: g++ (Rev5, Built by MSYS2 project) 12.1.0 Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Verificando o OpenGL O suporte ao OpenGL vem integrado ao Windows. Apenas certifique-se de instalar os drivers mais recentes da sua placa de vídeo. Instalando o Emscripten Abra o Prompt de Comando em algum caminho onde queira instalar a pasta do SDK do Emscripten (por exemplo, C:\\). Note the o terminal deve ser o Prompt de Comando e não o PowerShell. Clone o repositório do SDK: git clone https://github.com/emscripten-core/emsdk.git Entre na pasta recém-criada: cd emsdk Baixe e instale o SDK atualizado (latest): emsdk install latest Ative o SDK latest para o usuário atual: emsdk activate latest Configure as variáveis de ambiente e PATH do compilador para o terminal atual: emsdk_env.bat Para testar se a instalação foi bem-sucedida, execute o comando emcc --version. A saída deverá ser parecida com a seguinte: emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 3.1.18 (d5ca9bba6513763d5bdddbd0efff759332bd85d7) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Importante Refaça o passo 6 sempre que abrir um terminal ou execute o comando a seguir para registrar permanentemente as variáveis de ambiente no registro do sistema: emsdk_env.bat --permanent Caso não queira modificar o registro do sistema, crie um atalho para cmd.exe e use a opção /k para executar o arquivo emsdk_env.bat sempre que o Prompt de Comando for aberto. Por exemplo: cmd.exe /k &quot;C:\\emsdk\\emsdk_env.bat&quot; Mude esse caminho de acordo com o local onde emsdk_env.bat foi instalado. A variável Path existe tanto nas variáveis do usuário quanto nas variáveis do sistema. A modificação do Path do usuário geralmente é suficiente para uma instalação correta. Se ocorrer algum erro ao seguir as instruções de construção do “Hello, World!” na seção 1.5 (erro de construção ou de DLL não encontrada), experimente alterar o Path do sistema ao invés do usuário.↩︎ "],["vscode.html", "1.4 Visual Studio Code", " 1.4 Visual Studio Code Para desenvolver as atividades não é necessário usar um IDE ou editor em particular. Os códigos podem ser escritos em qualquer editor de texto não formatado e a compilação pode ser feita em linha de comando. Entretanto, é recomendável utilizar um editor/IDE como o CLion, Emacs, Sublime Text, Vim, Visual Studio Code, ou outro semelhante que seja capaz de oferecer funcionalidades de preenchimento automático de código, detecção de erros, ajuda sensível ao contexto e integração de construção com o CMake. A seguir veremos como configurar o Visual Studio Code (VS Code) para deixá-lo pronto para o desenvolvimento das atividades. O procedimento é bem simples e é o mesmo no Linux, macOS e Windows: Instale o VS Code através do instalador disponível em https://code.visualstudio.com/ ou através do gerenciador de pacotes de seu sistema operacional. Abra o editor e, na janela de extensões (Ctrl+Shift+X), instale a extensão C/C++ Extension Pack. Isso já é o suficiente para começarmos a trabalhar. Ainda precisaremos de algumas configurações extras para habilitar a depuração de código, mas veremos isso na seção a seguir (1.5). Caso você queira usar outro editor ou IDE, consulte a documentação específica de seu editor sobre como fazer a integração com o CMake e sobre como usar o GDB/LLDB para depurar código. Importante Qualquer que seja o IDE/editor utilizado, certifique-se de que o CMake e GCC estejam instalados e visíveis no PATH de acordo com as instruções mostradas nas seções anteriores. Dicas Em sistemas que possuem as ferramentas extras do Clang para linting e formatação de código como o Clang-Tidy e ClangFormat, é possível instalar extensões para fazer análise estática em tempo real e formatar o código automaticamente sempre que um arquivo é salvo. Uma dessas extensões é o clangd, baseado no servidor de mesmo nome do LLVM. Como vimos na seção 1.1, o Clang-Tidy e ClangFormat podem ser instalados no Ubuntu com os seguintes comandos: sudo apt install clang-tidy clang-format No Windows com MSYS2, abra o shell do MSYS2 e execute o seguinte comando: pacman -S mingw-w64-x86_64-clang-tools-extra Para ativar a formatação automática de código sempre que o arquivo for salvo, abra o arquivo JSON contendo as configurações do usuário do VS Code (opção “Preferences: Open User Settings (JSON)” da paleta de comandos) e adicione a chave \"editor.formatOnSave\": true. Para a análise estática em tempo real de código GLSL, instale a extensão GLSL Lint. Isso ajudará a evitar erros de sintaxe comuns na programação dos shaders em GLSL. Essa extensão instala também o Shader languages support for VS Code para habilitar o syntax highlighting e autocomplete do código GLSL. Explore o Visual Studio Marketplace para instalar outras extensões de sua preferência. Por exemplo, se você é fã do Emacs, instale o VSCodeEmacs para emular as teclas do Emacs no VS Code. Se você prefere o Vim, instale o VSCodeVim. E se você só quer relaxar um pouco, instale o Chrome Dinosaur Game! "],["abcg.html", "1.5 ABCg", " 1.5 ABCg Para facilitar o desenvolvimento das atividades práticas utilizaremos a biblioteca ABCg desenvolvida especialmente para esta disciplina. A ABCg permite a prototipagem rápida de aplicações gráficas interativas 3D em C++ capazes de rodar tanto no desktop (binário nativo) quanto no navegador (binário WebAssembly). Internamente a ABCg utiliza a biblioteca SDL para gerenciar o acesso a dispositivos de entrada (mouse/teclado/gamepad) e saída (vídeo e áudio) de forma independente de plataforma, e a biblioteca GLEW para acesso às funções da API gráfica OpenGL. Além disso, a API do Emscripten é utilizada sempre que a aplicação é compilada para gerar binário WebAssembly. A ABCg é mais propriamente um framework do que uma biblioteca, pois ela gerencia o fluxo de trabalho da aplicação. Nosso código deverá ser construído em torno da estrutura fornecida pela ABCg. Do ponto de vista do desenvolvedor, essa estrutura é apenas uma leve camada de abstração das APIs utilizadas. Por exemplo, é possível acessar diretamente as funções da API gráfica OpenGL. De fato, faremos isso na maior parte das vezes. Outras bibliotecas também utilizadas e que podem ser acessadas diretamente são: CPPIterTools: para o suporte a laços range-based em C++ usando funções do tipo range, enumerate e zip similares às da linguagem Python; Dear ImGui: para gerenciamento de widgets de interface gráfica do usuário, tais como janelas, botões e caixas de edição; {fmt}: como alternativa mais eficiente ao stdio da linguagem C (printf, scanf, etc) e iostreams do C++ (std::cout, std::cin, etc), e para formatação de strings com uma sintaxe similar às f-strings do Python; Guidelines Support Library (GSL): para uso de funções e tipos de dados recomendados pelo C++ Core Guidelines; OpenGL Mathematics (GLM): para suporte a operações de transformação geométrica com vetores e matrizes; tinyobjloader: para a leitura de modelos 3D no formato Wavefront OBJ. A seguir veremos como instalar e compilar a ABCg junto com um exemplo de uso. Instalação Em um terminal, clone o repositório do GitHub: git clone https://github.com/hbatagelo/abcg.git Observação A release mais recente da ABCg também pode ser baixada como um arquivo compactado de https://github.com/hbatagelo/abcg/releases/latest. Atenção No Windows, certifique-se de clonar/descompactar o repositório em um diretório cujo nome não contenha espaços ou caracteres especiais. Por exemplo, clone/descompacte em C:\\cg em vez de C:\\computação gráfica. O repositório tem a estrutura mostrada a seguir. Para simplificar, os arquivos e subdiretórios .git* foram omitidos: abcg │ .clang-format │ .clang-tidy │ build.bat │ build.sh | build-vs.bat │ build-wasm.bat │ build-wasm.sh | CHANGELOG.md │ CMakeLists.txt | DockerFile │ LICENSE │ README.md │ runweb.bat │ runweb.sh │ └───abcg │ │ ... │ └───cmake │ │ ... │ └───examples │ │ ... │ └───public │ ... Os arquivos .clang-format e .clang-tidy são arquivos de configuração utilizados pelas ferramentas ClangFormat e Clang-Tidy caso estejam instaladas. Os arquivos build.* são scripts de compilação em linha de comando. Note que há scripts correspondentes com extensão .bat para usar no Prompt de Comando do Windows 2: build.sh/build.bat: para compilar a ABCg e os exemplos em binários nativos usando o compilador padrão (no nosso caso, o GCC); build-wasm.sh/build-wasm.bat: similar ao build.sh, mas para gerar binário em WebAssembly dentro do subdiretório public; build-vs.bat: similar ao build.bat, mas usando o compilador do Visual Studio 2022 ao invés do GCC do MSYS2. O arquivo CMakeLists.txt é o script de compilação do CMake. Os arquivos runweb.sh e runweb.bat podem ser usados para criar um servidor web local para servir o conteúdo de public. Os subdiretórios são os seguintes: abcg contém o código-fonte da ABCg e suas dependências. cmake contém scripts auxiliares de configuração do CMake. examples contém um exemplo de uso da ABCg: o “Hello, World!”; public contém os códigos HTML para exibir o “Hello, World!” no navegador. Observação O “Hello, World!” pode usar tanto a API gráfica OpenGL (código-fonte em examples/opengl) quanto a API gráfica Vulkan (código-fonte em examples/vulkan). Nesta disciplina usaremos o OpenGL em todas as atividades. Em particular, usaremos o OpenGL 3.3. Assim poderemos possível construir aplicações para desktop e web usando o mesmo código-fonte. Por este motivo, os scripts CMake da ABCg estão configurados para usar o OpenGL por padrão. Compilando na linha de comando Execute o script build.sh (Linux/macOS) ou build.bat (Windows) para iniciar o processo de configuração e construção da versão OpenGL do “Hello, World!”. A saída será similar a esta (o exemplo a seguir mostra a saída no Ubuntu): -- The C compiler identification is GNU 11.2.0 -- The CXX compiler identification is GNU 11.2.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/lib/ccache/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/lib/ccache/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done Using ccache -- Found OpenGL: /usr/lib/x86_64-linux-gnu/libOpenGL.so -- Found GLEW: /usr/include (found version &quot;2.2.0&quot;) -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success -- Found Threads: TRUE -- Found SDL2: /usr/lib/x86_64-linux-gnu/libSDL2main.a;/usr/lib/x86_64-linux-gnu/libSDL2.so -- Found SDL2_image: /usr/lib/x86_64-linux-gnu/libSDL2_image.so -- Configuring done -- Generating done -- Build files have been written to: /home/ufabc/abcg/build ... [100%] Linking CXX executable ../../bin/helloworld [100%] Built target helloworld Ao final, os binários estarão disponíveis no subdiretório build. A biblioteca estática estará em build/abcg/libabcg.a e o executável do exemplo “Hello, World!” estará em build/bin/helloworld. Para testar, execute o helloworld. No Linux/macOS: ./build/bin/helloworld/helloworld No Windows: .\\build\\bin\\helloworld\\helloworld.exe | cat Importante No Windows, a saída deve sempre ser redirecionada para cat ou tee. Se isso não for feito, nenhuma saída de texto será exibida no terminal. Isso se deve a um bug do MSYS2. Observação Observe o conteúdo de build.sh (build.bat contém instruções equivalentes): #!/bin/bash set -euo pipefail BUILD_TYPE=${1:-Release} CMAKE_EXTRA_ARGS=${2:-&quot;&quot;} # Reset build directory rm -rf build mkdir -p build &amp;&amp; cd build # Configure cmake -DCMAKE_BUILD_TYPE=&quot;$BUILD_TYPE&quot; &quot;$CMAKE_EXTRA_ARGS&quot; .. # Build if [[ &quot;$OSTYPE&quot; == &quot;darwin&quot;* ]]; then # macOS NUM_PROCESSORS=&quot;$(sysctl -n hw.ncpu)&quot; else NUM_PROCESSORS=&quot;$(nproc)&quot; fi cmake --build . --config &quot;$BUILD_TYPE&quot; -- -j &quot;$NUM_PROCESSORS&quot; A variável BUILD_TYPE é Release por padrão, mas pode ser modificada passando a string Debug, MinSizeRel ou RelWithDebInfo como primeiro argumento de build.sh. A opção Debug ou RelWithDebInfo é utilizada quando queremos gerar símbolos de depuração. O modo Release (padrão) ou MinSizeRel devem ser usados quando queremos gerar um binário otimizado e sem arquivos de símbolos de depuração. Em particular, Release otimiza em favor do código mais rápido, enquanto MinSizeRel otimiza em favor do binário de menor tamanho. build.sh/build.bat também aceita um segundo argumento que corresponde a uma string a ser passada como argumento do CMake durante a configuração do projeto. Por exemplo, para compilar no modo Release e com a API gráfica OpenGL podemos executar build.sh Release -DGRAPHICS_API=OpenGL (neste caso basta executar build.sh, pois essas já são as configurações padrão). Observe que o script apaga o subdiretório build antes de criá-lo novamente. Portanto, não salve arquivos dentro de build pois eles serão apagados na próxima compilação! A geração dos binários usando o CMake é composta de duas etapas: a configuração (cmake -DCMAKE_BUILD_TYPE=$BUILD_TYPE ..) e a construção (cmake --build . --config $BUILD_TYPE). A configuração gera os scripts do sistema de compilação nativo (por exemplo, arquivos Makefile ou Ninja). A construção dispara a compilação e ligação usando tais scripts. Todos os arquivos gerados na configuração e construção ficam armazenados no subdiretório build. Compilando no VS Code Primeiramente, apague o subdiretório build caso você já tenha compilado a ABCg via linha de comando na seção anterior. No VS Code, selecione o menu “File &gt; Open Folder…” e abra a pasta abcg. Na primeira vez que a pasta é aberta aparecerá uma caixa de mensagem perguntando se você confia nos autores do projeto. Esperamos que você selecione “Yes” : No canto inferior direito da janela aparecerá uma notificação perguntando se você quer configurar o projeto. Selecione “Yes”. Ao fazer isso, será feita uma varredura no sistema para identificar os compiladores e toolchains disponíveis. Uma lista dos “kits” de compilação encontrados aparecerá na parte superior da janela. O exemplo a seguir é o resultado exibido no Ubuntu: Selecione um kit compatível, como o GCC 11.2 ou mais recente. Ao fazer isso, o CMake iniciará o processo de configuração do projeto. Esse processo gera, dentro de um subdiretório build, os arquivos que serão utilizados pelo sistema de construção nativo. Caso queira invocar manualmente a configuração do CMake, acesse a paleta de comandos (Ctrl+Shift+P) e digite a opção “CMake: Configure”. Se aparecer uma notificação pedindo para configurar o projeto sempre que ele for aberto, selecione “Yes”: Após o término da configuração, é possível que apareça uma outra notificação solicitando permissão para configurar o Intellisense. Selecione “Allow”. Além disso, pode aparecer também uma notificação sobre o uso do arquivo compile_commands.json, como mostrado a seguir. Selecione “Yes” novamente: O arquivo compile_commands.json é gerado automaticamente pelo CMake. Ele contém os comandos de compilação e o caminho de cada unidade de tradução utilizada no projeto. O IntelliSense (ou clangd) utiliza as informações desse arquivo para habilitar as referências cruzadas. Importante A construção dos projetos usando o CMake é feita em duas etapas: Configuração: consiste na geração dos scripts do sistema de compilação nativo (por exemplo, arquivos Makefile ou Ninja); Construção: consiste no disparo da compilação e ligação usando os scripts gerados na configuração, além da execução de etapas de pré e pós-construção definidas nos scripts dos arquivos CMakeLists.txt. Tanto os arquivos da configuração quanto os da construção (binários) são gravados no subdiretório build. Geralmente a configuração só precisa ser feita uma vez e depois refeita caso o subdiretório build tenha sido apagado, ou após a alteração do kit de compilação, ou ainda após a alteração do build type (por exemplo, de Debug para Release). As informações de configuração ficam armazenadas em um arquivo CMakeCache.txt dentro de build. Como indicado na figura abaixo, na barra de status há botões para selecionar o build type/configurar, selecionar o kit de compilação, e construir a aplicação. A opção de construir já se encarrega de configurar o projeto caso os arquivos de configuração ainda não tenham sido gerados. Essas opções também estão disponíveis na paleta de comandos. Os comandos são: “CMake: Select Variant”: para selecionar um build type; “CMake: Select a Kit”: para selecionar um kit de compilação; “CMake: Configure”: para configurar o projeto usando o kit e o build type atual; “CMake: Build”: para construir o projeto. “CMake: Clean Rebuild”: para apagar as configurações anteriores do CMake, reconfigurar e reconstruir o projeto. Observação Os build types permitidos no CMake são: Debug para gerar binários não otimizados e com arquivos de símbolos de depuração. Esse é o build type padrão (ao contrário de build.sh e build.bat, que usam o modo Release por padrão); RelWithDebInfo para gerar arquivos de símbolos de depuração com binários otimizados; Release para gerar binários otimizados e favorecer código mais rápido. Essa opção não gera os arquivos de símbolos de depuração; MinSizeRel, semelhante ao Release, mas a otimização tenta gerar binário de menor tamanho. Para compilar e gerar os binários, tecle F7 ou clique em “Build” na barra de status. O progresso será exibido na janela “Output” do CMake/Build. Se a construção terminar com sucesso, a última linha de texto da janela Output será: [build] Build finished with exit code 0 Os arquivos gerados na construção ficam armazenados no subdiretório build, da mesma forma como ocorre na compilação via linha de comando. Para testar, abra um terminal e execute ./build/bin/helloworld/helloworld (Linux/macOS) ou .\\build\\bin\\helloworld\\helloworld.exe (Windows). Atenção A configuração do CMake gerada a partir do VS Code não é necessariamente a mesma gerada usando os scripts de linha de comando: o compilador pode ser diferente, ou o build type pode ser diferente. Se em algum momento você construir o projeto via linha de comando usando os scripts .sh ou .bat e depois quiser construir pelo editor, apague o subdiretório build antes de retornar ao VS Code. Isso forçará uma nova configuração do CMake e evitará erros de incompatibilidade entre as configurações. Na primeira vez que um arquivo com extensão .cpp for aberto no editor, algumas notificações poderão aparecer. Experimente abrir, por exemplo, examples\\helloworld\\main.cpp. Se a extensão clangd foi instalada como sugerido na seção 1.4, a caixa de mensagem a seguir será exibida. Selecione “Install”. A seguinte mensagem também poderá aparecer. Neste caso, selecione “Disable IntelliSense”: Ao final dessas configurações, reinicie o editor. Isso pode ser feito rapidamente selecionando a opção “Developer: Reload Window” da paleta de comandos. Depurando no VS Code Podemos depurar facilmente nossas aplicações com GDB ou LLDB usando a interface do VS Code. Após construir um projeto com build type Debug ou RelWithDebInfo, devemos abrir um de seus arquivos com extensão .cpp. Isso é necessário para fazer com que o VS Code identifique que queremos configurar a depuração de um projeto em linguagem C++. Por exemplo, para configurar a depuração do projeto “Hello, World!”, abra o arquivo examples\\helloworld\\main.cpp. Selecione a opção “Run and Debug” na barra de atividades (Ctrl+Shift+D). Em seguida, clique na opção “create a launch.json file”: Se aparecer um drop-down list de seleção do ambiente de depuração, selecione “C++ (GDB/LLDB)”. Isso criará o arquivo launch.json. O arquivo também será aberto no editor. Copie e cole em launch.json o conteúdo exibido a seguir. Este é uma exemplo para depurar o “Hello, World!” no Linux ou macOS usando o GDB. Um exemplo de configuração para o Windows é mostrado mais adiante: { &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceFolder}/build/bin/helloworld/helloworld&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ] } ] } Observe que o valor da chave program aponta para o executável do projeto: ${workspaceFolder}/build/bin/helloworld/helloworld. Observação ${workspaceFolder} é uma variável pré-definida do VS Code que contém o caminho da pasta do projeto. Consulte a documentação para informações sobre outras variáveis disponíveis. A listagem a seguir mostra um exemplo de launch.json para depurar o “Hello, World!” no Windows usando o GDB do MSYS2: { &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceFolder}/build/bin/helloworld/helloworld.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ] } ] } Veja que o valor da chave miDebuggerPath contém o caminho completo do GDB, que é C:\\msys64\\mingw64\\bin\\gdb.exe supondo que o MSYS2 tenha sido instalado em C:\\msys64. O valor da chave externalConsole pode ser modificado para true caso você prefira que um novo terminal seja aberto durante a depuração. Consulte a documentação sobre depuração para informações sobre outras opções e informações gerais sobre como depurar código no editor. Após modificar o arquivo launch.json, selecione novamente a opção “Run” na barra de atividades ou aperte F5 para iniciar o programa no modo de depuração. Reedite o arquivo launch.json sempre que mudar o nome do executável que você queira depurar. Observação No VS Code para Windows, configure o terminal padrão para “Command Prompt” no lugar de “PowerShell”, uma vez que nossos scripts são compatíveis apenas com o Prompt de Comando. Para fazer isso, abra a paleta de comandos (Ctrl+Shift+P), acesse o comando “Terminal: Select Default Profile” e então selecione “Command Prompt”. Compilando para WASM Podemos compilar as aplicações ABCg para WebAssembly (WASM) de modo a executá-las diretamente no navegador. A construção é feita via linha de comando usando o toolchain Emscripten. Acompanhe a seguir como construir o “Hello, World!” para WASM e como testá-lo no navegador: Em um terminal (shell ou Prompt de Comando), ative as variáveis de ambiente do Emscripten (script emsdk_env.sh/emsdk_env.bat do SDK). Após isso, o compilador emcc deverá estar visível no PATH; No diretório abcg, execute build-wasm.sh (Linux/macOS) ou build-wasm.bat (Windows). Isso fará com que o CMake inicie a configuração do projeto e a construção dos binários. Os arquivos resultantes serão gravados em abcg/public. Em nosso caso, esses arquivos são helloworld.data (arquivo de dados/assets), helloworld.js (arquivo JavaScript) e helloworld.wasm (binário WebAssembly); Execute o script runweb.sh (Linux/macOS) ou runweb.bat (Windows) para rodar um servidor web local. O conteúdo de public ficará disponível em http://localhost:8080/; Abra a página http://localhost:8080/helloworld.html que chama o script helloworld.js recém-criado. A página HTML não faz parte do processo de construção e foi criada previamente. O resultado será semelhante ao exibido a seguir: uma aplicação mostrando um triângulo colorido e uma caixa de diálogo com alguns controles de interface. A pequena janela de texto abaixo da janela da aplicação é uma área de texto em HTML que mostra o conteúdo do terminal. Aqui, são exibidas algumas informações sobre o OpenGL (versão utilizada, fornecedor do driver, etc). Observação O subdiretório public contém, além do helloworld.html: full_window.html: para exibir o “Hello, World!” ocupando a janela inteira do navegador; full_window_console.html: idêntico ao anterior, mas com a sobreposição das mensagens do console na tela. Nos próximos capítulos veremos como construir novas aplicações usando a ABCg. Revisão de C++ Se você está mais habituado com programação em C ou C++ anterior ao C++11, o código das atividades da disciplina usando a ABCg poderá parecer pouco familiar. Revisaremos nesta seção alguns dos conceitos de C++ que podem gerar dúvidas em programadores que vieram da linguagem C, como a conversão explícita de tipos usando named casts, inicialização uniforme com {} e uso da palavra-chave auto. A aplicação desses conceitos segue as boas práticas de programação indicadas no C++ Core Guidelines. Dica Aproveite as primeiras semanas de aula para se familiarizar com os conceitos do chamado “C++ moderno” (C++11 em diante). Isso facilitará o entendimento do código da ABCg nos próximos capítulos. Uma referência rápida (cheatsheet) ao C++ moderno está disponível em https://github.com/AnthonyCalandra/modern-cpp-features. Um excelente livro é o A Tour of C++, de Bjarne Stroustrup. Há também recursos gratuitos como os sites learncpp.com e tutorialspoint.com. A documentação da Microsoft sobre C++ é uma opção em português. Há uma referência sobre a linguagem C++ e sobre a biblioteca C++ padrão. Consulte também o C++ Core Guidelines para ficar a par das boas práticas de programação. Uma referência mais completa e aprofundada da linguagem está disponível em cppreference.com. Algumas partes estão traduzidas para o português. Named casts Observe os seguintes exemplos de conversões explícitas de tipos (casts) usando a sintaxe tradicional oriunda da linguagem C: int a = (int)7.9; // double para int float b = (float)1 / 3; // int para float unsigned *pa = (unsigned *)&amp;a; // int* para unsigned* void foo(Base *b) { Derived *pd = (Derived *)b; // Base* para Derived* // ... } Estes casts “estilo C” têm uma sintaxe concisa, mas nem sempre traduzem de forma clara a intenção do programador. Além disso, a conversão é feita por conta e risco do programador. Não há verificação da validade da conversão, por exemplo, na conversão de Base* (ponteiro de uma classe base) para Derived* (ponteiro para uma classe derivada de Base). C++ procura tornar as conversões explícitas mais expressivas e seguras através de quatro tipos de casts chamados de named casts: static_cast para conversões entre tipos básicos cuja validade pode ser verificada em tempo de compilação (por exemplo, float para int e vice-versa); const_cast para conversões entre tipos de diferentes qualificações (por exemplo, de int const para int); reinterpret_cast para conversões entre tipos representados por diferentes padrões de bits na memória (por exemplo, int* para char*); dynamic_cast para conversões de ponteiros e referências a objetos com polimorfismo dinâmico. Os exemplos anteriores podem ser escritos assim com named casts: int a = static_cast&lt;int&gt;(7.9); // double para int float b = static_cast&lt;float&gt;(1) / 3; // int para float unsigned *pa = reinterpret_cast&lt;unsigned *&gt;(&amp;a); // int* para unsigned* void foo(Base *b) { // Não compila se Base não for uma classe polimórfica Derived *pd = dynamic_cast&lt;Derived *&gt;(b); // Base* para Derived* // ... } A sintaxe é mais verbosa, mas a intenção do programador fica mais clara e o código torna-se mais seguro. Por exemplo, dynamic_cast retorna nulo se b (ponteiro para Base) não puder ser convertido para Derived* (por exemplo, se o objeto apontado por b é de uma classe incompatível com Derived). Esse erro passaria despercebido com o cast estilo C. O ideal é usarmos a menor quantidade possível de casts. Em geral só precisaremos usar static_cast, e reinterpret_cast nas atividades do curso. Entretanto, os códigos das atividades vão um pouco mais além e seguem a diretriz Pro.safety do C++ Core Guidelines. Essa diretriz recomenda o uso de gsl::narrow_cast e gsl::narrow no lugar de static_cast para conversões com estreitamento: gsl::narrow_cast é o mesmo que static_cast. gsl::narrow é o mesmo que static_cast quando não há perda de informação na conversão. Se houver perda de informação, ocorre um erro de compilação. Conversões com estreitamento são aquelas em que existe a possiblidade de perda de informação (por exemplo, float para int, ou double para float). Considere o seguinte exemplo de substituição de static_cast por gsl::narrow em uma conversão com estreitamento: // float x = static_cast&lt;float&gt;(7.9); // Antes: OK float x = gsl::narrow&lt;float&gt;(7.9); // Depois: intenção mais clara Poderíamos usar static_cast, mas o uso de gsl::narrow deixa nossa intenção mais clara: esperamos que a conversão de 7.9 (um double) para float não perca informação. Afinal, float tem precisão suficiente para representar uma casa decimal. Se por algum motivo houver perda de informação, gsl::narrow gerará um erro de compilação e então saberemos que algo está errado3. Agora considere o seguinte exemplo de substituição de static_cast por gsl::narrow_cast: // int x = static_cast&lt;int&gt;(7.9f); // Antes: OK int x = gsl::narrow_cast&lt;int&gt;(7.9f); // Depois: intenção mais clara Nesse caso também poderíamos usar static_cast, mas gsl::narrow_cast deixa nossa intenção mais clara: esperamos que a conversão de 7.9f (um float) para um int perca informação. Afinal, a parte fracionária será perdida. gsl::narrow_cast indica que estamos ciente dessa perda e que isso não é um problema para nós. Em resumo, em conversões com estreitamento, isto é, com possível perda de informação, o uso de gsl::narrow e gsl::narrow_cast mostra melhor a intenção do programador. Ademais, de nossa parte, faz com que tenhamos que pensar melhor se estamos usando o static_cast corretamente. Inicialização uniforme Nas atividades do curso usaremos a chamada inicialização uniforme sempre que possível. A inicialização uniforme consiste no uso de {} no lugar de = ou () para inicializar objetos. Segundo a diretriz ES.23 do C++ Core Guidelines, “as regras para inicialização com {} são mais simples, mais gerais, menos ambíguas, e mais seguras do que outras formas de inicialização”. Observe os exemplos abaixo sem inicialização com {}, isto é, usando apenas = ou (): int a = 0; // Inicializa a com 0 int b(42); // Inicializa b com 42 double c(); // Declaração de uma função (ambíguo) int d = 7.9; // Inicializa implicitamente com 7 (inseguro) double pi = 3.1415f; // Inicializa implicitamente com 3.1415 std::vector&lt;int&gt; v1(3); // Inicializa v1 com 3 elementos de valor 0 (ambíguo) std::vector&lt;int&gt; v2(3, 2); // Inicializa v2 com 3 elementos de valor 2 (ambíguo) Compare com os exemplos abaixo com inicialização com {}: int a{}; // Inicializa a com valor default (0) int b{42}; // Inicializa b com 42 double c{}; // Inicializa c com valor default (0.0) // int d{7.9}; // ERRO: conversão com estreitamento int d{gsl::narrow_cast&lt;int&gt;(7.9)}; // OK: conversão explícita de double para int double pi{3.1415f}; // OK: conversão implícita sem estreitamento std::vector v1{3}; // Inicializa v1 com um único elemento 3 std::vector v2{3, 2}; // Inicializa v2 com os elementos 3 e 2 Observe que a inicialização com {} proíbe conversões implícitas com estreitamento. A inicialização uniforme nos obriga a usar conversões explícitas sempre que houver a possibilidade de perda de informação. Por um lado, isso deixa o código mais verboso, como no uso do gsl::narrow_cast no exemplo anterior. Por outro lado, deixa evidente a intenção do programador e evita bugs decorrentes de conversões implícitas. Palavra-chave auto A palavra-chave auto permite a dedução automática do tipo de uma variável a partir de sua inicialização. Usaremos auto sempre que possível para evitar repetições redundantes de tipos de dados. Essa é uma recomendação da diretiva ES.11 do C++ Core Guidelines. Alguns exemplos de uso de auto são mostrados a seguir: auto a{42}; // int auto b{7.9f}; // float auto c{1.0 / 3}; // double // Os exemplos a seguir funcionam com qualquer tipo de dado em v std::vector v{3, 2}; auto e{v[0]}; // Cópia de v[0] auto &amp;f{v[0]}; // Referência a v[0]) auto const &amp;g{v[0]}; // Referência apenas de leitura auto *h{&amp;v[0]}; // Ponteiro para v[0] auto it{v.begin()}; // std::vector&lt;int&gt;::iterator // Ponteiro inteligente auto p{std::make_unique&lt;int[]&gt;(1024)}; // std::unique_ptr&lt;int[]&gt; // Expressão lambda auto addTen{[](auto x) { return x + 10; }}; auto x{0U}; // unsigned auto y{addTen(x)}; // unsigned o PowerShell não é suportado! Use apenas o Prompt de Comando.↩︎ Por exemplo, gsl::narrow&lt;T&gt;(3.1415926535) deve funcionar em uma plataforma em que T é um ponto de flutuante de 48 bits (exótico, mas possível), mas falha em um plataforma em que T tem 32 bits.↩︎ "],["intro.html", "2 Introdução", " 2 Introdução Computação gráfica (CG) é o conjunto de métodos e técnicas para a construção, manipulação, armazenagem e exibição de imagens por meio de um computador (ISO 2015). A computação gráfica tem suas origens no desenvolvimento dos primeiros computadores eletrônicos equipados com dispositivos de exibição. A partir do final da década de 1940, o computador experimental Whirlwind I do MIT (Instituto de Tecnologia de Massachusetts) e o sistema SAGE (Semi-Automatic Ground Environment) da Força Aérea dos Estados Unidos, foram os primeiros a utilizar dispositivos de exibição do tipo CRT (cathod-ray tube, ou tubo de raios catódicos) para exibir gráficos vetoriais compostos de linhas e pontos. O uso do termo “computação gráfica” é um pouco mais recente. William Fetter, projetista gráfico da Boeing, utilizou o termo pela primeira vez em 1960 por sugestão de seu supervisor Verne L. Hudson, para descrever seu trabalho. Fetter utilizava gráficos tridimensionais no computador para criar um modelo estilizado de corpo humano que ficou conhecido como “Boeing Man” (figura 2.1). O modelo, composto de curvas e segmentos, era utilizado em simulações de ergonomia do piloto na cabine do avião. Figura 2.1: “Boeing Man” desenhado por William Fetter em um IBM 7094 (fonte). O acrônimo CGI (Computer-Generated Imagery) é frequentemente utilizado para se referir à geração de imagens e efeitos visuais em computador com aplicações em arte, entretenimento, simulação e visualização científica. Uma forma de CGI bastante conhecida e que chama a atenção por suas imagens bonitas é a síntese de imagens fotorrealistas. Um exemplo de imagem fotorrealista gerada em computador é mostrado na figura 2.2. A imagem é uma cena de arquitetura interior produzida com o Cycles Render Engine. Figura 2.2: Scandinavian Interior, por Arnaud Imobersteg (fonte). Atualmente, uma imagem como a da figura 2.2 pode ser gerada em qualquer computador pessoal que tenha sido fabricado nos últimos 10 anos. A imagem foi gerada com o software Blender, gratuito e de código aberto, e que tem o Cycles Render Engine como um de seus renderizadores. Entretanto, existe uma máxima em computação gráfica – a chamada 1ª lei de Peddie – que diz: “Em computação gráfica, demais nunca é o suficiente.” — Jon Peddie De fato, mesmo com toda a evolução do hardware gráfico e das técnicas de CG, ainda não é possível gerar em tempo real imagens com o nível de qualidade obtido por renderizadores como o Cycles. Eventualmente, esse dia chegará. Porém, quando isso acontecer, o nível de exigência dos usuários e desenvolvedores será igualmente maior. Desejaremos imagens ainda mais detalhadas, com maior resolução, mais realistas, mais interativas, com mais efeitos cinemáticos, etc. Enfim, demais nunca é o suficiente. Em computação gráfica, é necessário um cuidadoso compromisso entre a qualidade das imagens geradas e a eficiência com que essas imagens podem ser sintetizadas em um dado sistema computacional. Isso é particularmente importante quando as imagens precisam ser geradas em tempo real. Em jogos digitais, é comum que imagens de alta resolução tenham de ser geradas a uma taxa de, no mínimo, 30 quadros por segundo4. Mesmo os jogos que não visam o fotorrealismo exigem imagens em um nível de qualidade que só pode ser alcançado com o uso de técnicas avançadas de sombreamento e iluminação. Essas técnicas visam produzir resultados que, ainda que não sejam necessariamente acurados do ponto de vista físico, sejam suficientemente convincentes para um público cada vez mais exigente. No decorrer do quadrimestre veremos que a evolução das técnicas e ferramentas de computação gráfica em tempo real é impulsionada pela busca da melhor qualidade de imagem que pode ser obtida de forma eficiente no hardware gráfico disponível no momento. Como resultado, é comum que os métodos adotem simplificações inusitadas, mas ao mesmo tempo muito efetivas, e explorem diferentes aspectos da percepção visual humana para criar uma ilusão de realismo que seja suficiente para chegar ao resultado desejado. Referências "],["áreas-correlatas.html", "2.1 Áreas correlatas", " 2.1 Áreas correlatas A computação gráfica se relaciona, e em certa medida se sobrepõe, a diferentes campos de atuação da ciência da computação. Uma breve introdução às principais áreas correlatas é dada a seguir: Síntese de imagem: é o que geralmente se entende por computação gráfica. Compreende o processo de rendering (imageamento ou renderização) que consiste em converter especificações de geometria, cor, textura, iluminação, entre outras especificações de características de uma cena, em uma imagem exibida em um display gráfico. A figura 2.3 mostra o resultado da síntese de imagem de uma cena fotorrealista usando técnicas combinadas de traçado de raios e radiosidade. Figura 2.3: Imagem gerada no renderizador POV-Ray, por Gilles Tran (fonte). Visão computacional: compreende o processo de adquirir, processar e interpretar dados visuais para gerar as especificações de uma cena. A partir de uma imagem digital, técnicas de visão computacional podem ser utilizadas para tarefas como a reconstrução dos modelos geométricos vistos na imagem, o particionamento dos pixels em segmentos correspondentes aos diferentes objetos da cena, reconhecimento de texturas, identificação dos atributos da câmera e da iluminação, e extração de outras informações semânticas. A visão computacional com frequência se relaciona com a visão de máquina, que compreende as técnicas e ferramentas voltadas a aplicações de visão em inspeção automática, controle de processos industriais e orientação de robôs. A figura 2.4 mostra um exemplo de aplicação de visão computacional: uma técnica de segmentação semântica utilizando aprendizagem profunda para identificar objetos em uma imagem. Figura 2.4: Segmentação semântica usando o sistema YOLO (fonte). Processamento de imagem: compreende o processo de aplicar filtros e operações sobre uma imagem digital que resultam em uma nova imagem digital. Técnicas de processamento digital de imagem podem ser utilizadas para enfatizar características de uma imagem (por exemplo, ajustar brilho, contraste, nitidez), restaurar imagens que sofreram algum tipo de degradação por ruído, mudar cores e tons, comprimir e quantizar, entre diversas outras operações. O escopo do processamento de imagens frequentemente se intersecta com aquele das técnicas de visão computacional. A figura 2.5 mostra um exemplo de processamento de imagem: a aplicação de filtros de remoção de ruído em uma imagem renderizada pelo método de traçado de raios estocástico. O ruído é inerente ao método de Monte Carlo utilizado nesse tipo de renderização. Figura 2.5: Uso dos filtros de processamento de imagem do Intel Open Image Denoise para remoção de ruído de uma imagem de traçado de raios (fonte). Modelagem geométrica: está relacionada com a criação e processamento de representações matemáticas de formas. Técnicas de modelagem geométrica podem ser utilizadas para criar modelos compostos de curvas e superfícies a partir de aquisição de dados (por exemplo, a partir de uma nuvem de pontos de uma aquisição por scanner 3D), construir e manipular modelos sintéticos através da combinação de primitivas geométricas, converter uma representação geométrica em outra, e realizar operações geométricas e topológicas diversas. A figura 2.6 mostra um exemplo de reconstrução de malha geométrica usando o software MeshLab. O modelo à esquerda é o modelo original. Na reconstrução (à direita), os buracos foram preenchidos e o resultado é uma única malha de triângulos. Figura 2.6: Reconstrução de malha geométrica usando o MeshLab (fonte). Neste curso teremos como foco a síntese de imagens. Em particular, a síntese de imagens em tempo real. Como parte disso, veremos como representar e processar cenários virtuais compostos de objetos tridimensionais animados. Veremos como implementar modelos de iluminação capazes de simular de forma eficiente a iluminação de superfícies, e como gerar imagens digitais do ponto de vista de uma câmera virtual. Faremos isso usando a API gráfica OpenGL de modo a explorar o pipeline de processamento gráfico programável das placas de vídeo atuais. Com isso conseguiremos obter o nível de eficiência necessário para produzir animações e permitir a sensação de interatividade. Na UFABC, os tópicos de visão computacional e processamento de imagens são abordados nas disciplinas “ESZA019-17 Visão Computacional” e “MCZA018-17 Processamento Digital de Imagens”. "],["linha-do-tempo.html", "2.2 Linha do tempo", " 2.2 Linha do tempo Nesta seção acompanharemos um resumo da evolução histórica da computação gráfica. Iniciaremos na década de 1950, com os primeiros computadores eletrônicos de uso geral e o surgimento das primeiras aplicações de computação gráfica, e seguiremos até a década atual com os desenvolvimentos mais recentes das atuais GPUs (Graphics Processing Units). Embora a computação gráfica seja recente, assim como a própria ciência da computação, o desenvolvimento de seus fundamentos é anterior ao século XX e só foi possível devido às contribuições artísticas e matemáticas de diversos pioneiros. Para citar apenas alguns: Euclides de Alexandria (300 a.C.), com sua contribuição no desenvolvimento da geometria; Filippo Brunelleschi (1377–1446), com seus estudos sobre perspectiva; René Descartes (1596–1650), com o desenvolvimento da geometria analítica e os sistemas de coordenadas; Christiaan Huygens (1629–1695) e Isaac Newton (1643–1727) por suas investigações sobre os fenômenos da luz; Leonhard Euler (1707–1783), por sua contribuição na trigonometria e em topologia; James Joseph Sylvester (1814–1897), por suas contribuições na teoria das matrizes e invenção da notação matricial. O uso de gráficos no computador também não teria sido possível sem os esforços que contribuíram para o surgimento dos computadores eletrônicos, e também dos primeiros dispositivos de exibição, como o tubo de raios catódicos no final do século XIX. 1950 Os primeiros computadores eletrônicos com dispositivos de exibição surgem neste período. O computador Whirlwind I, do MIT, originalmente projetado para ser parte de um simulador de vôo, foi um dos primeiros computadores digitais de uso geral com processamento em tempo real. O Whirlwind I era equipado com um CRT vetorial capaz de desenhar linhas e pontos. Charles W. Adams e John T. Gilmore, programadores da equipe de desenvolvimento do Whirlwind, implementaram um programa de avaliação de equações diferenciais para produzir a animação da trajetória de uma bola quicando. Essa simulação pode ser considerada a primeira aplicação de computação gráfica interativa e um precursor do jogo de computador, pois o operador podia controlar, através de um botão, a frequência do quicar na tentativa de fazer a bola acertar uma lacuna na tela simulando um buraco no chão. O sistema de defesa aérea SAGE evoluiu a partir do Whirlwind ao longo da década de 1950. As estações do SAGE contavam com telas CRT que exibiam dados de diferentes radares combinados com informações de referência geográfica. Cada estação era também equipada com uma caneta óptica. Através da caneta óptica, o operador podia apontar e selecionar elementos gráficos diretamente na tela (figura 2.7). Figura 2.7: Operador do SAGE usando uma caneta óptica em um CRT vetorial (fonte). 1960 Nesse período a computação gráfica se desenvolve nos laboratórios de pesquisa de universidades e surgem as primeiras aplicações de CAD (Computer-Aided Design) nas indústrias automotiva e aeroespacial. Na década de 1960 ocorrem importantes desenvolvimentos na área de modelagem geométrica, como o uso de curvas de Bézier e NURBS (Non-Uniform Rational Basis Spline). Em 1960, a Digital Equipment Corporation (DEC) começa a produzir em escala comercial o computador PDP-1, equipado com CRT e caneta óptica. Em 1961, o cientista da computação Steve Russell (MIT) cria o “Spacewar!” (figura 2.8). O jogo ganha popularidade dentro e fora da universidade e vira referência no desenvolvimento de jogos digitais5. Figura 2.8: Estudantes do MIT jogando Spacewar! no DEC PDP-1 (fonte). Em 1963, Ivan Sutherland desenvolve o SketchPad, um sistema de projeto gráfico interativo que permite ao usuário manipular primitivas gráficas vetoriais através de uma caneta óptica e um CRT (Sutherland 1963). A figura 2.9 mostra Sutherland operando o SketchPad no computador TX-2 do MIT. O SketchPad é um marco no uso da interface gráfica do usuário (GUI, acrônimo de Graphical User Interface) e um precursor das aplicações de projeto assistido por computador (CAD). Figura 2.9: Ivan Sutherland operando o SketchPad em 1962 (fonte). Na década de 1960 surgem também os primeiros seminários e grupos de interesse em pesquisa sobre gráficos em computador. Na ACM (Association for Computing Machinery), tradicional sociedade científica e educacional dedicada à computação, é fundado o grupo SICGRAPH (Special Interest Committe on Computer Graphics) para promover seminários de computação gráfica. No final da década, o SICGRAPH muda de nome para SIGGRAPH (Special Interest Group on Computer Graphics and Interactive Techniques). A conferência SIGGRAPH é realizada anualmente e é hoje uma das principais conferências de computação gráfica no mundo. 1970 Durante a década de 1970 são desenvolvidas muitas das técnicas de síntese de imagens em tempo real utilizadas atualmente. Em 1971, o então aluno de doutorado Henri Gouraud, trabalhando com Dave Evans e Ivan Sutherland na Universidade de Utah, desenvolve uma técnica eficiente de melhoramento da percepção visual do sombreamento (shading) de superfícies suaves aproximadas por malhas poligonais (Gouraud 1971). Tal técnica, conhecida como Gouraud shading, consiste em interpolar linearmente os valores de intensidade de luz refletida dos vértices da malha poligonal. O resultado é a suavização da variação da reflexão de luz sem a necessidade de aumentar a resolução da malha geométrica (Figura 2.10). Figura 2.10: Visualização de uma esfera aproximada por triângulos, exibindo o aspecto facetado (esquerda) e suavizado com Gouraud shading (direita). Em 1973, Bui Phong, também na Universidade de Utah, desenvolve o Phong shading como um melhoramento de Gouraud shading para reproduzir com mais fidelidade as reflexões especulares em aproximações de superfícies curvas (Phong 1973). Na figura 2.11 é possível comparar Gouraud shading e Phong shading lado a lado. Phong shading reproduz de forma mais acurada o brilho especular da esfera sem precisar usar uma malha poligonal mais refinada. Figura 2.11: Visualização de uma esfera aproximada por triângulos, com Gouraud shading (esquerda) e Phong shading (direita). Phong também propôs um modelo empírico de iluminação local de pontos sobre superfícies conhecido como modelo de reflexão de Phong. Em 1977, Jim Blinn, aluno da mesma universidade, propôs uma alteração do modelo de reflexão de Phong – o modelo de Blinn–Phong – mais acurado fisicamente e mais eficiente sob certas condições de visualização e iluminação (Blinn 1977). Nas décadas seguintes, o modelo de Blinn–Phong tornaria-se o padrão de indústria para síntese de imagens em tempo real, e ainda é muito utilizado atualmente. Em 1974, Wolfgang Straßer, na Universidade Técnica de Berlim, e Ed Catmull, na Universidade de Utah, desenvolvem ao mesmo tempo, mas de forma independente, uma técnica que viria a ser conhecida como Z-buffering. Tal técnica permite identificar, de forma conceituamente simples e favorável à implementação em hardware, quais partes da geometria 3D estão visíveis de um determinado ponto de vista. Atualmente, essa técnica é largamente utilizada em síntese de imagens e é suportada em todo hardware gráfico. Além de ter contribuído com a técnica de Z-buffering, Catmull também trouxe diversos avanços na área de modelagem geométrica, especialmente em subdivisão de superfícies e representação paramétrica de superfícies bicúbicas (Catmull 1974). Outra importante contribuição de Catmull foi o desenvolvimento da técnica de mapeamento de textura, ubíqua nas aplicações gráficas atuais e que permite aumentar a percepção de detalhes de superfícies sem aumentar a complexidade da geometria (figura 2.12). Figura 2.12: Animação do mapeamento de uma textura 2D sobre um modelo poligonal 3D (fonte). Em 1975, o matemático Benoît Mandelbrot, na IBM, desenvolve o conceito de geometria de dimensão fracionária e cria o termo fractal (Albers and Alexanderson 2008). Desde então, fractais começam a ser explorados em síntese de imagens e modelagem geométrica para representar os mais diversos padrões e fenômenos naturais tais como contornos de mapas, relevo de terrenos, nuvens, texturas e plantas. Vol Libre “Vol Libre”, de Loren Carpenter, foi o primeiro filme criado com fractais. O vídeo, de apenas dois minutos, foi apresentado pela primeira vez na conferência SIGGRAPH ’80 após uma palestra técnica de Carpenter sobre a renderização de curvas e superfícies fractais: De acordo com o livro “Droidmaker: George Lucas And the Digital Revolution” (Rubin 2005), ao final da exibição do vídeo, Ed Catmull e Alvy Smith, da Lucasfilm, abordaram Carpenter e ofereceram a ele um emprego na divisão de computação da empresa. Carpenter aceitou imediatamente. Após a carreira na Lucasfilm, Carpenter ainda seria co-fundador da Pixar (junto com Catmull, Smith e outros) e cientista-chefe do estúdio de animação. Em 1976, Steve Jobs, Steve Wozniak e Ronald Wayne fundam a Apple Computer (atualmente Apple Inc.). Em 1979, Steve Jobs entra em contato com as pesquisas de desenvolvimento de interface gráfica na Xerox PARC (atualmente PARC), divisão de pesquisa da Xerox em Palo Alto, Califórnia. Na PARC, Jobs conhece o Xerox Alto, o primeiro computador com uma interface gráfica baseada na metáfora do desktop e no uso do mouse (figura 2.13). Figura 2.13: Xerox Alto (fonte). O Xerox Alto foi o resultado de desenvolvimentos iniciados por Douglas Engelbart e Dustin Lindberg no Standard Research Institute, atual SRI International, por sua vez inspirados no SketchPad de Sutherland. Alguns anos depois, a Apple implementaria os conceitos do Xerox Alto nos computadores Apple Lisa e Macintosh, iniciando uma revolução no uso da interface gráfica nos computadores pessoais (PCs). Em 1977, surge a primeira tentativa de padronização de especificação de comandos em sistemas gráficos: o Core Graphics System (ou simplesmente Core), proposto pelo Graphic Standards Planning Committee (GSPC) da ACM SIGGRAPH (Chappell and Bono 1978). Em 1978, Jim Blinn desenvolve uma técnica de mapeamento de textura para simulação de vincos e rugosidades em superfícies: o bump mapping (Blinn 1978). Uma forma de bump mapping muito utilizada atualmente é o normal mapping. A técnica pode ser muito efetiva para manter a ilusão de uma superfície detalhada, mesmo quando a geometria utilizada é muito simples. A figura 2.14 mostra um exemplo dessa simplificação. Ao longo do quadrimestre implementaremos esta e outras técnicas de texturização. Figura 2.14: Uso de normal mapping para simular a renderização de um modelo de quatro milhões de triângulos usando apenas dois triângulos (fonte). No final da década, J. Turner Whitted desenvolve a técnica de traçado de raios (Whitted 1979). O traçado de raios consegue simular com mais precisão, e de forma conceitualmente simples, efeitos ópticos de reflexão, refração, espalhamento e dispersão da luz. Como resultado, consegue gerar imagens mais fotorrealistas, ainda que sob um custo computacional muito elevado quando comparado com a renderização baseada na rasterização, que consiste na varredura e preenchimento de primitivas geométricas projetadas. Figura 2.15: Esferas e tabuleiro de xadrez: uma das primeiras imagens geradas com traçado de raios, por Turner Whitted. 1980 Essa é a década em que a computação gráfica marca sua presença definitiva na indústria de cinema. O uso de cenas de computação gráfica é popularizado a partir de filmes como “Star Trek II: The Wrath of Khan” (1982), “Tron” (1982) e “Young Sherlock Holmes (1985), como resultado dos avanços das técnicas de síntese de imagem e modelagem geométrica da década anterior, combinado com o avanço da capacidade de processamento dos computadores. Durante essa década ocorrem também importantes avanços nas técnicas de síntese de imagens. Em 1984, Robert Cook, Thomas Porter e Loren Carpenter desenvolvem o traçado de raios distribuído (distributed ray tracing), o qual permite reproduzir efeitos de sombras suaves, entre outros efeitos não contemplados pelo método original de Whitted (Cook, Porter, and Carpenter 1984). A figura 2.16 mostra um exemplo de renderização da cena de teste “Cornell box” usando essa técnica. A imagem tende a ser granulada como resultado da natureza estocástica do algoritmo. Figura 2.16: Imagem gerada com traçado de raios distribuído/estocástico. Ainda em 1984, Donald Greenberg, Michael Cohen e Kenneth Torrance propõem a técnica de radiosidade (Greenberg, Cohen, and Torrance 1986) baseada no uso do método de elementos finitos para simular interreflexões de luz entre superfícies idealmente difusas. A solução da radiosidade de uma cena pode ser pré-processada e não depende da posição da câmera. Isso permite a visualização da cena em tempo real, desde que a posição dos objetos e fontes de luz mantenha-se estática. A figura 2.17 mostra um exemplo de cena renderizada com radiosidade usando o software RRV (Radiosity Renderer and Visualizer). O método de radiosidade pode ser combinado com traçado de raios para gerar imagens com melhor fidelidade de simulação de reflexão difusa e especular. Figura 2.17: Imagem gerada com radiosidade (fonte). Em 1985, o GKS (Graphical Kernel System), desenvolvido como um melhoramento da API Core, torna-se a API padrão ISO para gráficos independentes do dispositivo (ISO 1985). Através do GKS, o código de descrição de comandos para manipulação de gráficos 2D permite a portabilidade entre diferentes linguagens de programação, sistemas operacionais e hardware gráfico compatível. Entretanto, gráficos 3D ainda não são contemplados nesta API. Em 1986, Steve Jobs adquire a divisão de computação gráfica da Lucasfilm e funda a Pixar junto com Ed Catmull, Alvy Smith e outros. Nessa época, Catmull, Loren Carpenter e Robert Cook desenvolvem o sistema de renderização RenderMan, muito utilizado na produção de efeitos visuais em filmes e animações. Após 14 anos, Catmull, Carpenter e Cook receberiam da Academia de Artes e Ciências Cinematográficas a estatueta do Oscar na categoria “Academy Scientific and Technical Awards” pelas contribuições à indústria do cinema representadas pelo desenvolvimento do RenderMan. O sucesso do RenderMan deve-se em parte à sua elegante API – a RenderMan Interface (RISpec) – inspirada na linguagem PostScript. A API permite a descrição completa de cenas 3D com todos os componentes necessários à renderização. Isso garante resultados consistentes, independentes do software de modelagem utilizado. O conceito de shaders, amplamente utilizado em hardware gráfico atual, surge do RenderMan shading language, desenvolvido na década de 1990 e incorporado no RISpec em 2005 como uma linguagem – dessa vez inspirada na linguagem C – de especificação de propriedades de superfícies, fontes de luz e efeitos atmosféricos de cena. Em 1988 é organizado o 1º Simpósio Brasileiro de Computação Gráfica e Processamento de Imagens (SIBGRAPI), em Petrópolis, RJ. O evento, organizado anualmente pela CEGRAPI/SBC, internacionalizou-se e atualmente é chamado de Conference on Graphics, Patterns and Images. Neste ano, o SIBGRAPI será realizado em Natal (RN), de 24 a 27 de outubro. 1990 1990 é a década das APIs gráficas 3D e da popularização do hardware gráfico nos PCs. Empresas como a Sun Microsystems (adquirida pela Oracle em 2010), IBM, HP (Hewlett-Packard), e as agora extintas NeXT, SGI (Silicon Graphics, Inc.) e DEC, desenvolvem estações gráficas de alto desempenho equipadas com hardware capaz de acelerar operações de renderização baseadas em rasterização com suporte a Z-buffer, mapeamento de texturas, iluminação e sombreamento de superfícies (figura 2.18). Figura 2.18: Workstation SGI IRIS Indigo (fonte). Neste período surgem as primeiras APIs para gráficos 3D como tentativa de padronizar a interface de programação entre as diferentes arquiteturas de hardware. Uma dessas APIs, desenvolvida ao longo da década de 1980 e que se estabelece como padrão da indústria na década de 1990, é o PHIGS (Programmer’s Hierarchical Interactive Graphics System) (Shuey 1987). PHIGS utiliza o conceito de grafo de cena: uma estrutura de dados hierárquica que representa as relações entre os modelos geométricos e outras entidades de uma cena. A API trabalha com malhas poligonais e síntese de imagens baseada na rasterização (em oposição ao traçado de raios), prevê o suporte a Gouraud e Phong shading, mas não oferece suporte a mapeamento de texturas. Em oposição ao PHIGS, a SGI utiliza em suas estações gráficas IRIS a API proprietária IRIS GL (Integrated Raster Imaging System Graphics Library) com características semelhantes ao PHIGS, porém com suporte a mapeamento de texturas (McLendon 1992). Diferentemente do PHIGS, o IRIS GL não adota o conceito de grafo de cena. As primitivas gráficas são enviadas imediatamente ao hardware gráfico em um pipeline de transformação geométrica e visualização. Esse modo de enviar os dados, conhecido como immediate mode, acaba por revelar-se mais apropriado para implemetação em hardware do que o retained mode do PHIGS com seu grafo de cena. Em 1991, Mark Segal e Kurt Akeley, da SGI, iniciam o desenvolvimento de uma versão aberta do IRIS GL como tentativa de criar um novo padrão de indústria. Para isso, removem o código proprietário e modificam a API de modo a torná-la independente do sistema de janelas e de dispositivos de entrada. Deste desenvolvimento surge, em 1992, o OpenGL (Open Graphics Library) (Woo et al. 1999), que rapidamente ocupa o lugar do PHIGS como API padrão para gráficos 3D. Desde então, revisões periódicas do OpenGL são feitas de modo a suportar os aprimoramentos mais recentes do hardware gráfico. O aspecto minimalista e de facilidade de uso do IRIS GL continuam presentes no OpenGL. Essas características fizeram – e ainda fazem – do OpenGL uma das APIs gráficas 3D mais populares em aplicações multiplataforma. InfiniteReality No início da década de 1990, as estações gráficas de alto desempenho suportavam apenas um número reduzido de características do OpenGL, sendo o restante simulado em software. O sistema RealityEngine (Akeley 1993), lançado em 1992 pela SGI, foi o primeiro hardware gráfico capaz de oferecer suporte para todas as etapas de transformação e iluminação da versão 1.0 do OpenGL, incluindo o mapeamento de texturas 2D com mipmapping (uma técnica de pré-filtragem de texturas) e antialiasing (suavização de serrilhado). A arquitetura foi sucedida em 1996 pelo InfiniteReality (Montrym et al. 1997), desenvolvido especificamente para o OpenGL. Dependendo da configuração final, o custo de uma estação gráfica baseada no InfiniteReality poderia ser superior a 1 milhão de dólares. Uma demonstração da SGI sobre as capacidades de renderização em tempo real do InfiniteReality em 1996 pode ser vista no vídeo de YouTube “Silicon Graphics - Onyx Infinite Reallity 50FPS”. O sistema InfiniteReality evoluiu até o início da década de 2000. A figura 2.19 mostra um supercomputador equipado com o InfiniteReality 4. Figura 2.19: SGI Onyx 300 com InfinityReality 4, de 2002 (fonte). A partir de 1995, surgem nos PCs as primeiras placas de vídeo com aceleração de processamento gráfico 3D, também chamadas de aceleradoras gráficas 3D. As primeiras aceleradoras gráficas eram capazes de realizar apenas a varredura de linhas não texturizadas e, em alguns casos, tinham desempenho similar ao código de máquina otimizado na CPU. Por outro lado, logo essas limitações foram vencidas e surgiram placas eficientes e com suporte a mapeamento de textura, impulsionadas pelo emergente mercado de jogos de computador. Enquanto as primeiras estações gráficas da SGI implementavam um pipeline completo de transformação de vértices, ainda que sem suporte à texturização, as aceleradoras gráficas para PCs, produzidas por empresas como Diamond Multimedia, S3 Graphics (extinta em 2003), Trident Microsystems (extinta em 2012), Matrox Graphics e NVIDIA, ofereciam suporte ao mapeamento de texturas, porém sem transformação de geometria ou processamento de iluminação. A 3Dfx Interactive (adquirida em 2000 pela NVIDIA), com a sua série de aceleradoras Voodoo Graphics lançadas a partir de 1996, ampliou enormemente o uso do hardware gráfico em jogos de computador. As placas Voodoo eram capazes de exibir triângulos texturizados com mipmapping e filtragem bilinear (figura 2.20). Entretanto, o hardware ainda dependia da CPU para preparar os triângulos para a rasterização. Os triângulos só poderiam ser processados pelo hardware gráfico se fossem previamente convertidos em trapézios degenerados, alinhados em coordenadas da tela. Figura 2.20: Jogo “Carmageddon II: Carpocalypse Now” (Stainless Games) em uma placa gráfica 3Dfx Voodoo, de 1998 (fonte). Outra limitação das aceleradoras gráficas nesse período era a falta de suporte adequado a uma API padrão de indústria. A arquitetura de tais placas era incompatível com aquela especificada no OpenGL e fazia com que os desenvolvedores precisassem recorrer a APIs proprietárias, como a API Glide da 3Dfx (3Dfx 1997). As placas da 3Dfx foram populares até o final da década quando então o OpenGL e a API Direct3D, da Microsoft, começaram a ser suportados de maneira eficiente pelas placas de concorrentes como a ATI Technologies (adquirida em 2006 pela AMD), Matrox e NVIDIA. Na segunda metade da década, o desenvolvimento das placas gráficas para PCs acompanhou a evolução da API Direct3D. Em 1995, a Microsoft lança o Windows 95 Games SDK, um conjunto de APIs de baixo nível para o desenvolvimento de jogos e aplicações multimídia de alto desempenho no Windows. Em 1996, o Windows 95 Games SDK muda de nome para DirectX e sua segunda e terceira versões são disponibilizadas em junho e setembro desse mesmo ano. Entre as APIs contidas no DirectX, o Direct3D é concebido como uma API para hardware gráfico compatível com o pipeline de processamento do OpenGL. Embora no início o Direct3D fosse criticado por sua arquitetura demasiadamente confusa e mal documentada em comparação com o OpenGL (como relatado por John Carmack, da id Software, em sua carta sobre o OpenGL), eventualmente torna-se a API mais utilizada em jogos uma vez que novas versões começam a ser distribuídas em intervalos menores que aqueles do OpenGL. A revisão do OpenGL dependia do ARB (Architecture Review Board): um consórcio independente formado por representantes de diversas empresas de hardware e software que se reuniam periodicamente para propor e aprovar mudanças na API. O Direct3D, por ser proprietário, respondia melhor ao rápido desenvolvimento das placas gráficas naquele momento e passou a ditar a especificação das futuras aceleradoras gráficas voltadas ao mercado de jogos. Em 1997 é anunciado o DirectX 5 (o DirectX 4 nunca chegou a ser lançado), acompanhando as primeiras placas capazes de renderizar triângulos, tais como a ATI Rage Pro e NVIDIA Riva 128 (figura 2.21). A Riva 128 não alcançava a mesma qualidade de imagem produzida pelas placas da 3Dfx, mas ultrapassava as placas Voodoo em várias medições de desempenho. Ainda assim, a aceleração de processamento de geometria era inexistente e a CPU era responsável por calcular as transformações geométricas e interpolações de atributos de vértices ao longo das arestas para cada triângulo transformado. Figura 2.21: Placa gráfica Diamond com o chip NVIDIA Riva 128, de 1997 (fonte). Em 1998 é lançado o DirectX 6 e surgem as primeiras aceleradoras gráficas capazes de interpolar atributos ao longo de arestas. Nessa geração de hardware gráfico, a CPU ainda era responsável pela transformação e iluminação de cada vértice, mas agora bastava enviar à placa gráfica os atributos de cada vértice em vez de atributos interpolados para cada aresta de cada triângulo. Um ano depois, o DirectX 7 é lançado com suporte para aceleração em hardware de transformação e iluminação (figura 2.22). As primeiras placas compatíveis com DirectX 7 surgiriam no ano seguinte. Figura 2.22: Demonstração do benchmark 3DMark2000 (UL) usando DirectX 7 com transformação de geometria e cálculo de iluminação em hardware. 2000 A década de 2000 presencia o que pode ser considerado uma revolução no uso do hardware gráfico: surgem os primeiros processadores gráficos programáveis (programmable GPUs) capazes de alterar o comportamento do pipeline de renderização sem depender da CPU. Isso torna possível a implementação de diversos novos modelos de reflexão para além do tradicional modelo de Blinn–Phong disponível no pipeline de função fixa (pipeline não programável). Além disso, a capacidade de programar processadores gráficos possibilita a implementação de um incontável número de novos efeitos visuais. As GPUs programáveis tornam-se muito populares em PCs, impulsionadas pelas exigentes demandas do mercado de jogos. Ao mesmo tempo, tornam-se muito flexíveis e poderosas não só para jogos, mas também para processamento de propósito geral. O hardware gráfico programável surge no início de 2001 com o lançamento da GPU NVIDIA GeForce 3 (figura 2.23), inicialmente para o computador Apple Macintosh (Lindholm, Kilgard, and Moreton 2001). Figura 2.23: GPU NVIDIA GeForce (fonte). No início de 2001, durante o evento MacWorld Expo Tokyo, é exibido o curta metragem “Luxo Jr.”, produzido pela Pixar em 1986. Entretanto, desta vez o filme é renderizado em tempo real em um computador equipado com uma GeForce 3. Steve Jobs, então CEO da Apple, observou: “Há 15 anos, o que levava 75 horas para produzir cada segundo de vídeo, está agora sendo renderizado em tempo real na GeForce 3.” — Steve Jobs (Morris 2001) Mais tarde, as potencialidades de uma GPU similar seriam exibidas durante uma demonstração de tecnologia na conferência SIGGRAPH 2001: uma versão interativa do filme “Final Fantasy: The Spirits Within”, de Hironobu Sakaguchi, renderizada em tempo real em uma GPU NVIDIA Quadro DCC (Sakaguchi and Aida 2001). Neste evento, a NVIDIA destacou que o desempenho em operações em ponto flutuante utilizadas para desenhar apenas um quadro do filme era superior ao poder computacional total de um supercomputador Cray (tradicional fabricante de supercomputadores, adquirida em 2019 pela Hewlett Packard Enterprise) naquele momento. Ao longo da década, as GPUs de baixo custo (na faixa de 100 a 250 dólares), produzidas por empresas como NVIDIA e ATI, desbancam as estações gráficas de alto desempenho ainda baseadas em tecnologias da década anterior. As placas gráficas para computadores pessoais ultrapassam rapidamente as capacidades computacionais de sistemas como o RealityEngine da SGI, mas ao mesmo tempo com uma redução de custo superior a 90% em comparação com esses sistemas. De acordo com a Lei de Moore, e observando a diminuição do custo das CPUs nesse período, tais placas deveriam custar muito mais, em torno de 15 mil dólares. Esse avanço expressivo das GPUs é implacável com as fabricantes de estações gráficas. Em 2009, a SGI decreta falência. As APIs Direct3D (em 2006) e OpenGL (em 2009) anunciam a descontinuidade do suporte ao pipeline de função fixa. Com isso, as aplicações migram definitivamente ao uso dos shaders: programas que modificam o comportamento das etapas programáveis do pipeline, como o processamento de geometria e fragmentos (amostras de primitivas rasterizadas). Com o aumento do conjunto de instruções suportadas nas GPUs, percebe-se que é possível usar o hardware gráfico para processamento de propósito geral em tarefas como simulação de dinâmica de fluidos, operações em bancos de dados, modelagem de dinâmica molecular, criptoanálise, entre muitas outras tarefas capazes de se beneficiar de processamento paralelo. O termo GPGPU (General-Purpose Computation on GPUs) é utilizado para se referir a esse uso. Uma das tecnologias pioneiras de GPGPU foi o BrookGPU, desenvolvido na Universidade Stanford em 2004, composta de um compilador e um módulo de tempo de execução compatível com Direct3D e OpenGL (Buck et al. 2004). Até então, o processamento de propósito geral usando GPUs exigia do desenvolvedor conhecimento de APIs gráficas como Direct3D ou OpenGL para a criação de shaders customizados de vértices e pixels em linguagens como HLSL (da Microsoft), Cg (da NVIDIA), ou até mesmo em shader assembly. BrookGPU possibilitou simplificar esse fluxo de trabalho ao oferecer uma extensão de ANSI C – a linguagem Brook – voltada especificamente ao processamento paralelo de fluxos de dados. Em 2007, a NVIDIA lança a plataforma CUDA (Compute Unified Device Architecture), composta por um conjunto de ferramentas/bibliotecas e API de GPGPU para GPUs da NVIDIA. A plataforma é muito popular atualmente, impulsionada pelo crescimento das aplicações em ciência de dados e aprendizado de máquina. Influenciada pelo CUDA, surgem em 2009 outras plataformas como o DirectCompute, da Microsoft (como parte do Direct3D 11), e a especificação aberta OpenCL do Khronos Group, mesmo consórcio de indústrias que mantém o OpenGL. As primeiras oficinas e conferências sobre GPGPU, como a ACM GPGPU e a GPU Technology Conference (GTC), da NVIDIA, surgem neste período. A figura 2.24 mostra um exemplo atual de aplicação de GPGPU para a modelagem de DNA. Figura 2.24: Ligante de sulco menor do DNA, modelado através de GPGPU com o software Abalone. (fonte). 2010 A partir da década de 2010, a aceleração de gráficos 3D se expande e se populariza nos dispositivos móveis. O uso de multitexturização (uso de vários estágios de texturização) e de técnicas como normal mapping, cube mapping (para simulação de superfícies reflexivas) e shadow mapping (para simulação de sombras) torna-se comum em aplicações gráficas interativas. Em 2011, o Khronos Group anuncia o padrão WebGL, ampliando a possibilidade de uso de aceleração de gráficos 3D nos navegadores. Na segunda metade da década, a renderização baseada em física, do inglês Physically Based Rendering (PBR), começa a ser empregada em jogos de computador e em consoles. O jogo Alien: Isolation (Creative Assembly), de 2014, é um dos primeiros a explorar essa tecnologia (figura 2.25). Figura 2.25: Uso de renderização baseada em física no jogo “Alien: Isolation” (Creative Assembly) (fonte). A renderização baseada em física procura simular de forma fisicamente correta a interação da luz com os diferentes materiais de uma cena (Pharr, Jakob, and Humphreys 2016). Até então os algoritmos de iluminação e sombreamento em tempo real eram baseados em modelos empíricos, simplificados e pouco realistas, desenvolvidos para o hardware mais limitado da década anterior. Na renderização baseada em física, os materiais são descritos por informações de detalhes de microsuperfície obtidos por fotogrametria. A figura 2.26 mostra o modelo de uma arma renderizada com PBR e o conjunto de texturas utilizado. Figura 2.26: Arma renderizada com PBR usando o toolkit de renderização Marmoset, e conjunto de texturas utilizadas (fonte). Em 2014, Ian Goodfellow e seus colegas da Universidade de Montreal anunciam as Redes Adversárias Generativas (GANs) (Goodfellow et al. 2014). GANs são arquiteturas de redes neurais que permitem a geração de dados originais a partir do treinamento simultâneo de duas redes que competem entre si: uma rede geradora (por exemplo, treinada para gerar imagens de rostos de pessoas) e uma rede discriminadora (por exemplo, treinada para diferenciar rostos reais de rostos falsos). A rede geradora é otimizada a partir da discriminadora, como em um jogo minimax em que o discriminador tenta maximizar a chance de diferenciar corretamente os dados gerados dos dados reais de treinamento, e o gerador tenta minimizar a chance do discriminador classificar que os dados gerados são falsos. Em 2019, a NVIDIA Research desenvolve o StyleGAN (Karras, Laine, and Aila 2019), uma arquitetura de GAN que combina técnicas de aprendizado profundo e transferência de estilo neural (Gatys, Ecker, and Bethge 2016) para gerar rostos indistinguíveis de imagens reais. A técnica é popularizada com o site This Person Does Not Exist (Essa Pessoa Não Existe) que usa o modelo StyleGan2 para gerar um novo rosto a cada vez que a página é atualizada (figura 2.27). Figura 2.27: Rosto gerado pelo site https://thispersondoesnotexist.com/ usando o modelo StyleGAN2 da NVIDIA. Em 2016 são lançadas novas gerações de headsets de realidade virtual como o Oculus Rift e HTC Vive, que elevam as exigências de hardware gráfico para jogos que utilizam essa tecnologia. Também em 2016, o Khronos Group lança a API Vulkan como uma API de baixo nível ideal para explorar os recursos gráficos e de computação das novas gerações de GPUs. Vulkan dá ao desenvolvedor maior controle para gerenciar tarefas que anteriormente eram feitas exclusivamente pelo driver de vídeo, como a alocação, sincronização e transferência de recursos para a GPU. Vulkan também permite um melhor aproveitamento do processamento concorrente entre a CPU e a GPU. Em 2018 é incorporado ao Direct3D 12 o DirectX Raytracing (DXR), que introduz um novo pipeline gráfico destinado ao traçado de raios em tempo real. Ainda em 2018, as GPUs NVIDIA RTX série 20 são as primeiras a suportar essa tecnologia. Em 2019 a NVIDIA anuncia o Deep Learning Super Sampling (DLSS): um conjunto de tecnologias baseadas em redes neurais de aprendizagem profunda capazes de aumentar em tempo real a resolução dos quadros de exibição de jogos em computadores com GPUs RTX. A partir de uma imagem de baixa resolução, o modelo treinado consegue inferir uma imagem de alta resolução de forma mais eficiente e com mesmo nível de detalhes do que o jogo conseguiria obter caso renderizasse diretamente a imagem em alta resolução. O vídeo de divulgação a a seguir mostra o ganho de desempenho obtido com o uso de DLSS em diversos jogos: 2020 Em 2020, as GPUs NVIDIA RTX série 20 são sucedidas pela série 30, ampliando ainda mais a possibilidade de uso de traçado de raios em tempo real. A AMD lança as GPUs da série Radeon RX 6000, também com suporte a traçado de raios. Além disso, uma API de traçado de raios é incorporada ao Vulkan como o conjunto de extensões Vulkan Ray Tracing. O vídeo a seguir mostra exemplos de renderização com traçado de raios nas GPUs RTX: Ainda estamos no início da década, mas o aumento da capacidade de processamento e largura de banda de memória do hardware gráfico deve continuar a empurrar os limites do que é possível renderizar em tempo real. Efeitos atmosféricos, texturas de altíssima resolução e iluminação global6 em tempo real devem se popularizar nos próximos anos. Um exemplo do estado-da-arte em técnicas de renderização em tempo real usando iluminação global pode ser visto neste vídeo de apresentação do motor de jogo Unreal Engine 5, lançado em abril deste ano: As tecnologias baseadas em aprendizagem profunda também devem continuar trazendos aprimoramentos na qualidade e eficiência em síntese de imagens em tempo real. A NVIDIA tem expandido tecnologias como o NVIDIA Real-Time Denoiser (NRD) para remover o ruído de imagens renderizadas com traçado de raios, o Deep Learning Anti-Aliasing (DLAA) para suavização de serrilhados (anti-aliasing) em resolução nativa, e a tecnologia Deep Learning Dynamic Super Resolution (DLDSR), que renderiza imagens de alta resolução e então reduz para a resolução da tela, obtendo com isso uma imagem de qualidade superior com mesma eficiência da renderização na resolução nativa. Esta também deve ser a década da criação de conteúdo através de modelos generativos. Em 2021, a OpenAI anunciou o DALL-E: um conjunto de modelos neurais baseados em métodos de difusão capazes de gerar imagens a partir de textos descritivos em linguagem natural. A tecnologia vem se desenvolvendo rapidamente. O DALL-E 2, anunciado em abril deste ano, permite criar imagens originais de alta qualidade, variações de imagens existentes em diferentes estilos, além de permitir a extensão de imagens para além de suas bordas originais (outpainting). Também neste ano, o Google Brain anunciou tecnologias semelhantes como o Imagen (Saharia et al. 2022) e o Parti (Yu et al. 2022). Além desses, o laboratório de pesquisa independente Midjourney anunciou, também em 2022, uma ferramenta similar com versão beta disponível ao público através de um bot no Discord. Recentemente, uma imagem produzida no Midjourney (figura 2.28) ganhou a competição de arte digital na 2022 Colorado State Fair, gerando controvérsia entre os artistas. Figura 2.28: “Théâtre d’Opéra Spatial”, assinada por “Jason T. Allen via Midjourney”, vencedora da competição de arte digital da 2002 Colorado State Fair (fonte). O vídeo a seguir destaca os principais recursos do DALL-E 2: DALL-E, Imagen, Parti e Midjourney são tecnologias proprietárias que não disponibilizam o código fonte ou os pesos dos modelos. Entretanto, recentemente começaram a surgir modelos abertos, entre eles o Crayon, também conhecido como Dall-E Mini da Crayon LLC, o Latent Diffusion da Universidade de Heidelberg (Rombach et al. 2022), e o Stable Diffusion da StabilityAI. Demonstrações estão disponíveis online em https://www.craiyon.com/ e na plataforma Hugging Face (Latent Diffusion e Stable Diffusion). O vídeo a seguir, do canal de YouTube Two Minute Papers, apresenta os impressionantes recursos do Stable Diffusion: Por fim, a década de 2020 tem presenciado avanços significativos na área de renderização neural. Renderização neural consiste no uso de tecnologias baseadas em redes neurais para reconstruir modelos 3D a partir de uma coleção de imagens 2D. Uma dessas tecnologias é o neural rendering field, ou NeRF (Mildenhall et al. 2020). NeRFs são modelos de redes neurais completamente conectadas que representam a forma como a luz se propaga dentro de uma cena a partir de uma posição e orientação de visão. NeRFs podem ser usadas para gerar representações implícitas das superfícies da cena, mas também para renderizar imagens a partir de qualquer ponto de vista, com sombreamento e iluminação. Uma técnica estado-da-arte de renderização neural é o Instant NeRF, da NVIDIA Research. Um vídeo de demonstração é exibido a seguir: Referências "],["firstapp.html", "2.3 Primeiro programa", " 2.3 Primeiro programa Nesta seção seguiremos um passo a passo de construção de um primeiro programa com a biblioteca ABCg. Será o nosso “Hello, World!”, similar ao exemplo da ABCg mostrado na seção 1.5, mas sem o triângulo colorido renderizado com OpenGL. Configuração inicial Faça uma cópia (ou fork) do conteúdo de https://github.com/hbatagelo/abcg.git. Desse modo você poderá modificar livremente a biblioteca e armazená-la em seu repositório pessoal. Como a ABCg já tem um projeto de exemplo chamado helloworld, vamos chamar o nosso de firstapp. Em abcg/examples, crie o subdiretório abcg/examples/firstapp. A escolha de deixar o projeto como um subdiretório de abcg/examples é conveniente pois bastará construir a ABCg para que o nosso projeto seja automaticamente construído como um exemplo adicional da biblioteca. Abra o arquivo abcg/examples/CMakeLists.txt e acrescente a linha add_subdirectory(firstapp). O conteúdo ficará assim: add_subdirectory(helloworld) add_subdirectory(firstapp) Dessa forma o CMake incluirá o subdiretório firstapp na busca de um script CMakeLists.txt contendo a configuração do projeto. Crie o arquivo abcg/examples/firstapp/CMakeLists.txt. Edite-o com o seguinte conteúdo: project(firstapp) add_executable(${PROJECT_NAME} main.cpp window.cpp) enable_abcg(${PROJECT_NAME}) O comando project na primeira linha define o nome do projeto. Em seguida, add_executable define que o executável terá o mesmo nome definido em project e será gerado a partir dos fontes main.cpp e window.cpp (não é necessário colocar os arquivos .h ou .hpp). Por fim, a função enable_abcg() configura o projeto para usar a ABCg. Essa função é definida em abcg/cmake/ABCg.cmake, que é um script CMake chamado a partir do CMakeLists.txt do diretório raiz. Em abcg/examples/firstapp, crie os arquivos main.cpp, window.cpp e window.hpp. Vamos editá-los a seguir. main.cpp Em main.cpp definimos o ponto de entrada da aplicação: #include &quot;window.hpp&quot; int main(int argc, char **argv) { // Create application instance abcg::Application app(argc, argv); // Create OpenGL window Window window; window.setWindowSettings({.title = &quot;First App&quot;}); // Run application app.run(window); return 0; } Na primeira linha incluímos o arquivo de cabeçalho que terá a definição de uma classe customizada Window responsável pelo comportamento da janela da aplicação. Faremos com que essa classe seja derivada de abcg::OpenGLWindow para que possamos usar as funções da ABCg de gerenciamento de janelas compatíveis com OpenGL; Na linha 5 criamos um objeto app da classe abcg::Application, responsável pelo gerenciamento da aplicação; Na linha 8 criamos o objeto window que presenta nossa janela customizada; Na linha 9 definimos o título da janela. setWindowSettings é uma função membro de abcg::OpenGLWindow, classe base de Window. A função recebe uma estrutura abcg::WindowSettings contendo as configurações da janela; Na linha 12, a função abcg::Application::run é chamada para inicializar os subsistemas da SDL, inicializar a janela recém-criada e entrar no laço principal da aplicação. A função retornará somente quando a janela de aplicação for fechada. Observação Todas as classes e funções da ABCg fazem parte do namespace abcg. Como vimos no código anterior, abcg::OpenGLWindow é uma classe da ABCg responsável pelo gerenciamento de janelas compatíveis com OpenGL. De modo semelhante, abcg::Application é uma classe da ABCg responsável pelo gerenciamento da aplicação. Em todos os programas que faremos durante a disciplina, começaremos definindo uma classe derivada de abcg::OpenGLWindow, como a classe Window de nossa primeira aplicação. Tal classe derivada será customizada com comandos do OpenGL para que possamos desenhar o conteúdo da janela. Internamente a ABCg usa tratamento de exceções. As exceções são lançadas como objetos da classe abcg::Exception, derivada de std::exception. Vamos alterar um pouco o código anterior para capturar as exceções que possam ocorrer e imprimir no console a mensagem de erro correspondente. O código final de main.cpp ficará assim: #include &quot;window.hpp&quot; int main(int argc, char **argv) { try { // Create application instance abcg::Application app(argc, argv); // Create OpenGL window Window window; window.setWindowSettings({.title = &quot;First App&quot;}); // Run application app.run(window); } catch (std::exception const &amp;exception) { fmt::print(stderr, &quot;{}\\n&quot;, exception.what()); return -1; } return 0; } O código anterior foi colocado dentro do escopo try de um bloco try...catch. No escopo catch, a função fmt::print imprime no erro padrão (stderr) a mensagem de erro associada com a exceção capturada. fmt::print faz parte da biblioteca {fmt}. Ela permite a formatação e impressão de strings usando uma sintaxe parecida com as f-strings da linguagem Python7. window.hpp No arquivo window.hpp definiremos nossa classe Window que será responsável pelo gerenciamento do conteúdo da janela da aplicação: #ifndef WINDOW_HPP_ #define WINDOW_HPP_ #include &quot;abcgOpenGL.hpp&quot; class Window : public abcg::OpenGLWindow {}; #endif Observe novamente que nossa classe Window é derivada de abcg::OpenGLWindow, que faz parte da ABCg. abcg::OpenGLWindow gerencia uma janela capaz de renderizar gráficos com a API OpenGL. A classe possui um conjunto de funções virtuais que podem ser substituídas pela classe derivada de modo a alterar o comportamento da janela. O comportamento padrão consiste em desenhar a janela com fundo preto, com um contador de FPS (Frames Per Second, ou quadros por segundo) sobreposto no canto superior esquerdo da janela, e um botão no canto inferior esquerdo para alternar entre tela cheia e modo janela (com atalho pela tecla F11). O contador e o botão são gerenciados pela biblioteca Dear ImGui (no restante do texto vamos chamá-la apenas de ImGui). Por enquanto nossa classe não faz nada de especial. Ela só deriva de abcg::OpenGLWindow e não define nenhuma função ou variável membro. Mesmo assim, já podemos construir a aplicação. Experimente fazer isso. Na linha de comando, use o script build.sh (Linux/macOS) ou build.bat (Windows). Se você estiver no Visual Studio Code, abra a pasta abcg pelo editor, use a opção de configuração do CMake e então construa o projeto (F7). O executável será gerado em abcg/build/bin/firstapp. Da forma como está, a aplicação mostrará uma janela com fundo preto e os dois controles de GUI (widgets) mencionados anteriomente. Isso acontece porque Window não substitui nenhuma das funções virtuais de abcg::OpenGLWindow. Todo o comportamento está sendo definido pela classe base: Vamos alterar o conteúdo e o comportamento da nossa janela Window. Imitaremos o comportamento do projeto helloworld que cria uma pequena subjanela da ImGui. Modifique window.hpp para o código a seguir: #ifndef WINDOW_HPP_ #define WINDOW_HPP_ #include &quot;abcgOpenGL.hpp&quot; class Window : public abcg::OpenGLWindow { protected: void onCreate() override; void onPaint() override; void onPaintUI() override; private: std::array&lt;float, 4&gt; m_clearColor{0.906f, 0.910f, 0.918f, 1.0f}; }; #endif onCreate, onPaint e onPaintUI substituem funções virtuais de abcg::OpenGLWindow. A palavra-chave override é opcional, mas é recomendável pois deixa explícito que as funções são substituições das funções virtuais da classe base: onCreate é onde colocaremos os comandos de inicialização do estado da janela e do OpenGL. Internamente a ABCg chama essa função apenas uma vez no início do programa, após ter inicializado os subsistemas da SDL e o OpenGL. onPaint é onde colocaremos todas as funções de desenho do OpenGL. Internamente a ABCg chama essa função continuamente no laço principal da aplicação, uma vez para cada quadro (frame) de exibição. Por exemplo, na imagem acima, onPaint estava sendo chamada a uma média de 3988,7 vezes por segundo; onPaintUI é onde colocaremos todas as funções de desenho de widgets da ImGui (botões, menus, caixas de seleção, etc). Internamente, onPaintUI é chamado logo depois que onPaint é chamado; m_clearColor é um arranjo de quatro valores float entre 0 e 1. Esses valores definem a cor RGBA de fundo da janela, que neste caso é um cinza claro. Observação Poderíamos ter definido m_clearColor da seguinte forma, mais familiar aos programadores em C: float m_clearColor[4] = {0.906f, 0.910f, 0.918f, 1.0f}; Entretanto, em C++ o std::array é a forma recomendada e mais segura de trabalhar com arranjos. window.cpp Em window.cpp, definiremos as funções virtuais substituídas: #include &quot;window.hpp&quot; void Window::onCreate() { auto const &amp;windowSettings{getWindowSettings()}; fmt::print(&quot;Initial window size: {}x{}\\n&quot;, windowSettings.width, windowSettings.height); } void Window::onPaint() { // Set the clear color abcg::glClearColor(m_clearColor.at(0), m_clearColor.at(1), m_clearColor.at(2), m_clearColor.at(3)); // Clear the color buffer abcg::glClear(GL_COLOR_BUFFER_BIT); } void Window::onPaintUI() { // Parent class will show fullscreen button and FPS meter abcg::OpenGLWindow::onPaintUI(); // Our own ImGui widgets go below { // Window begin ImGui::Begin(&quot;Hello, First App!&quot;); // Static text auto const &amp;windowSettings{getWindowSettings()}; ImGui::Text(&quot;Current window size: %dx%d (in windowed mode)&quot;, windowSettings.width, windowSettings.height); // Slider from 0.0f to 1.0f static float f{}; ImGui::SliderFloat(&quot;float&quot;, &amp;f, 0.0f, 1.0f); // ColorEdit to change the clear color ImGui::ColorEdit3(&quot;clear color&quot;, m_clearColor.data()); // More static text ImGui::Text(&quot;Application average %.3f ms/frame (%.1f FPS)&quot;, 1000.0 / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate); // Window end ImGui::End(); } } Vejamos com mais atenção o trecho com a definição de Window::onCreate: void Window::onCreate() { auto const &amp;windowSettings{getWindowSettings()}; fmt::print(&quot;Initial window size: {}x{}\\n&quot;, windowSettings.width, windowSettings.height); } Na linha 4, windowSettings é uma estrutura abcg::WindowSettings retornada por abcg::OpenGLWindow::getWindowSettings() com as configurações da janela. Na linha 5, fmt::print imprime no console o tamanho da janela8. Observe agora o trecho com a definição de Window::onPaint: void Window::onPaint() { // Set the clear color abcg::glClearColor(m_clearColor.at(0), m_clearColor.at(1), m_clearColor.at(2), m_clearColor.at(3)); // Clear the color buffer abcg::glClear(GL_COLOR_BUFFER_BIT); } Aqui são chamadas duas funções do OpenGL: glClearColor e glClear. glClearColor é utilizada para determinar a cor que será usada para limpar a janela9. A função recebe quatro parâmetros do tipo float (red, green, blue, alpha), que correspondem às componentes de cor RGB e um valor adicional de opacidade (alpha). Esse formato de cor é chamado de RGBA. Os valores são fixados (clamped) no intervalo \\([0,1]\\) em ponto flutuante. glClear, usando como argumento a constante GL_COLOR_BUFFER_BIT, limpa a janela com a cor especificada na última chamada de glClearColor. Em resumo, nosso onPaint limpa a tela com a cor RGBA especificada em m_clearColor. Importante As funções do OpenGL são prefixadas com as letras gl; As constantes do OpenGL são prefixadas com GL_. Neste curso usaremos as funções do OpenGL que são comuns ao OpenGL ES 3.0 de modo a manter compatibilidade com o WebGL 2.0. Assim conseguiremos fazer aplicações que podem ser executadas tanto no desktop quanto no navegador usando o mesmo código fonte. A versão mais recente do OpenGL é a 4.6. A documentação de cada versão está disponível em https://registry.khronos.org/OpenGL/index_gl.php. Observação Na ABCg, podemos prefixar as funções gl com o namespace abcg de modo a rastrear erros do OpenGL com o sistema de tratamento de exceções da ABCg. Por exemplo, ao escrevermos abcg::glClear no lugar de glClear, estamos na verdade chamando uma função wrapper que verifica automaticamente se a chamada da função OpenGL é válida. Se algum erro ocorrer, uma exceção será lançada e capturada pelo catch que implementamos na função main. A mensagem de erro (retornada por exception.what() no escopo do catch) inclui a descrição do erro, o nome do arquivo, o nome da função e o número da linha do código onde o erro foi detectado. Isso pode ser bastante útil para a depuração de erros do OpenGL. Sempre que possível, prefixe as funções do OpenGL com abcg::. A verificação automática de erros do OpenGL é habilitada somente quando a aplicação é compilada no modo Debug. Não há sobrecarga nas chamadas das funções do OpenGL com o namespace abcg quando a aplicação é compilada em modo Release. Agora vamos à definição de Window::onPaintUI, responsável pelo desenho da interface usando a ImGui: void Window::onPaintUI() { // Parent class will show fullscreen button and FPS meter abcg::OpenGLWindow::onPaintUI(); // Our own ImGui widgets go below { // Window begin ImGui::Begin(&quot;Hello, First App!&quot;); // Static text auto const &amp;windowSettings{getWindowSettings()}; ImGui::Text(&quot;Current window size: %dx%d (in windowed mode)&quot;, windowSettings.width, windowSettings.height); // Slider from 0.0f to 1.0f static float f{}; ImGui::SliderFloat(&quot;float&quot;, &amp;f, 0.0f, 1.0f); // ColorEdit to change the clear color ImGui::ColorEdit3(&quot;clear color&quot;, m_clearColor.data()); // More static text ImGui::Text(&quot;Application average %.3f ms/frame (%.1f FPS)&quot;, 1000.0 / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate); // Window end ImGui::End(); } } Na linha 19 é chamada a função membro onPaintUI da classe base, que mostra o medidor de FPS e o botão para alternar entre o modo janela e tela cheia. Na linha 24 é criada uma janela da ImGui com o título “Hello, First App!”. A partir desta linha, até a linha 43, todas as chamadas a funções da ImGui criam widgets dentro dessa janela recém-criada. Apenas para isso ficar mais explícito, todo o código que corresponde a esta janela está dentro do escopo delimitado pelas chaves nas linhas 22 e 44. Na linha 27 é criado um texto estático que mostra o tamanho atual da janela. Na linha 32 é criado um slider horizontal que pode variar de 0 a 1 em ponto flutuante. O valor do slider é armazenado em f. A variável f é declarada como static para que seu estado seja retido entre as chamadas de onPaintUI (outra opção é declarar a variável como membro da classe). Na linha 36 é criado um widget de edição de cor para alterar os valores de m_clearColor. Na linha 39 é criado mais um texto estático com informações de FPS extraídas de ImGui::GetIO().Framerate. Esse código é praticamente o mesmo do “Hello, World!”. Construa a aplicação para ver o resultado: Exercício A seguir temos alguns exemplos de uso de outros widgets da ImGui. Experimente incluir esses trechos de código em onPaintUI: Botões: // 100x50 button if (ImGui::Button(&quot;Press me!&quot;, ImVec2(100, 50))) { fmt::print(&quot;1st button pressed.\\n&quot;); } // Nx50 button, where N is the remaining width available ImGui::Button(&quot;Press me!&quot;, ImVec2(-1, 50)); // See also IsItemHovered, IsItemActive, etc if (ImGui::IsItemClicked()) { fmt::print(&quot;2nd Button pressed.\\n&quot;); } Checkbox: static bool enabled{true}; ImGui::Checkbox(&quot;Some option&quot;, &amp;enabled); fmt::print(&quot;The checkbox is {}\\n&quot;, enabled ? &quot;enabled&quot; : &quot;disabled&quot;); Combo box: static std::size_t currentIndex{}; std::vector comboItems{&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;}; if (ImGui::BeginCombo(&quot;Combo box&quot;, comboItems.at(currentIndex))) { for (auto index{0U}; index &lt; comboItems.size(); ++index) { bool const isSelected{currentIndex == index}; if (ImGui::Selectable(comboItems.at(index), isSelected)) currentIndex = index; // Set the initial focus when opening the combo (scrolling + keyboard // navigation focus) if (isSelected) ImGui::SetItemDefaultFocus(); } ImGui::EndCombo(); } fmt::print(&quot;Selected combo box item: {}\\n&quot;, comboItems.at(currentIndex)); Menu (em uma janela de tamanho fixo e com o flag adicional ImGuiWindowFlags_MenuBar para permitir o uso da barra de menu): ImGui::SetNextWindowSize(ImVec2(300, 100)); auto flags{ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoResize}; ImGui::Begin(&quot;Window with menu&quot;, nullptr, flags); { bool save{}; static bool showCompliment{}; // Hold state // Menu Bar if (ImGui::BeginMenuBar()) { // File menu if (ImGui::BeginMenu(&quot;File&quot;)) { ImGui::MenuItem(&quot;Save&quot;, nullptr, &amp;save); ImGui::EndMenu(); } // View menu if (ImGui::BeginMenu(&quot;View&quot;)) { ImGui::MenuItem(&quot;Show Compliment&quot;, nullptr, &amp;showCompliment); ImGui::EndMenu(); } ImGui::EndMenuBar(); } if (save) { // Save file... } if (showCompliment) { ImGui::Text(&quot;You&#39;re a beautiful person.&quot;); } } ImGui::End(); Mais sliders: static std::array pos2d{0.0f, 0.0f}; ImGui::SliderFloat2(&quot;2D position&quot;, pos2d.data(), 0.0, 50.0); static std::array pos3d{0.0f, 0.0f, 0.0f}; ImGui::SliderFloat3(&quot;3D position&quot;, pos3d.data(), -1.0, 1.0); Dica A ImGui não tem um manual com exemplos de uso de todos os widgets suportados. A melhor referência atualmente é o código da função ImGui::ShowDemoWindow em abcg/external/imgui/imgui_demo.cpp. Essa função cria uma janela de demonstração contendo uma grande variedade de exemplos de uso de widgets e recursos da ImGui. No exemplo “Hello, World!”, tal janela é exibida quando a caixa de seleção “Show demo window” está ativada. Por exemplo, caso você queira implementar um “List Box” como exibido na janela de demonstração abaixo, procure pela string “List boxes” ou “listbox 1” em abcg/external/imgui/imgui_demo.cpp, copie o código correspondente e adapte-o em sua aplicação. O código correspondente em imgui_demo.cpp é o seguinte: const char* items[] = { &quot;AAAA&quot;, &quot;BBBB&quot;, &quot;CCCC&quot;, &quot;DDDD&quot;, &quot;EEEE&quot;, &quot;FFFF&quot;, &quot;GGGG&quot;, &quot;HHHH&quot;, &quot;IIII&quot;, &quot;JJJJ&quot;, &quot;KKKK&quot;, &quot;LLLLLLL&quot;, &quot;MMMM&quot;, &quot;OOOOOOO&quot; }; static int item_current_idx = 0; // Here we store our selection data as an index. if (ImGui::BeginListBox(&quot;listbox 1&quot;)) { for (int n = 0; n &lt; IM_ARRAYSIZE(items); n++) { const bool is_selected = (item_current_idx == n); if (ImGui::Selectable(items[n], is_selected)) item_current_idx = n; // Set the initial focus when opening the combo (scrolling + keyboard navigation focus) if (is_selected) ImGui::SetItemDefaultFocus(); } ImGui::EndListBox(); } A documentação das funções, constantes e enumerações está no formato de comentários nos arquivos abcg/external/imgui/imgui.h e abcg/external/imgui/imgui.cpp. Observação A ImGui é uma biblioteca de GUI que trabalha em modo imediato (o “Im” de ImGui vem de immediate mode), isto é, os controles de UI não retém estado entre os quadros de exibição. Sempre que a função onPaintUI é chamada, a GUI é redesenhada por completo. O gerenciamento de estado deve ser feito pelo usuário, por exemplo, através de variáveis estáticas (como a variável f da linha 32 de window.cpp para guardar o valor do slider) ou variáveis membros da classe (como a variável m_clearColor da classe Window)10. Compilando para WebAssembly Para compilar nossa aplicação para WebAssembly basta usar o script build-wasm.sh (Linux/macOS) ou build-wasm.bat (Windows). Apenas certifique-se de habilitar antes as variáveis de ambiente do SDK do Emscripten como fizemos na seção 1.5. Após a construção do projeto, os arquivos resultantes (firstapp.js e firstapp.wasm) serão gravados no subdiretório public. Para usá-los vamos precisar de um arquivo HTML. Faça uma cópia de um dos arquivos HTML já existentes em public (helloworld.html, full_window.html ou full_window_console.html). Mude o nome do arquivo para firstapp.html. No final do arquivo, mude a string src=\"helloworld.js\" para src=\"firstapp.js\", assim: &lt;script async type=&quot;text/javascript&quot; src=&quot;firstapp.js&quot;&gt;&lt;/script&gt; Para testar, monte o servidor local com runweb.sh ou runweb.bat e abra o arquivo HTML em http://localhost:8080/. Dica Disponibilize o conteúdo web de seus projetos no GitHub Pages para formar um portfólio de atividades feitas no curso: Na sua conta do GitHub, crie um repositório com visibilidade pública. Pode ser seu próprio fork da ABCg. No diretório raiz, crie um subdiretório firstapp com os arquivos firstapp.*, mas renomeie firstapp.html para index.html; Nas configurações do repositório no GitHub, habilite o GitHub Pages informando o branch que será utilizado (por exemplo, main). O conteúdo estará disponível em https://username.github.io/reponame/firstapp/ onde username e reponame são respectivamente seu nome de usuário e o nome do repositório. Ao longo do quadrimestre, suba seus projetos nesse repositório. No diretório raiz você pode criar um index.html com a descrição do portfólio e o link para cada página de projeto. Um subconjunto da {fmt} foi incorporado à biblioteca de formatação de texto no C++20. O suporte equivalente ao fmt::print (impressão formatada com saída padrão) está disponível no C++23 através de std::print, mas ainda não é suportado nas principais implementações da biblioteca padrão.↩︎ O tamanho padrão para uma aplicação desktop é 800x600. Na versão para web, a janela pode ser redimensionada de acordo com a regra CSS do elemento canvas do HTML5.↩︎ Mais precisamente, glClearColor define a cor que será utilizada para limpar os buffers de cor do framebuffer. Veremos mais sobre o conceito de framebuffer nos próximos capítulos.↩︎ A ImGui pode reter algum estado dos controles de UI entre os frames. Por exemplo, em uma janela com vários botões, a ImGui guarda internamente qual botão está com o foco atual. Em um widget do tipo árvore, ela guarda a informação de quais nós estão expandidos e quais estão colapsados.↩︎ "],["tictactoe.html", "2.4 Jogo da Velha", " 2.4 Jogo da Velha Usando o projeto firstapp como base, faremos nesta seção um “Jogo da Velha” com interface composta apenas de widgets da ImGui. Com isso ficaremos mais familiarizados com a ImGui e entraremos em contato com novas funções da biblioteca, tais como: ImGui::BeginTable e ImGui::EndTable para fazer tabelas; ImGui::Spacing para adicionar espaçamentos verticais; ImGui::PushFont e ImGui::PopFont para usar novas fontes. A ideia principal é simular o tabuleiro do jogo com um arranjo de 3x3 botões: O jogo começará com os botões vazios, sem texto. Cada vez que um botão for pressionado, seu texto será substituído por um X ou O de acordo com o turno do jogador. Para simplificar não jogaremos contra o computador: o jogo só funcionará no modo “humano versus humano”; Internamente manteremos um arranjo contendo o estado do jogo para determinar se houve um vencedor ou se “deu velha” (empate); Usaremos um widget de texto estático para mostrar o turno atual e o resultado do jogo; Incluiremos também um botão e uma opção de menu para reiniciar o jogo. O resultado ficará como a seguir: Configuração inicial Nosso projeto será chamado tictactoe. Em abcg/examples, crie o subdiretório abcg/examples/tictactoe. Abra o arquivo abcg/examples/CMakeLists.txt e acrescente a linha add_subdirectory(tictactoe). Para evitar que os projetos anteriores continuem sendo compilados, comente as linhas anteriores. O resultado ficará assim: # add_subdirectory(helloworld) # add_subdirectory(firstapp) add_subdirectory(tictactoe) Crie o arquivo abcg/examples/tictactoe/CMakeLists.txt. O conteúdo é o mesmo do projeto anterior. A única mudança é o nome do projeto: project(tictactoe) add_executable(${PROJECT_NAME} main.cpp window.cpp) enable_abcg(${PROJECT_NAME}) Em abcg/examples/tictactoe, crie o subdiretório assets. Nas aplicações usando a ABCg, o subdiretório assets é utilizado para armazenar arquivos de recursos utilizados em tempo de execução (arquivos de fontes, imagens, sons, etc). No nosso caso, colocaremos em assets o arquivo de fonte TrueType Inconsolata-Medium.ttf que será utilizado para o texto dos Xs e Os. O arquivo pode ser baixado, ou simplesmente copiado de abcg/abcg/assets (essa também é a fonte padrão da ABCg). Importante Sempre que um projeto da ABCg é configurado pelo CMake, o diretório assets é copiado automaticamente para o diretório do executável (build/bin/proj, onde proj é o nome do projeto). Toda vez que um arquivo de assets for modificado, é necessário limpar o diretório build para forçar a cópia de assets para build/bin/proj na próxima compilação. Isso pode ser feito de diferentes maneiras: Removendo o diretório build antes de compilar novamente; No VS Code, usando o comando “CMake: Clean Rebuild” da paleta de comandos (Ctrl+Shift+P); Construindo o projeto através da linha de comando com build.sh/build.bat. Em abcg/examples/tictactoe, crie os arquivos main.cpp, window.cpp e window.hpp. Vamos editá-los a seguir. main.cpp O conteúdo de main.cpp é praticamente o mesmo de nossa primeira aplicação. A única diferença é o título da janela e seu tamanho inicial, que agora será 600x600. #include &quot;window.hpp&quot; int main(int argc, char **argv) { try { abcg::Application app(argc, argv); Window window; window.setWindowSettings( {.width = 600, .height = 600, .title = &quot;Tic-Tac-Toe&quot;}); app.run(window); } catch (std::exception const &amp;exception) { fmt::print(stderr, &quot;{}\\n&quot;, exception.what()); return -1; } return 0; } window.hpp Aqui definiremos nossa classe Window, responsável pelo gerenciamento da janela da aplicação e também da lógica do jogo. O conteúdo ficará como a seguir: #ifndef WINDOW_HPP_ #define WINDOW_HPP_ #include &quot;abcgOpenGL.hpp&quot; class Window : public abcg::OpenGLWindow { protected: void onCreate() override; void onPaintUI() override; private: static int const m_N{3}; // Board size is m_N x m_N enum class GameState { Play, Draw, WinX, WinO }; GameState m_gameState; bool m_XsTurn{true}; std::array&lt;char, m_N * m_N&gt; m_board{}; // &#39;\\0&#39;, &#39;X&#39; or &#39;O&#39; ImFont *m_font{}; void checkEndCondition(); void restartGame(); }; #endif Em comparação com o projeto firstapp, desta vez não substituímos o método onPaint. Podemos fazer isso pois todo o conteúdo da janela será composto por controles de UI desenhados em onPaintUI. Nossa aplicação precisa de algumas variáveis para armazenar o estado do jogo. Na linha 12, m_N é o tamanho dos lados do tabuleiro. O Jogo da Velha é jogado em um tabuleiro 3x3, mas podemos mudar esse valor para jogar com um tabuleiro 4x4, 5x5, etc. O código é genérico o suficiente para permitir isso. Na linha 14 definimos GameState como uma enumeração de todos os possíveis estados do jogo. Os estados serão interpretados da seguinte maneira: GameState::Play é quando a partida está sendo jogada. Nesse estado o jogador do turno atual poderá clicar em algum lugar do tabuleiro para colocar um X ou O; GameState::Draw é quando o jogo acabou e “deu velha”; GameState::WinX é quando o jogo acabou e X ganhou; GameState::WinO é quando o jogo acabou e O ganhou. O estado atual será indicado por m_gameState na linha 15. Na linha 17, m_XsTurn é uma variável que indica se o turno atual é do X. Na linha 18, m_board é o estado do tabuleiro, definido como um arranjo de 3x3=9 caracteres (arranjo 3x3 orientado a linhas). Cada caractere pode ser \\0 (caractere nulo) para indicar que a posição está vazia, ou a letra X, ou a letra O. Na linha 20, o ponteiro m_font será usado para representar a fonte dos Xs e Os. A classe tem duas funções: checkEndCondition, que será usada no final de cada turno para verificar se m_board está em alguma condição de vitória ou empate; restateGame, para limpar o tabuleiro e iniciar um novo jogo. window.cpp Aqui definiremos as funções membro da classe Window. Começaremos definindo Window::onCreate. Como Window::onCreate é chamada apenas uma vez quando a janela é criada, ela é ideal para fazermos as configurações iniciais da aplicação, como o carregamento da nova fonte para os Xs e Os, que tem tamanho maior que a fonte padrão. O resultado ficará assim: #include &quot;window.hpp&quot; void Window::onCreate() { // Load font with bigger size for the X&#39;s and O&#39;s auto const filename{abcg::Application::getAssetsPath() + &quot;Inconsolata-Medium.ttf&quot;}; m_font = ImGui::GetIO().Fonts-&gt;AddFontFromFileTTF(filename.c_str(), 72.0f); if (m_font == nullptr) { throw abcg::RuntimeError{&quot;Cannot load font file&quot;}; } restartGame(); } Na linha 5 criamos uma string com o caminho completo do arquivo Inconsolata-Medium.ttf. Para isso usamos a função abcg::Application::getAssetsPath() que retorna o caminho atual do subdiretório assets. Na linha 7 chamamos as funções da ImGui para carregar a fonte com tamanho 72. Se ocorrer algum erro no carregamento, o ponteiro m_Font será nulo. Neste caso lançamos uma exceção (linha 9) que será capturada no bloco try...catch de main. Na linha 12 chamamos a função restartGame para deixar o jogo pronto para uma nova partida. A propósito, vejamos como fica a implementação de restartGame: void Window::restartGame() { m_board.fill(&#39;\\0&#39;); m_gameState = GameState::Play; } A função simplesmente preenche o tabuleiro com caracteres nulos e define o estado do jogo como GameState::Play. Vamos agora definir Window::onPaintUI. É nessa função que a interface será desenhada e a lógica de interação com os controles de UI implementada. Começaremos definindo a janela da ImGui: void Window::onPaintUI() { // Get size of application&#39;s window auto const appWindowWidth{gsl::narrowt&lt;float&gt;(getWindowSettings().width)}; auto const appWindowHeight{gsl::narrow&lt;float&gt;(getWindowSettings().height)}; // &quot;Tic-Tac-Toe&quot; window { ImGui::SetNextWindowSize(ImVec2(appWindowWidth, appWindowHeight)); ImGui::SetNextWindowPos(ImVec2(0, 0)); auto const flags{ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse}; ImGui::Begin(&quot;Tic-Tac-Toe&quot;, nullptr, flags); // TODO: Add Menu // TODO: Add static text showing current turn or win/draw messages // TODO: Add game board // TODO: Add &quot;Restart game&quot; button ImGui::End(); } } Nas linhas 17 e 18 pegamos o tamanho atual da janela da aplicação através da função abcg::getWindowSettings. Essa função retorna uma referência a um objeto do tipo abcg::WindowSettings contendo as configurações da janela, incluindo sua largura (width) e altura (height). Os valores são inteiros e precisam ser convertidos para float para serem utilizados nas funções da ImGui. O conteúdo da janela da ImGui é definido no escopo das linhas 21 a 35. Em particular, na linha 22 chamamos ImGui::SetNextWindowSize para informar que a janela que estamos prestes a criar terá o tamanho da janela da aplicação. De forma parecida, na linha 23 chamamos ImGui::SetNextWindowPos para informar que tal janela deverá ser posicionada na coordenada (0,0) da janela da aplicação (canto superior esquerdo). Na linha 25 definimos uma máscara de bits com as propriedades da janela que será criada. A janela terá uma barra de menu (ImGuiWindowFlags_MenuBar), não poderá ser redimensionada (ImGuiWindowFlags_NoResize), e não poderá ser colapsada ao clicar na barra de título (ImGuiWindowFlags_NoCollapse). Na linha 27 criamos de fato o controle de UI da janela. Ela é criada com as configurações definidas anteriormente. Todos os widgets criados entre essa linha de ImGui::Begin até a linha 34 de ImGui::End() serão colocados dentro dessa janela. Por enquanto a janela está vazia e só deixamos alguns comentários de tarefas a fazer: // TODO: Add Menu // TODO: Add static text showing current turn or win/draw messages // TODO: Add game board // TODO: Add &quot;Restart game&quot; button Vamos fazer essas tarefas a seguir. Adicionando o menu Substitua a linha de comentário TODO: Add Menu pelo seguinte trecho de código: // Menu { bool restartSelected{}; if (ImGui::BeginMenuBar()) { if (ImGui::BeginMenu(&quot;Game&quot;)) { ImGui::MenuItem(&quot;Restart&quot;, nullptr, &amp;restartSelected); ImGui::EndMenu(); } ImGui::EndMenuBar(); } if (restartSelected) { restartGame(); } } Este código cria uma barra de menu com uma opção “Game”. Dentro desta opção há apenas um item de menu chamado “Restart”. Observe que o estado de “Restart” é armazenado na variável booleana restartSelected, inicializada com false na linha 31. Se o item de menu é selecionado, ImGui::MenuItem muda restartSelected para true e assim chamamos restartGame na linha 40 para reiniciar o estado do jogo. Adicionando o texto do turno atual, de vitória e empate Continuando com as tarefas por fazer, substitua a linha de comentário TODO: Add static text showing current turn or win/draw messages pelo seguinte código: // Static text showing current turn or win/draw messages { std::string text; switch (m_gameState) { case GameState::Play: text = fmt::format(&quot;{}&#39;s turn&quot;, m_XsTurn ? &#39;X&#39; : &#39;O&#39;); break; case GameState::Draw: text = &quot;Draw!&quot;; break; case GameState::WinX: text = &quot;X&#39;s player wins!&quot;; break; case GameState::WinO: text = &quot;O&#39;s player wins!&quot;; break; } // Center text ImGui::SetCursorPosX( (appWindowWidth - ImGui::CalcTextSize(text.c_str()).x) / 2); ImGui::Text(&quot;%s&quot;, text.c_str()); ImGui::Spacing(); } ImGui::Spacing(); Na linha 46 definimos uma string que recebe um texto diferente dependendo do estado atual de m_gameState. Se o jogo está no modo Play, o texto será X's turn ou O's turn. Se o jogo está no modo Draw, WinX ou WinO, mensagens correspondentes de empate e vitória serão utilizadas. Na linha 62, ImGui::SetCursorPosX define a posição horizontal da janela em que o texto começará a ser exibido, da esquerda para a direita. Para que o texto fique centralizado horizontalmente, sua posição inicial deve ser a metade da largura da janela (appWindowWidth / 2) menos a metade da largura do texto (calculada com ImGui::CalcTextSize). O widget de texto é criado na linha 64. Em seguida, adicionamos um espaçamento vertical na linha 65, e outro na linha 68 para deixar um bom espaço entre o texto e o tabuleiro que será desenhado na próxima etapa. Implementando o tabuleiro O tabuleiro será mostrado como uma grade de 3x3 botões (no caso de m_N ser 3), sendo que cada botão terá como texto o caractere correspondente em m_board. Substitua a linha de comentário TODO: Add game board pelo seguinte código: // Game board { auto const gridHeight{appWindowHeight - 22 - 60 - (m_N * 10) - 60}; auto const buttonHeight{gridHeight / m_N}; // Use custom font ImGui::PushFont(m_font); if (ImGui::BeginTable(&quot;Game board&quot;, m_N)) { for (auto i : iter::range(m_N)) { ImGui::TableNextRow(); for (auto j : iter::range(m_N)) { ImGui::TableSetColumnIndex(j); auto const offset{i * m_N + j}; // Get current character auto ch{m_board.at(offset)}; // Replace null character with whitespace because the button label // cannot be an empty string if (ch == 0) { ch = &#39; &#39;; } // Button text is ch followed by an ID in the format ##ij auto buttonText{fmt::format(&quot;{}##{}{}&quot;, ch, i, j)}; if (ImGui::Button(buttonText.c_str(), ImVec2(-1, buttonHeight))) { if (m_gameState == GameState::Play &amp;&amp; ch == &#39; &#39;) { m_board.at(offset) = m_XsTurn ? &#39;X&#39; : &#39;O&#39;; checkEndCondition(); m_XsTurn = !m_XsTurn; } } } ImGui::Spacing(); } ImGui::EndTable(); } ImGui::PopFont(); } ImGui::Spacing(); Neste código, primeiro começamos calculando dois valores de altura (linhas 72 e 73). gridHeight é a altura da área útil do tabuleiro. Ela é calculada a partir da altura da janela, subtraída da altura aproximada dos outros controles de UI (22 da barra de menu, 60+60 para a área acima e abaixo do tabuleiro) e do espaçamento entre os botões do tabuleiro (10). buttonHeight é a altura de cada botão. Na linha 76, ImGui::PushFont faz com que a fonte m_font seja ativada no lugar da fonte padrão. Todo controle de UI definido entre essa linha até ImGui::PopFont (linha 107) usará essa fonte. Na linha 77 criamos uma tabela “Game board”, composta de m_N colunas. O nome “Game board” não aparece na tela. Ele serve apenas como um identificador deste controle de UI. Os laços das linha 78 e 79 iteram sobre as linhas e colunas do tabuleiro, respectivamente. Para cada nova linha chamamos ImGui::TableNextRow (linha 79), e para cada coluna chamamos ImGui::TableSetColumnIndex (linha 81) com o índice da coluna. Na linha 85 lemos o caractere atual de m_board para a linha e coluna atual. Este caractere é a letra (X, O, ou vazio) que deve ser exibida como texto do botão. Entretanto, se for um caractere nulo, mudamos para um espaço (linhas 89 a 91) pois o comando ImGui::Button não aceita strings vazias. Na linha 95 criamos o botão atual. Seu tamanho é ImVec2(-1, buttonHeight), o que significa que a largura será a máxima possível (definida por -1 ou outro valor negativo) e a altura será buttonHeight. O texto do botão (buttonText) é definido de forma um pouco mais complicada. O texto não é só o caractere ch. Se o caractere na posição (0,2) for um X, buttonText será X##02. Esse ##02 não é mostrado no botão. Ele é utilizado para indicar à ImGui que o identificador do botão é a string 02. Cada botão precisa ter um identificador único. A ImGui usa esses identificadores para definir quem está com o foco atual do teclado. Geralmente a ImGui usa o próprio texto do botão como identificador, mas como temos possivelmente vários botões com o mesmo texto (X, O ou espaço), precisamos recorrer à sintaxe ##id para definir identificadores únicos. Se o botão é pressionado, ImGui::Button retorna true. Nesse caso, precisamos verificar se a posição correspondente de m_board pode ser de fato modificada. Para isso o jogo deve estar no modo Play e ch não pode ser X ou O (linha 96), isto é, cada posição do tabuleiro só pode ser preenchida uma vez. Na linha 97 modificamos m_board para X ou O dependendo de quem está jogando o turno atual. Em seguida chamamos checkEndCondition para verificar se houve vitória ou empate (linha 98), e então alternamos o turno do jogador (linha 99). Adicionando o botão de reinício Abaixo do tabuleiro colocaremos um botão para reiniciar o jogo. Substitua a linha de comentário TODO: Add \"Restart game\" button pelo seguinte código: // &quot;Restart game&quot; button { if (ImGui::Button(&quot;Restart game&quot;, ImVec2(-1, 50))) { restartGame(); } } O botão terá largura máxima (-1) e altura 50. Note que, sempre que definimos um novo controle de UI, a ImGui cria o controle em uma nova linha (com exceção dos botões da tabela, criados entre ImGui::BeginTable e ImGui::EndTable). Fora de uma tabela, se quisermos que os controles não fiquem empilhados, podemos chamar ImGui::SameLine antes de criar o próximo controle. Assim ele será criado do lado direito do anterior. Verificando a condição de vitória e empate Para concluir a implementação de nosso Jogo da Velha, precisamos definir a função checkEndCondition. Essa função é chamada após cada jogada para verificar se m_board está em alguma condição de vitória ou empate: Se alguma linha, coluna ou diagonal de m_board tiver somente X, então o jogador do X ganhou (devemos mudar o estado do jogo para GameState::WinX). Se alguma linha, coluna ou diagonal de m_board tiver somente O, então o jogador do O ganhou (devemos ir ao estado GameState::WinO). Se o tabuleiro não tiver mais nenhum caractere nulo, e nem o X nem o O ganharam, então “deu velha” (devemos ir ao estado GameState::Draw). Vamos implementar a função aos poucos, começando com o código a seguir. Note que há vários comentários com tarefas por fazer (TODO): void Window::checkEndCondition() { if (m_gameState != GameState::Play) { return; } // Lambda expression that checks if a string contains only Xs or Os. If so, it // changes the game state to WinX or WinO accordingly and returns true. // Otherwise, returns false. auto allXsOrOs{[&amp;](std::string_view str) { if (str == std::string(m_N, &#39;X&#39;)) { m_gameState = GameState::WinX; return true; } if (str == std::string(m_N, &#39;O&#39;)) { m_gameState = GameState::WinO; return true; } return false; }}; // TODO: Check rows // TODO: Check columns // TODO: Check main diagonal // TODO: Check inverse diagonal // TODO: Check draw } O tabuleiro só precisa ser verificado quando o jogo está no estado GameState::Play. A condição da linha 124 verifica isso. Na linha 131 definimos uma expressão lambda que será usada várias vezes posteriormente para verificar as linhas, colunas e diagonais de m_board. Mais especificamente, a expressão lambda verifica se uma string str passada como parâmetro é composta apenas por 3 caracteres X ou 3 caracteres O (supondo que m_N é 3). Se sim, ela retorna true e seta o estado do jogo para WinX ou WinO de forma correspondente. Se não, ela só retorna false. Vamos agora implementar o código que corresponde ao comentário TODO: Check rows, isto é, o código que verifica cada linha do tabuleiro: // Check rows for (auto const i : iter::range(m_N)) { std::string concatenation; for (auto const j : iter::range(m_N)) { concatenation += m_board.at(i * m_N + j); } if (allXsOrOs(concatenation)) { return; } } Os laços aninhados iteram as linhas (i) e colunas (j) do tabuleiro. Para cada linha, uma string concatenation é preenchida com os caracteres daquela linha. allXsOrOs é então chamada para verificar se a string contém 3 X ou 3 O. Se sim, checkEndCondition retorna na linha 150 pois a condição final já foi encontrada. Caso contrário, a verificação deve continuar. O código dos outros TODOs é similar: // Check columns for (auto const j : iter::range(m_N)) { std::string concatenation; for (auto const i : iter::range(m_N)) { concatenation += m_board.at(i * m_N + j); } if (allXsOrOs(concatenation)) { return; } } // Check main diagonal { std::string concatenation; for (auto const i : iter::range(m_N)) { concatenation += m_board.at(i * m_N + i); } if (allXsOrOs(concatenation)) { return; } } // Check inverse diagonal { std::string concatenation; for (auto const i : iter::range(m_N)) { concatenation += m_board.at(i * m_N + (m_N - i - 1)); } if (allXsOrOs(concatenation)) { return; } } // Check draw if (std::find(m_board.begin(), m_board.end(), &#39;\\0&#39;) == m_board.end()) { m_gameState = GameState::Draw; } A verificação do empate é feita na condicional da linha 188. Observe que ela só será executada se as condições de vitória anteriores não tiverem sido satisfeitas. Então, se nesse momento não tiver nenhum caractere nulo em m_board, significa que o tabuleiro está todo preenchido com X e O mas ninguém ganhou, isto é, “deu velha”. Laços baseados em intervalos Observe que usamos laços for baseados em intervalos (range-based for loops) juntos com a função iter::range da biblioteca CPPItertools. Use laços baseados em intervalos sempre que possível. Eles são mais fáceis de ler e mais seguros pois evitam bugs comuns como trocar &lt; por outro comparador (&gt;, ou &lt;=) ou incrementar a variável errada. Por exemplo, para iterar com um índice i de 0 a 9, ao invés de usar o for tradicional for (int i = 0; i &lt; 10; ++i) { // i = 0, 1, ..., 9 } prefira fazer assim: for (auto i : iter::range(10)) { // i = 0, 1, ..., 9 } iter::range funciona da mesma forma que a função range do Python. De forma semelhante, para iterar um arranjo a e imprimir seu conteúdo, prefira fazer assim std::array a{&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;}; for (auto const &amp;str : a) { fmt::print(&quot;{}&quot;, str); } ao invés de: std::array a{&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;}; for (std::size_t i = 0; i &lt; a.size(); ++i) { fmt::print(&quot;{}&quot;, a[i]); } O projeto completo do Jogo da Velha pode ser baixado deste link. "],["referências.html", "Referências", " Referências "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
