[["transformations.html", "8 Matrizes e transformações", " 8 Matrizes e transformações Este capítulo dá sequência à introdução de conceitos utilizados no processamento geométrico para síntese de imagens. A seção 8.1 é uma revisão sobre os conceitos de matrizes e transformações lineares. A seção 8.2 faz uma introdução ao sistema de coordenadas homogêneas. Coordenadas homogêneas possibilitam representar de forma unificada transformações afins (transformações lineares e deslocamento de pontos) através de operações matriciais. A seção 8.3 mostra como podemos fazer concatenação de transformações através de produtos matriciais. Junto com a representação em coordenadas homogêneas, a concatenação de transformações como produtos entre matrizes simplifica o processamento geométrico e aumenta sua eficiência. Na seção 8.4 são apresentadas as principais matrizes de transformação que serão utilizadas no curso. Tais matrizes representam transformações entre espaços, utilizadas para posicionar/orientar objetos em uma cena e definir pontos de vista de câmeras virtuais. A seção 8.5 apresenta os principais espaços utilizados no pipeline do OpenGL. A seção 8.6 apresenta o conceito de construção de uma câmera LookAt, que é a criação do quadro de uma câmera virtual a partir de dois pontos (posição da câmera e posição para onde a câmera está olhando) e um vetor de referência que indica a direção “para cima”. Este e outros conceitos abordados neste capítulo são colocados em prática no projeto lookat da seção 8.7. "],["matrix.html", "8.1 Matrizes", " 8.1 Matrizes Uma matriz é um arranjo de \\(n \\times m\\) escalares, onde \\(n\\) é o número de linhas e \\(m\\) é o número de colunas. No exemplo a seguir, \\(\\mathbf{A}\\) é uma matriz de tamanho \\(3 \\times 4\\), isto é, é uma matriz de 3 linhas e 4 colunas: \\[ \\mathbf{A}= \\begin{bmatrix} \\phantom{-.1}9 &amp; \\phantom{-}2 &amp; \\phantom{.2} 10 &amp; \\phantom{.2} 4 \\\\ \\phantom{-.1}4 &amp; -2 &amp; 0.25 &amp; \\phantom{.2} 1 \\\\ -8.1 &amp; \\phantom{-}6 &amp; \\phantom{.2} 42 &amp; \\phantom{.2} 0 \\\\ \\end{bmatrix}. \\] Cada elemento de \\(\\mathbf{A}\\) é denotado por \\(a_{ij}\\), onde \\(i\\) é a linha, e \\(j\\) é a coluna do elemento da matriz: \\[ \\mathbf{A}= \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\dots &amp; a_{1m} \\\\ a_{21} &amp; a_{22} &amp; a_{23} &amp; \\dots &amp; a_{2m} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\dots &amp; a_{nm} \\end{bmatrix}. \\] Matriz transposta A transposta de uma matriz \\(\\mathbf{A}\\) de tamanho \\(n \\times m\\), denotada por \\(\\mathbf{A}^T\\), é uma matriz de tamanho \\(m \\times n\\) obtida trocando as linhas pelas colunas. Por exemplo, se \\[ \\mathbf{A} = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}, \\] então \\[ \\mathbf{A}^T = \\begin{bmatrix} 1 &amp; 4 \\\\ 2 &amp; 5 \\\\ 3 &amp; 6 \\end{bmatrix}. \\] A transposta da transposta é a matriz original, isto é, \\[{(\\mathbf{A}^T)}^T = \\mathbf{A}.\\] Matriz quadrada Uma matriz quadrada é uma matriz na qual o número de linhas é igual ao número de colunas (\\(n=m\\)). Se \\(\\mathbf{A}\\) é uma matriz quadrada de \\(n\\) linhas e colunas, dizemos que \\(\\mathbf{A}\\) é uma matriz de ordem \\(n\\). Por exemplo, \\[ \\mathbf{A}= \\begin{bmatrix} 5 &amp; 1 &amp; 4 \\\\ 7 &amp; 0 &amp; 2 \\\\ 3 &amp; 3 &amp; 9 \\\\ \\end{bmatrix} \\] é uma matriz de ordem 3. Matriz linha/coluna Uma tupla de \\(n\\) elementos pode ser representada por uma matriz \\(1 \\times n\\) (matriz linha) ou \\(n \\times 1\\) (matriz coluna). Para matrizes linha e matrizes coluna, usaremos a notação de letra minúscula em negrito \\((\\mathbf{a}, \\mathbf{b}, \\dots)\\), como na notação de vetor. Para trabalharmos com transformações matriciais, usaremos matrizes coluna para escrever a representação de vetores em uma base conhecida. Por exemplo, a representação de um vetor no \\(\\mathbb{R}^3\\) pode ser escrita pela matriz de componentes \\[ \\mathbf{v} = \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} \\] sendo que \\[\\mathbf{v}=x\\hat{\\mathbf{i}} + y\\hat{\\mathbf{j}} + z\\hat{\\mathbf{k}}.\\] Matriz identidade A matriz identidade, denotada por \\(\\mathbf{I}\\), é uma matriz quadrada na qual todos os elementos de uma das diagonais – elementos \\(a_{ij}\\) em que \\(i=j\\), chamada de diagonal principal – são \\(1\\), e todos os outros elementos são \\(0\\). \\[ \\mathbf{I}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 1 \\end{bmatrix}. \\] Por exemplo, a matriz identidade de ordem 3 é a matriz \\[ \\mathbf{I}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\] A matriz identidade é o elemento neutro da multiplicação entre matrizes: \\[ \\mathbf{A}\\mathbf{I} = \\mathbf{I}\\mathbf{A} = \\mathbf{A}. \\] Operações Há três operações básicas com matrizes: Adição de matriz com matriz: \\[\\mathbf{A} + \\mathbf{B}\\] tem como resultado uma matriz que contém a soma elemento a elemento de \\(\\mathbf{A}\\) e \\(\\mathbf{B}\\), sendo que \\(\\mathbf{A}\\) e \\(\\mathbf{B}\\) precisam ter o mesmo tamanho. Por exemplo, se \\[ \\begin{align} \\mathbf{A} &amp;= \\begin{bmatrix} \\phantom{-}1 &amp; -2 &amp; \\phantom{-}3 \\\\ -4 &amp; \\phantom{-}5 &amp; \\phantom{-}6 \\\\ \\end{bmatrix},\\\\ \\mathbf{B} &amp;= \\begin{bmatrix} -1 &amp; -3 &amp; \\phantom{-}6 \\\\ \\phantom{-}0 &amp; \\phantom{-}5 &amp; \\phantom{-}2 \\\\ \\end{bmatrix}, \\end{align} \\] então \\[ \\mathbf{A}+\\mathbf{B} = \\begin{bmatrix} \\phantom{-}0 &amp; -5 &amp; \\phantom{-}9 \\\\ -4 &amp; 10 &amp; \\phantom{-}8 \\\\ \\end{bmatrix}. \\] Essa operação é comutativa e associativa: \\[ \\begin{align} \\mathbf{A}+\\mathbf{B} &amp;= \\mathbf{B}+\\mathbf{A},\\\\ \\mathbf{A}+(\\mathbf{B}+\\mathbf{C}) &amp;= (\\mathbf{A}+\\mathbf{B})+\\mathbf{C}. \\end{align} \\] Multiplicação de escalar com matriz: \\[a\\mathbf{A}\\] tem como resultado uma matriz na qual cada elemento da matriz \\(\\mathbf{A}\\) é multiplicado pelo escalar \\(a\\). Por exemplo, se \\[ \\mathbf{A} = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}, \\] então \\[ 2\\mathbf{A} = \\begin{bmatrix} 2 &amp; 4 &amp; 6 \\\\ 8 &amp; 10 &amp; 12 \\\\ \\end{bmatrix}. \\] Essa operação é distributiva e associativa: \\[ \\begin{align} a(\\mathbf{A}+\\mathbf{B}) &amp;= a\\mathbf{A}+a\\mathbf{B},\\\\ (a+b)\\mathbf{A} &amp;= a\\mathbf{A}+b\\mathbf{A},\\\\ a(b\\mathbf{A}) &amp;= (ab)\\mathbf{A},\\\\ ab\\mathbf{A} &amp;= ba\\mathbf{A}. \\end{align} \\] Multiplicação de matriz com matriz: \\[\\mathbf{A}\\mathbf{B}\\] ou \\[\\mathbf{A}\\,.\\mathbf{B}\\] é definida apenas quando o número de colunas de \\(\\mathbf{A}\\) é igual ao número de linhas de \\(\\mathbf{B}\\). Se \\(\\mathbf{A}\\) é uma matriz \\(n \\times l\\), e \\(\\mathbf{B}\\) é uma matriz \\(l \\times m\\), então \\(\\mathbf{C} = \\mathbf{A}\\mathbf{B}\\) é uma matriz de tamanho \\(n \\times m\\) tal que \\[ c_{ij}=\\sum_{k=1}^l a_{ik}b_{kj}. \\] Desse modo, o elemento \\(c_{ij}\\) (elemento da \\(i\\)-ésima linha e \\(j\\)-ésima coluna de \\(\\mathbf{C}\\)) será o somatório da multiplicação elemento a elemento da \\(i\\)-ésima linha de \\(\\mathbf{A}\\) com a \\(j\\)-ésima coluna de \\(\\mathbf{B}\\). Por exemplo, se \\[ \\begin{align} \\mathbf{A} &amp;= \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{bmatrix},\\\\ \\mathbf{B} &amp;= \\left[ \\begin{array}{rr} -1 &amp; 0 \\\\ -3 &amp; 5 \\\\ 6 &amp; 2 \\end{array} \\right], \\end{align} \\] então \\[ \\begin{align} \\mathbf{C} &amp;=\\mathbf{A}\\mathbf{B} \\\\ &amp;= \\left[ \\begin{array}{rrr} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{array} \\right] \\left[ \\begin{array}{rr} -1 &amp; 0 \\\\ -3 &amp; 5 \\\\ 6 &amp; 2 \\end{array} \\right]\\\\ &amp;= \\left[ \\begin{array}{rr} (1 \\times -1)+(2 \\times -3)+(3 \\times 6) &amp; (1 \\times 0)+(2 \\times 5)+(3 \\times 2) \\\\ (4 \\times -1)+(5 \\times -3)+(6 \\times 6) &amp; (4 \\times 0)+(5 \\times 5)+(6 \\times 2) \\end{array} \\right]\\\\ &amp;= \\left[ \\begin{array}{rr} 11 &amp; 16 \\\\ 17 &amp; 37 \\end{array} \\right]. \\end{align} \\] Embora a multiplicação entre matrizes seja associativa, \\[ \\mathbf{A}(\\mathbf{B}\\mathbf{C}) = (\\mathbf{A}\\mathbf{B})\\mathbf{C}, \\] na maioria das vezes não é comutativa, isto é, \\[ \\mathbf{A}\\mathbf{B} \\neq \\mathbf{B}\\mathbf{A}. \\] Os casos em que \\(\\mathbf{A}\\mathbf{B} = \\mathbf{B}\\mathbf{A}\\) são casos especiais como, por exemplo, quando \\(\\mathbf{A}\\mathbf{B} = \\mathbf{I}\\) (veja a definição de matriz inversa a seguir). Se \\(\\mathbf{a}\\) e \\(\\mathbf{b}\\) são representações de vetores \\[ \\begin{align} \\mathbf{a} = \\left[ \\begin{array}{} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{array} \\right],\\qquad \\mathbf{b} = \\left[ \\begin{array}{} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n \\end{array} \\right], \\end{align} \\] a multiplicação da transposta de \\(\\mathbf{a}\\) por \\(\\mathbf{b}\\) tem como resultado o produto escalar entre os vetores: \\[ \\begin{align} \\mathbf{a}^T\\mathbf{b} &amp;= \\left[ \\begin{array}{} a_1 &amp; a_2 &amp; \\dots &amp; a_n \\end{array} \\right] \\left[ \\begin{array}{} b_1 \\\\ b_2 \\\\ \\vdots \\\\ a_n \\end{array} \\right]\\\\ &amp;= a_1b_1 + a_2b_2 + \\dots + a_nb_n\\\\ &amp;= \\mathbf{a} \\cdot \\mathbf{b}. \\end{align} \\] Da mesma forma, podemos definir a norma euclidiana de \\(\\mathbf{a}\\) como \\[ \\begin{align} |\\mathbf{a}| &amp;= \\sqrt{\\mathbf{a}^T \\mathbf{a}} \\end{align}. \\] Matriz inversa Se, para uma dada matriz quadrada \\(\\mathbf{A}\\), existir uma matriz \\(\\mathbf{B}\\) tal que \\(\\mathbf{A}\\mathbf{B} = \\mathbf{B}\\mathbf{A} = \\mathbf{I}\\), então \\(\\mathbf{B}\\) é a inversa de \\(\\mathbf{A}\\), denotada por \\(\\mathbf{A}^{-1}\\): \\[ \\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{A}^{-1}\\mathbf{A} = \\mathbf{I}. \\] A inversa da inversa é a matriz original, isto é, \\[{(\\mathbf{A}^{-1})}^{-1} = \\mathbf{A}.\\] Se uma matriz possui uma inversa, dizemos que a matriz é inversível ou não singular. Caso contrário, dizemos que a matriz é singular. Uma matriz \\(\\mathbf{A}\\) é inversível apenas se seu determinante, denotado por \\(|\\mathbf{A}|\\) ou \\(\\det(\\mathbf{A}),\\) for diferente de zero. O determinante de uma matriz de ordem \\(n\\) pode ser definido recursivamente como uma soma ponderada de \\(n\\) determinantes de submatrizes de ordem \\(n-1\\) (teorema de Laplace): \\[ |\\mathbf{A}|=\\sum^n_{j=1}(-1)^{i+j}a_{ij}M_{ij}, \\] onde \\(M_{ij}\\), chamado de determinante menor de \\(\\mathbf{A}\\), é o determinante da matriz de ordem \\(n-1\\) obtida através da remoção da linha \\(i\\) e coluna \\(j\\) de \\(\\mathbf{A}\\), sendo que \\(i\\) pode ser o índice de qualquer linha da matriz. Nessa expressão, \\((-1)^{i+j}M_{ij}\\) é chamado de cofator do elemento \\(a_{ij}\\) e é denotado por \\(C_{ij}\\). Para matrizes de ordem 2 e 3, o procedimento é suficientemente simples e é mostrado a seguir: Para uma matriz de ordem 2, \\[ \\mathbf{A} = \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}, \\] \\[ \\begin{align} |\\mathbf{A}| &amp;= \\begin{vmatrix} a &amp; b \\\\ c &amp; d \\end{vmatrix}\\\\ &amp;= ad - bc. \\end{align} \\] Para uma matriz de ordem 3, \\[ \\begin{align} \\mathbf{A} = \\begin{bmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{bmatrix}, \\end{align} \\] \\[ \\begin{align} |\\mathbf{A}| &amp;= \\begin{vmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{vmatrix}\\\\ &amp;= a \\begin{vmatrix} e &amp; f \\\\ h &amp; i \\end{vmatrix} -b \\begin{vmatrix} d &amp; f \\\\ g &amp; i \\end{vmatrix} +c \\begin{vmatrix} d &amp; e \\\\ g &amp; h \\end{vmatrix}\\\\ &amp;= aei + bfg + cdh - ceg -bdi - afh. \\end{align} \\] A complexidade de tempo para calcular o determinante por este método é \\(O(n!)\\). Há soluções mais eficientes para matrizes de ordem mais elevada, como o uso de decomposição LU ou eliminação de Gauss, com complexidade \\(O(n^3)\\). Entretanto, como usaremos matrizes de ordem até 4, o método anterior é suficiente. A matriz inversa de uma matriz \\(\\mathbf{A}\\) inversível pode ser calculada como \\[ \\mathbf{A}^{-1}=\\frac{1}{|\\mathbf{A}|} . \\textrm{adj}(\\mathbf{A}), \\] onde \\(\\textrm{adj}(\\mathbf{A})\\), chamada de matriz adjunta de \\(\\mathbf{A}\\), é a transposta da matriz de cofatores de \\(\\mathbf{A}\\). Isto é, \\[ \\textrm{adj}(\\mathbf{A})= \\begin{bmatrix} C_{ij} \\end{bmatrix}^T. \\] Em computação gráfica, frequentemente podemos evitar o uso de métodos numéricos de inversão de matrizes pois muitas matrizes representam transformações inversíveis através de um raciocínio geométrico. Por exemplo: Se uma matriz representa uma rotação de \\(45\\) graus em torno do eixo \\(x\\), então sua inversa é uma matriz que representa uma rotação de \\(-45\\) graus em torno do eixo \\(x\\); Se uma matriz representa uma translação pelo vetor \\((x,y,z)\\), então sua inversa é uma matriz que representa uma translação pelo vetor \\((-x,-y,-z)\\). Se uma matriz representa uma mudança de escala por um fator \\(s \\neq 0\\), então sua inversa é uma matriz de mudança de escala por um fator \\(1/s\\). Abordaremos essas e outras matrizes de transformação na seção 8.4. Matriz ortogonal Uma matriz \\(\\mathbf{A}\\) é ortogonal se \\[\\mathbf{A}\\mathbf{A}^T=\\mathbf{A}^T\\mathbf{A}=\\mathbf{I},\\] isto é, sua transposta é também a sua inversa: \\[\\mathbf{A}^T=\\mathbf{A}^{-1}.\\] As linhas e colunas de uma matriz ortogonal formam uma base ortonormal. Por exemplo, as matrizes \\[ \\begin{align} \\mathbf{A} &amp;= \\begin{bmatrix} \\hat{\\mathbf{i}} &amp; \\phantom{-}\\hat{\\mathbf{j}} &amp; \\phantom{-}\\hat{\\mathbf{k}} \\\\ \\end{bmatrix},\\\\ \\mathbf{B} &amp;= \\begin{bmatrix} \\hat{\\mathbf{i}} &amp; -\\hat{\\mathbf{j}} &amp; \\phantom{-}\\hat{\\mathbf{k}} \\\\ \\end{bmatrix},\\\\ \\mathbf{C} &amp;= \\begin{bmatrix} \\hat{\\mathbf{k}} &amp; \\phantom{k}\\hat{\\mathbf{i}} &amp; \\phantom{-.}\\hat{\\mathbf{j}} \\\\ \\end{bmatrix}, \\end{align} \\] com colunas formadas pelos seguintes vetores do quadro padrão do \\(\\mathbb{R}^3\\), \\[ \\begin{align} \\hat{\\mathbf{i}} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\qquad \\hat{\\mathbf{j}} = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix},\\qquad \\hat{\\mathbf{k}} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}, \\end{align} \\] são matrizes ortogonais. O determinante de uma matriz ortogonal é sempre \\(1\\) ou \\(-1\\). Propriedades \\((\\mathbf{A}+\\mathbf{B})^T=\\mathbf{A}^T + \\mathbf{B}^T\\). \\((\\mathbf{A}^T)^{-1}=(\\mathbf{A}^{-1})^T\\). \\((\\mathbf{A}\\mathbf{B})^T=\\mathbf{B}^T\\mathbf{A}^T\\). Observe como a ordem dos fatores é invertida. No caso geral, \\((\\mathbf{A}_1\\mathbf{A}_2\\dots\\mathbf{A}_k)^T=\\mathbf{A}_k^T\\dots\\mathbf{A}_2^T\\mathbf{A}_1^T\\). \\((\\mathbf{A}\\mathbf{B})^{-1}=\\mathbf{B}^{-1}\\mathbf{A}^{-1}\\). No caso geral, para um conjunto \\(\\{\\mathbf{A}_i\\}\\) de matrizes inversíveis, \\((\\mathbf{A}_1\\mathbf{A}_2\\dots\\mathbf{A}_k)^{-1}=\\mathbf{A}_k^{-1}\\dots\\mathbf{A}_2^{-1}\\mathbf{A}_1^{-1}\\). Transformação linear Uma transformação linear \\(T\\) corresponde a um mapeamento entre dois espaços vetoriais que preserva as operações de adição de vetor com vetor, e multiplicação de vetor com escalar, isto é, \\[ T(a\\mathbf{u}+b\\mathbf{v})=aT(\\mathbf{u})+bT(\\mathbf{v}) \\] para quaisquer vetores \\(\\mathbf{u}, \\mathbf{v} \\in V\\), e quaisquer escalares \\(a\\) e \\(b\\). A transformação linear \\(T(\\mathbf{v})\\) é equivalente à combinação linear da transformação dos vetores da base de \\(\\mathbf{v}\\): \\[T(\\mathbf{v})=v_1T(\\mathbf{e}_1) + v_2T(\\mathbf{e}_2) + \\cdots + v_nT(\\mathbf{e}_n).\\] Uma matriz de transformação representa uma transformação linear \\(T\\) escrita como uma multiplicação entre uma matriz \\(\\mathbf{A}\\) e um vetor \\(\\mathbf{v}\\): \\[T(\\mathbf{v})=\\mathbf{A}\\mathbf{v}.\\] Mudança de base Considere a transformação linear \\(T(\\mathbf{v})\\) no \\(\\mathbb{R}^n\\) sobre um vetor \\(\\mathbf{v}\\): \\[\\mathbf{v}&#39;=T(\\mathbf{v})=v_1T(\\mathbf{e}_1) + v_2T(\\mathbf{e}_2) + \\cdots + v_nT(\\mathbf{e}_n).\\] Na forma matricial: \\[ \\mathbf{v}&#39;=\\mathbf{A}\\mathbf{v},\\\\ \\begin{bmatrix}v_1&#39;\\\\v_2&#39;\\\\ \\vdots \\\\ v_n&#39;\\end{bmatrix}= \\begin{bmatrix} T(\\mathbf{e}_1) &amp; T(\\mathbf{e}_2) &amp; \\cdots &amp; T(\\mathbf{e}_n) \\end{bmatrix} \\begin{bmatrix}v_1\\\\v_2\\\\ \\vdots \\\\ v_n\\end{bmatrix}. \\] A matriz \\(\\mathbf{A}\\) é uma matriz de mudança de base se \\(\\{T(\\mathbf{e}_1), T(\\mathbf{e}_2), \\cdots, T(\\mathbf{e}_n)\\}\\) é também uma base. Suponha que \\(\\beta_1=\\{\\mathbf{u}_1, \\mathbf{v}_1, \\mathbf{w}_1\\}\\), e \\(\\beta_2=\\{\\mathbf{u}_2, \\mathbf{v}_2, \\mathbf{w}_2\\}\\) sejam duas bases do \\(\\mathbb{R}^3\\) (sem perder a generalidade para outras dimensões). Além disso, suponha que \\(\\mathbf{v}_{\\beta_1}=[x_1\\quad y_1\\quad z_1]^T\\) é a representação de um vetor \\(\\mathbf{v}\\) em relação a \\(\\beta_1\\), e \\(\\mathbf{v}_{\\beta_2}=[x_2\\quad y_2\\quad z_2]^T\\) é a representação do mesmo vetor \\(\\mathbf{v}\\), mas em relação à base \\(\\beta_2\\). Como \\(\\mathbf{v}_{\\beta_1}\\) e \\(\\mathbf{v}_{\\beta_2}\\) correspondem ao mesmo vetor \\(\\mathbf{v}\\) na base padrão, podemos escrever: \\[ x_1 \\mathbf{u}_1 + y_1 \\mathbf{v}_1 + z_1 \\mathbf{w}_1 = x_2 \\mathbf{u}_2 + y_2 \\mathbf{v}_2 + z_2 \\mathbf{w}_2. \\] Convertendo para a forma matricial, \\[ \\begin{bmatrix} \\mathbf{u}_2 &amp; \\mathbf{v}_2 &amp; \\mathbf{w}_2 \\end{bmatrix} \\begin{bmatrix} x_2\\\\ y_2\\\\ z_2 \\end{bmatrix} = \\begin{bmatrix} \\mathbf{u}_1 &amp; \\mathbf{v}_1 &amp; \\mathbf{w}_1 \\end{bmatrix} \\begin{bmatrix} x_1\\\\ y_1\\\\ z_1 \\end{bmatrix}. \\] Expandindo as componentes dos vetores: \\[ \\begin{bmatrix} u_{2x} &amp; v_{2x} &amp; w_{2x} \\\\ u_{2y} &amp; v_{2y} &amp; w_{2y} \\\\ u_{2z} &amp; v_{2z} &amp; w_{2z} \\\\ \\end{bmatrix} \\begin{bmatrix} x_2\\\\ y_2\\\\ z_2 \\end{bmatrix} = \\begin{bmatrix} u_{1x} &amp; v_{1x} &amp; w_{1x} \\\\ u_{1y} &amp; v_{1y} &amp; w_{1y} \\\\ u_{1z} &amp; v_{1z} &amp; w_{1z} \\\\ \\end{bmatrix} \\begin{bmatrix} x_1\\\\ y_1\\\\ z_1 \\end{bmatrix}. \\] Podemos isolar \\([x_2\\quad y_2\\quad z_2]^T\\) multiplicando a equação à esquerda pela inversa de \\([\\mathbf{u}_2\\quad \\mathbf{v}_2\\quad \\mathbf{w}_2]\\), \\[ \\begin{bmatrix} x_2\\\\ y_2\\\\ z_2 \\end{bmatrix} = \\begin{bmatrix} u_{2x} &amp; v_{2x} &amp; w_{2x} \\\\ u_{2y} &amp; v_{2y} &amp; w_{2y} \\\\ u_{2z} &amp; v_{2z} &amp; w_{2z} \\\\ \\end{bmatrix}^{-1} \\begin{bmatrix} u_{1x} &amp; v_{1x} &amp; w_{1x} \\\\ u_{1y} &amp; v_{1y} &amp; w_{1y} \\\\ u_{1z} &amp; v_{1z} &amp; w_{1z} \\\\ \\end{bmatrix} \\begin{bmatrix} x_1\\\\ y_1\\\\ z_1 \\end{bmatrix}. \\] Logo, \\[ \\mathbf{A}= \\begin{bmatrix} u_{2x} &amp; v_{2x} &amp; w_{2x} \\\\ u_{2y} &amp; v_{2y} &amp; w_{2y} \\\\ u_{2z} &amp; v_{2z} &amp; w_{2z} \\\\ \\end{bmatrix}^{-1} \\begin{bmatrix} u_{1x} &amp; v_{1x} &amp; w_{1x} \\\\ u_{1y} &amp; v_{1y} &amp; w_{1y} \\\\ u_{1z} &amp; v_{1z} &amp; w_{1z} \\\\ \\end{bmatrix} \\] é a matriz que converte representações de vetores na base \\(\\beta_1\\) para representações de vetores na base \\(\\beta_2\\). Observe que, se \\(\\beta_2=\\{\\hat{\\mathbf{i}}, \\hat{\\mathbf{j}}, \\hat{\\mathbf{k}}\\}\\), então \\[ \\begin{align*} \\mathbf{A}&amp;= \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ \\end{bmatrix}^{-1} \\begin{bmatrix} u_{1x} &amp; v_{1x} &amp; w_{1x} \\\\ u_{1y} &amp; v_{1y} &amp; w_{1y} \\\\ u_{1z} &amp; v_{1z} &amp; w_{1z} \\\\ \\end{bmatrix}\\\\ &amp;= \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ \\end{bmatrix} \\begin{bmatrix} u_{1x} &amp; v_{1x} &amp; w_{1x} \\\\ u_{1y} &amp; v_{1y} &amp; w_{1y} \\\\ u_{1z} &amp; v_{1z} &amp; w_{1z} \\\\ \\end{bmatrix}\\\\ &amp;= \\begin{bmatrix} u_{1x} &amp; v_{1x} &amp; w_{1x} \\\\ u_{1y} &amp; v_{1y} &amp; w_{1y} \\\\ u_{1z} &amp; v_{1z} &amp; w_{1z} \\\\ \\end{bmatrix}, \\end{align*} \\] que é simplesmente a matriz construída de tal modo que suas colunas sejam os vetores da base \\(\\beta_1\\). Em resumo, a matriz de mudança de base que muda de uma base \\(\\beta\\) para a base padrão é a matriz cujas colunas são compostas pelos vetores da base \\(\\beta\\). "],["homogeneous.html", "8.2 Coordenadas homogêneas", " 8.2 Coordenadas homogêneas Vimos que a expressão \\[\\mathbf{v}&#39;=\\mathbf{A}\\mathbf{v},\\] onde \\[ \\mathbf{v}&#39;=\\begin{bmatrix}x&#39;\\\\y&#39;\\\\z&#39;\\end{bmatrix},\\qquad \\mathbf{A}=\\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\end{bmatrix}, \\qquad \\mathbf{v}=\\begin{bmatrix}x\\\\y\\\\z\\end{bmatrix}, \\] representa uma transformação linear de um vetor \\(\\mathbf{v}\\) no espaço vetorial euclidiano \\(\\mathbb{R}^3\\). Podemos supor que as coordenadas de \\(\\mathbf{v}\\) representam as coordenadas de um ponto no quadro padrão do espaço euclidiano: o ponto resultante do deslocamento da origem pelo vetor \\(\\mathbf{v}\\). Assim, podemos usar matrizes para transformações lineares sobre pontos, além de vetores. Entretanto, essa notação não nos permite ir muito adiante. Primeiro, ela não permite diferenciar o que é a representação de um ponto e o que é a representação de um vetor. Além disso, a matriz de transformação linear no \\(\\mathbb{R}^3\\) não é capaz de representar transformações que envolvem deslocamento de pontos. A simples operação \\[\\mathbf{p&#39;}=\\mathbf{p}+\\mathbf{t},\\] onde \\(\\mathbf{p}\\) é um ponto e \\(\\mathbf{t}\\) é um vetor, não pode ser representada como uma matriz de transformação linear na forma \\[ \\mathbf{p}&#39;=\\mathbf{A}\\mathbf{p},\\\\ \\\\ \\begin{bmatrix}x&#39;\\\\y&#39;\\\\z&#39;\\end{bmatrix}= \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\end{bmatrix} \\begin{bmatrix}x\\\\y\\\\z\\end{bmatrix}. \\] Felizmente, podemos contornar essas dificuldades se representarmos pontos e vetores do \\(\\mathbb{R}^3\\) em um sistema de coordenadas homogêneas no espaço \\(\\mathbb{R}^4\\). Como vimos na definição de combinação afim (seção 7.2), podemos multiplicar um escalar \\(a\\) por um ponto \\(P\\), de modo que \\[ 0 P = \\mathbf{0},\\\\ 1 P = P. \\] Um ponto \\(P=(x,y,z)\\) no quadro \\(\\{P_0, \\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\}\\) é definido unicamente como \\[ P = x\\mathbf{v}_1 + y\\mathbf{v}_2 + z\\mathbf{v}_3 + P_0. \\] Em coordenadas homogêneas, \\(P\\) pode ser representado pela matriz coluna de coeficientes \\[ \\begin{align} \\mathbf{p}&amp;=\\begin{bmatrix}x\\\\y\\\\z\\\\1\\end{bmatrix}, \\end{align} \\] uma vez que \\[ \\begin{align} P &amp;= x\\mathbf{v}_1 + y\\mathbf{v}_2 + z\\mathbf{v}_3 + P_0\\\\ &amp;= \\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix} \\begin{bmatrix}\\mathbf{v}_1 \\\\ \\mathbf{v}_2 \\\\ \\mathbf{v}_3 \\\\ P_0\\end{bmatrix}. \\end{align} \\] De forma semelhante, um vetor \\(\\mathbf{v}=[x\\quad y \\quad z]^T\\) no mesmo quadro, \\[ \\mathbf{v} = x\\mathbf{v}_1 + y\\mathbf{v}_2 + z\\mathbf{v}_3 + 0 P, \\] pode ser definido em coordenadas homogêneas pela matriz coluna de coeficientes \\[ \\begin{align} \\mathbf{v}&amp;=\\begin{bmatrix}x\\\\y\\\\z\\\\0\\end{bmatrix}, \\end{align} \\] uma vez que \\[ \\begin{align} \\mathbf{v} &amp;= x\\mathbf{v}_1 + y\\mathbf{v}_2 + z\\mathbf{v}_3\\\\ &amp;= \\begin{bmatrix}x &amp; y &amp; z &amp; 0\\end{bmatrix} \\begin{bmatrix}\\mathbf{v}_1 \\\\ \\mathbf{v}_2 \\\\ \\mathbf{v}_3 \\\\ P_0\\end{bmatrix}. \\end{align} \\] Na expressão \\[\\mathbf{p}&#39;=\\mathbf{A}\\mathbf{p},\\] onde \\[ \\mathbf{p}&#39;=\\begin{bmatrix}x&#39;\\\\y&#39;\\\\z&#39;\\\\w&#39;\\end{bmatrix},\\qquad \\mathbf{A}=\\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\\\ a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\\\ a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}, \\qquad \\mathbf{p}=\\begin{bmatrix}x\\\\y\\\\z\\\\w\\end{bmatrix}, \\] a matriz \\(\\mathbf{A}\\) representa uma transformação linear no \\(\\mathbb{R}^4\\) e uma transformação afim no \\(\\mathbb{R}^3\\). A transformação afim preserva a operação de combinação afim, isto é, \\[ T(aP+(1-a)Q)=aT(P)+(1-a)T(Q) \\] para quaisquer pontos \\(P\\) e \\(Q\\), e qualquer escalar \\(a \\in [0,1]\\). Assim como a transformação linear transforma espaços vetoriais, a transformação afim de um ponto \\(\\mathbf{p}\\) para \\(\\mathbf{p&#39;}\\) equivale à transformação do quadro de \\(\\mathbf{p}\\) no quadro de \\(\\mathbf{p}&#39;\\). Com a matriz de transformação afim, conseguimos representar tanto as transformações de espaços vetoriais quanto as transformações que envolvem deslocamento de pontos. Agora podemos representar o deslocamento \\(\\mathbf{p&#39;}=\\mathbf{p}+\\mathbf{t}\\) através de uma operação matricial: \\[ \\mathbf{p}&#39;=\\mathbf{A}\\mathbf{p}\\\\ \\\\ \\begin{bmatrix}x+t_x\\\\y+t_y\\\\z+tz\\\\1\\end{bmatrix}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix}x\\\\y\\\\z\\\\1\\end{bmatrix}. \\] Em \\(\\mathbf{p}=\\begin{bmatrix}x &amp; y &amp; z &amp; w\\end{bmatrix}^T\\), a coordenada \\(w\\) é chamada de coordenada homogênea. A escolha de fazer \\(w=1\\) para pontos e \\(w=0\\) para vetores permite diferenciar, sem ambiguidades, as operações de adição de vetor com vetor, diferença entre pontos, e adição de ponto com vetor: Na adição de vetor com vetor, o resultado é um vetor (coordenada \\(w=0\\)): \\[ \\begin{align} \\mathbf{u}+\\mathbf{v}&amp;=\\mathbf{w},\\\\ \\\\ \\begin{bmatrix}u_x\\\\u_y\\\\u_z\\\\0\\end{bmatrix}+ \\begin{bmatrix}v_x\\\\v_y\\\\v_z\\\\0\\end{bmatrix}&amp;= \\begin{bmatrix}u_x+v_x\\\\u_y+v_y\\\\u_z+v_z\\\\0\\end{bmatrix}. \\end{align} \\] Na diferença entre pontos, o resultado é um vetor (coordenada \\(w=0\\)): \\[ \\begin{align} \\mathbf{p}-\\mathbf{q}&amp;=\\mathbf{u},\\\\ \\\\ \\begin{bmatrix}p_x\\\\p_y\\\\p_z\\\\1\\end{bmatrix}- \\begin{bmatrix}q_x\\\\q_y\\\\q_z\\\\1\\end{bmatrix}&amp;= \\begin{bmatrix}p_x-q_x\\\\p_y-q_y\\\\p_z-q_z\\\\0\\end{bmatrix}. \\end{align} \\] Na adição de ponto com vetor, o resultado é um ponto (coordenada \\(w=1\\)): \\[ \\begin{align} \\mathbf{p}+\\mathbf{u}&amp;=\\mathbf{q},\\\\ \\\\ \\begin{bmatrix}p_x\\\\p_y\\\\p_z\\\\1\\end{bmatrix}+ \\begin{bmatrix}u_x\\\\u_y\\\\u_z\\\\0\\end{bmatrix}&amp;= \\begin{bmatrix}p_x+u_x\\\\p_y+u_y\\\\p_z+u_z\\\\1\\end{bmatrix}. \\end{align} \\] Coordenadas homogêneas \\((x,y,z,w)\\) podem ser convertidas de volta para coordenadas cartesianas \\((x&#39;,y&#39;,z&#39;)\\) do espaço euclidiano 3D através da divisão de \\(x\\), \\(y\\), \\(z\\) por \\(w\\): \\[ (x&#39;, y&#39;, z&#39;) = \\left(\\frac{x}{w}, \\frac{y}{w}, \\frac{z}{w}\\right). \\] Assim, um ponto \\(\\mathbf{p}\\) em coordenadas homogêneas, \\[ \\mathbf{p}=\\begin{bmatrix}x \\\\ y \\\\ z \\\\ 1\\end{bmatrix}, \\] corresponde, em coordenadas cartesianas, ao ponto \\[ \\mathbf{p}&#39;=\\begin{bmatrix}x \\\\ y \\\\ z\\end{bmatrix}=\\begin{bmatrix}x/1 \\\\ y/1 \\\\ z/1\\end{bmatrix}. \\] Em transformações afins expressas de forma homogênea, o valor de \\(w\\) será sempre \\(0\\) ou \\(1\\). Entretanto, em matrizes de transformação projetiva, \\(w\\) poderá assumir outros valores. Transformações projetivas serão abordadas no próximo capítulo. Entretanto, perceba que a divisão por \\(w\\) faz com que um ponto \\((x&#39;,y&#39;,z&#39;)\\) do espaço euclidiano 3D corresponda a infinitos pontos no espaço de dimensão extra (4D). Em particular, os pontos \\((sx,sy,sz,sw)\\), onde \\(s \\neq 0\\) e \\(w \\neq 0\\), correspondem ao mesmo ponto \\((x&#39;,y&#39;,z&#39;)\\) do espaço euclidiano: \\[ (x&#39;, y&#39;, z&#39;) = \\left(\\frac{sx}{sw}, \\frac{sy}{sw}, \\frac{sz}{sw}\\right) = \\left(\\frac{x}{w}, \\frac{y}{w}, \\frac{z}{w}\\right). \\] Em outras palavras, os pontos \\((sx,sy,sz,sw)\\) do \\(\\mathbb{R}^4\\) são projetados em um mesmo ponto \\((x&#39;,y&#39;,z&#39;)\\) do \\(\\mathbb{R}^3\\). Esse comportamento será útil para simular o efeito de diminuição do tamanho de objetos em uma projeção perspectiva. Em particular, note que: Se um objeto é formado por pontos com coordenada homogênea \\(w &gt; 1\\), o objeto diminui de tamanho após a conversão para o espaço euclidiano; Se um objeto é formado por pontos com coordenadas homogênea \\(0 \\leq w &lt; 1\\), o objeto aumenta de tamanho após a conversão para o espaço euclidiano. "],["concat.html", "8.3 Concatenação de transformações", " 8.3 Concatenação de transformações Podemos expressar uma sequência, composição ou concatenação de transformações através de um produto matricial. Por exemplo, a transformação de um ponto (ou vetor) \\(\\mathbf{p}\\) por \\(\\mathbf{A}\\), e em seguida por \\(\\mathbf{B}\\), e então por \\(\\mathbf{C}\\), pode ser escrita como: \\[\\mathbf{p}&#39;=\\mathbf{C}(\\mathbf{B}(\\mathbf{A}\\mathbf{p})),\\] Como a multiplicação entre matrizes é associativa, podemos remover os parênteses: \\[\\mathbf{p}&#39;=\\mathbf{C}\\mathbf{B}\\mathbf{A}\\mathbf{p}.\\] Observação Lembre-se que, em geral, o produto matricial não é comutativo: \\[\\mathbf{CBA}\\neq\\mathbf{ABC}.\\] Na expressão \\(\\mathbf{p}&#39;=\\mathbf{C}\\mathbf{B}\\mathbf{A}\\mathbf{p}\\), a ordem de aplicação das transformações é determinada pela leitura da direita para a esquerda: Em 1º lugar, aplica-se a transformação representada pela matriz \\(\\mathbf{A}\\). Em 2º lugar, aplica-se a transformação representada pela matriz \\(\\mathbf{B}\\). Por último, a transformação representada pela matriz \\(\\mathbf{C}\\). Se quisermos ler a ordem das transformações da esquerda para a direita, precisamos antes calcular a transposta da expressão: \\[ \\begin{align} \\mathbf{p}&#39;^T&amp;=(\\mathbf{C}\\mathbf{B}\\mathbf{A}\\mathbf{p})^T\\\\ &amp;=\\mathbf{p}^T\\mathbf{A}^T\\mathbf{B}^T\\mathbf{C}^T. \\end{align} \\] Observe que, neste caso, \\(\\mathbf{p}^T\\) é uma matriz linha multiplicada à esquerda (pré-multiplicação) da matriz de transformação. Como nossa convenção neste curso é usar representações de pontos e vetores como matrizes coluna multiplicadas à direita (pós-multiplicação), usaremos sempre a expressão original \\(\\mathbf{p}&#39;=\\mathbf{C}\\mathbf{B}\\mathbf{A}\\mathbf{p}\\). No caso geral, se um ponto ou vetor é representado por uma matriz coluna \\(\\mathbf{p}\\), então a expressão \\[\\mathbf{p}&#39;=\\mathbf{A}_k \\mathbf{A}_{k-1}\\dots\\mathbf{A}_1 \\mathbf{p}\\] representa a transformação do ponto/vetor por uma sequência de transformações na ordem \\[\\mathbf{A}_1, \\mathbf{A}_2, \\dots, \\mathbf{A}_k.\\] Se for necessário aplicar uma mesma sequência de transformações a diferentes pontos ou vetores, é desejável primeiramente armazenar o resultado da multiplicação das matrizes de transformação em uma única matriz. Por exemplo, \\[ \\mathbf{M}=\\mathbf{A}_k \\mathbf{A}_{k-1}\\dots\\mathbf{A}_1, \\] onde \\(\\mathbf{M}\\) representa as transformações na ordem \\(\\mathbf{A}_1, \\mathbf{A}_2, \\dots, \\mathbf{A}_k\\) e pode ser utilizada para transformar quantos pontos/vetores forem necessários: \\[ \\mathbf{v}_1&#39;=\\mathbf{M}\\mathbf{v}_1,\\\\ \\mathbf{v}_2&#39;=\\mathbf{M}\\mathbf{v}_2,\\\\ \\vdots \\] A malha de triângulos de um modelo geométrico pode ser composta por milhares de vértices, e a transformação de um modelo exige a transformação da posição de todos os seus vértices. Assim, a concatenação de transformações em uma única matriz aumenta a eficiência do processamento geométrico. "],["transforms.html", "8.4 Transformações", " 8.4 Transformações Nesta seção definiremos as matrizes de transformação em coordenadas homogêneas que correspondem às principais transformações afins utilizadas no pipeline de renderização. Identidade A transformação de identidade é a transformação que mapeia um ponto a ele mesmo: \\[ \\mathbf{p}&#39;=\\mathbf{p}. \\] É representada por uma matriz identidade: \\[ \\mathbf{I}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\] Assim, \\[ \\mathbf{p}&#39;=\\mathbf{I}\\mathbf{p}=\\mathbf{p}. \\] Translação Translação é a transformação afim de deslocamento de um ponto \\(\\mathbf{p}\\) por um vetor \\(\\mathbf{t}\\): \\[ \\mathbf{p}&#39;=\\mathbf{p}+\\mathbf{t} \\] \\[ \\begin{bmatrix} x&#39; \\\\ y&#39; \\\\ z&#39; \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}+ \\begin{bmatrix} t_x \\\\ t_y \\\\ t_z \\\\ 0 \\end{bmatrix}. \\] A figura 8.1 ilustra o resultado da translação de todos os pontos de um cubo centralizado na origem. Figura 8.1: Translação. A matriz de translação é definida como \\[ \\mathbf{T}=\\mathbf{T}(\\mathbf{t})= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\] Assim, \\[ \\mathbf{p}&#39;=\\mathbf{T}\\mathbf{p} \\] \\[ \\begin{bmatrix} x+t_x\\\\ y+t_y\\\\ z+t_z\\\\ 1\\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\end{bmatrix}. \\] A inversa da translação é o deslocamento de \\(\\mathbf{p}\\) no sentido inverso do vetor de deslocamento: \\[ \\mathbf{T}^{-1}(\\mathbf{t})=\\mathbf{T}(-\\mathbf{t}). \\] Note que a transformação de translação não altera o formato do objeto. O objeto deslocado continua com as mesmas proporções. Uma transformação que, como a translação, preserva a distância entre todos os pontos do objeto transformado, é chamada de transformação de corpo rígido. Escala A escala é um tipo de transformação linear que faz com que um objeto aumente ou diminua de tamanho de acordo com fatores de escala em \\(x\\), \\(y\\) e \\(z\\). Desse modo, a escala não é uma transformação de corpo rígido. A transformação de escala é obtida multiplicando cada coordenada \\((x,y,z)\\) de um ponto \\(\\mathbf{p}\\) pelos escalares \\((s_x, s_y, s_z)\\): \\[ \\begin{align} x&#39; &amp;= s_x x\\\\ y&#39; &amp;= s_y y\\\\ z&#39; &amp;= s_z z. \\end{align} \\] Se os fatores de escala forem todos iguais (\\(s_x=s_y=s_z\\)), temos uma escala uniforme pois o objeto é redimensionado por igual em todas direções. A figura 8.2 ilustra o resultado da escala uniforme de cada ponto de um cubo centralizado na origem. Como \\(s_x=s_y=s_z=2\\), o objeto dobra de tamanho em cada dimensão. Figura 8.2: Escala uniforme sobre um objeto centralizado na origem. A origem do quadro é o ponto fixo da transformação, isto é, é o ponto que não é afetado pela escala. Observe, na figura 8.3, a escala uniforme de um cubo que não está centralizado na origem. O vértice que coincide com a origem é o único ponto que permanece inalterado. Pontos na origem continuam na origem após a escala. Figura 8.3: Escala uniforme sobre um objeto não centralizado na origem. Antes da aplicação da transformação de escala, é frequentemente desejável centralizar o objeto na origem ou fazer com que pelo menos a base do objeto fique centralizada na origem, como no modelo mostrado na figura 8.4. Figura 8.4: Escala em objeto com base centralizada na origem. Se o objeto não estiver centralizado na origem, a escala poderá deslocar o objeto de forma indireta. Por exemplo, se um cubo unitário estiver centralizado no ponto \\((10,10,10)\\), a escala com \\(s_x=s_y=s_z=2\\) dobrará o tamanho do cubo em cada dimensão, como esperado. Porém, o cubo agora estará centralizado no ponto \\((20,20,20)\\), o que provavelmente não é o que se quer. Se os fatores de escala estão no intervalo \\([0, 1)\\), o objeto diminui de tamanho. A figura 8.5 mostra o resultado de uma escala uniforme que diminui o tamanho do objeto. Como \\(s_x=s_y=s_z=0.5\\), o objeto resultante tem \\(50\\%\\) do tamanho original em cada dimensão. Figura 8.5: Escala uniforme com fatores de escala menores que 1. Se os fatores de escala não são iguais, o resultado é uma escala não uniforme. Na figura 8.6, o cubo triplica de tamanho na direção \\(x\\) (\\(s_x=3\\)), mantém o tamanho na direção \\(y\\) (\\(s_y=1\\)), e diminui o tamanho pela metade em \\(z\\) (\\(s_z=0.5\\)). Figura 8.6: Escala não uniforme. Em resumo, se \\(s\\) é um fator de escala (\\(s_x\\), \\(s_y\\) ou \\(s_z\\)): \\(0 \\leq s &lt; 1\\) faz o objeto diminuir de tamanho na direção correspondente. \\(s = 1\\) mantém o tamanho do objeto. \\(s &gt; 1\\) faz o objeto aumentar de tamanho na direção correspondente. Se o sinal de \\(s\\) é negativo, o resultado é uma reflexão na direção correspondente. A figura 8.7 ilustra o resultado da reflexão em \\(x\\) e \\(y\\) sem alteração do tamanho do objeto (\\(|s|=1\\)). Figura 8.7: Reflexão. A matriz de escala é definida como \\[ \\mathbf{S}=\\mathbf{S}(s_x,s_y,s_z)= \\begin{bmatrix} s_x &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; s_y &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; s_z &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\] Assim, \\[ \\mathbf{p}&#39;=\\mathbf{S}\\mathbf{p} \\] \\[ \\begin{bmatrix} s_x x\\\\ s_y y\\\\ s_z z\\\\ 1\\end{bmatrix} = \\begin{bmatrix} s_x &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; s_y &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; s_z &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\end{bmatrix}. \\] A inversa é a escala pelo valor recíproco dos fatores de escala: \\[ \\mathbf{S}^{-1}(s_x,s_y,s_z) = \\mathbf{S}\\left(\\frac{1}{s_x},\\frac{1}{s_y},\\frac{1}{s_z}\\right) \\] Assim, se um objeto teve seu tamanho dobrado (\\(s=2\\)), para voltar ao tamanho original devemos diminuir seu tamanho pela metade (\\(s=1/2=0.5\\)). Rotação A rotação é um tipo de transformação linear que produz uma movimentação radial em torno de um ponto ou eixo de rotação. A rotação é uma transformação de corpo rígido, pois não altera as distâncias entre os pontos do objeto rodado. Para simplificar, vamos primeiramente definir uma rotação no plano cartesiano e depois estender o conceito para o espaço tridimensional. Um ponto \\(P=(x,y)\\) é rodado em torno da origem por um ângulo \\(\\theta\\) no sentido anti-horário, resultando em um ponto \\(P&#39;=(x&#39;,y&#39;)\\) como mostra a figura 8.8. Figura 8.8: Rotação no plano. Podemos determinar a transformação que leva \\(P\\) a \\(P&#39;\\) através da representação dos pontos em coordenadas polares: \\[ \\begin{align} x &amp;= r \\cos \\phi,\\\\ y &amp;= r \\sin \\phi,\\\\ \\\\ x&#39; &amp;= r \\cos (\\phi + \\theta),\\\\ y&#39; &amp;= r \\sin (\\phi + \\theta).\\\\ \\end{align} \\] Usando a soma de cossenos, \\[ \\begin{align} x&#39; &amp;= r \\cos (\\phi + \\theta)\\\\ &amp;= r \\cos \\phi \\cos \\theta - r\\sin\\phi\\sin\\theta,\\\\ y&#39; &amp;= r \\sin (\\phi + \\theta)\\\\ &amp;= r \\sin \\phi \\cos \\theta + r\\cos\\phi\\sin\\theta. \\end{align} \\] Substituindo por \\(x\\) e \\(y\\), obtemos o resultado: \\[ \\begin{align} x&#39; &amp;= x \\cos \\theta - y \\sin \\theta,\\\\ y&#39; &amp;= y \\cos \\theta + x \\sin \\theta. \\end{align} \\] Em notação matricial: \\[ \\begin{bmatrix} x&#39;\\\\ y&#39;\\end{bmatrix} = \\begin{bmatrix} \\cos \\theta &amp; -\\sin \\theta \\\\ \\sin \\theta &amp; \\phantom{-}\\cos \\theta \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\end{bmatrix}. \\] A matriz \\[ \\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos \\theta &amp; -\\sin \\theta \\\\ \\sin \\theta &amp; \\phantom{-}\\cos \\theta \\end{bmatrix} \\] representa a transformação de rotação em torno da origem por um ângulo \\(\\theta\\) no sentido anti-horário. Rotação 3D No espaço tridimensional, a rotação ocorre em torno de um eixo de referência. Vamos derivar as transformações de rotação em torno dos três eixos do sistema de coordenadas cartesiano orientado segundo a regra da mão direita (figura 8.9). Figura 8.9: Sistema de coordenadas baseado na regra da mão direita. Um ponto \\(P=(x,y,z)\\) é rodado em torno do eixo \\(z\\) por um ângulo \\(\\theta\\) no sentido anti-horário, resultando em um ponto \\(P&#39;=(x&#39;,y&#39;,z&#39;)\\), como mostra a figura 8.10. Figura 8.10: Rotação em torno de \\(z\\). Pela regra da mão direita, é como se o eixo \\(z\\) positivo na figura 8.10 estivesse saindo da tela. Assim, as coordenadas \\(x\\) e \\(y\\) mudam como na rotação 2D, e a coordenação \\(z\\) não é modificada: \\[ \\begin{align} x&#39; &amp;= x \\cos \\theta - y \\sin \\theta,\\\\ y&#39; &amp;= y \\cos \\theta + x \\sin \\theta,\\\\ z&#39; &amp;= z. \\end{align} \\] A figura 8.11 ilustra o resultado da rotação em \\(\\pi/6\\) radianos (\\(30^{\\circ}\\)) em torno do eixo \\(z\\), aplicada sobre um cubo centralizado na origem. Como o ângulo é positivo, o objeto é rodado no sentido anti-horário. Figura 8.11: Rotação sobre um objeto centralizado na origem. A figura 8.12 mostra a rotação em \\(\\pi/6\\) radianos em torno do eixo \\(z\\) sobre um cubo não centralizado na origem. Observe que todos os pontos ao longo do eixo \\(z\\) permanecem inalterados. De fato, na rotação 3D, todos os pontos ao longo do eixo de rotação são pontos fixos. Figura 8.12: Rotação sobre um objeto não centralizado na origem. Podemos obter a rotação em torno dos outros eixos através da substituição cíclica das coordenadas \\(x\\), \\(y\\) e \\(z\\) nas expressões de rotação em torno de \\(z\\), segundo a ordem mostrada na figura 8.13. Figura 8.13: Ordem cíclica de substituição das coordenadas. Assim, a rotação em torno do eixo \\(x\\) resultará em: \\[ \\begin{align} y&#39; &amp;= y \\cos \\theta - z \\sin \\theta,\\\\ z&#39; &amp;= z \\cos \\theta + y \\sin \\theta,\\\\ x&#39; &amp;= x. \\end{align} \\] A rotação em torno do eixo \\(y\\) é obtida através de mais uma substituição cíclica das coordenadas nas expressões acima: \\[ \\begin{align} z&#39; &amp;= z \\cos \\theta - x \\sin \\theta,\\\\ x&#39; &amp;= x \\cos \\theta + z \\sin \\theta,\\\\ y&#39; &amp;= y. \\end{align} \\] As matrizes de rotação em torno dos eixos \\(x\\), \\(y\\) e \\(z\\) ficam como a seguir: \\[ \\mathbf{R_x}(\\theta)= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos \\theta &amp; -\\sin \\theta &amp; 0 \\\\ 0 &amp; \\sin \\theta &amp; \\phantom{-}\\cos \\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix},\\\\ \\mathbf{R_y}(\\theta)= \\begin{bmatrix} \\cos \\theta &amp; 0 &amp; \\sin \\theta &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -\\sin \\theta &amp; 0 &amp; \\cos \\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix},\\\\ \\mathbf{R_z}(\\theta)= \\begin{bmatrix} \\cos \\theta &amp; -\\sin \\theta &amp; 0 &amp; 0 \\\\ \\sin \\theta &amp; \\phantom{-}\\cos \\theta &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\] A matriz inversa de uma rotação por um ângulo \\(\\theta\\) é simplesmente a matriz de rotação pelo mesmo eixo, mas pelo ângulo \\(-\\theta\\): \\[ \\mathbf{R_x}(\\theta)^{-1}=\\mathbf{R_x}(-\\theta),\\\\ \\mathbf{R_y}(\\theta)^{-1}=\\mathbf{R_y}(-\\theta),\\\\ \\mathbf{R_z}(\\theta)^{-1}=\\mathbf{R_z}(-\\theta). \\] Além disso, as matrizes de rotação são matrizes ortogonais. Desse modo, sua inversa é sua transposta: \\[ \\mathbf{R_x}(\\theta)^{-1}=\\mathbf{R_x}(\\theta)^T,\\\\ \\mathbf{R_y}(\\theta)^{-1}=\\mathbf{R_y}(\\theta)^T,\\\\ \\mathbf{R_z}(\\theta)^{-1}=\\mathbf{R_z}(\\theta)^T. \\] "],["glspaces.html", "8.5 Espaços do OpenGL", " 8.5 Espaços do OpenGL Vimos que, no pipeline gráfico do OpenGL, as primitivas só são renderizadas se estiverem contidas em um “volume de visão” formado por um cubo centralizado na origem, com coordenadas que vão de \\(-1\\) a \\(1\\). As coordenadas desse espaço tridimensional são chamadas de coordenadas normalizadas do dispositivo, ou NDC (figura 8.14). Figura 8.14: Volume de visão em coordenadas normalizadas do dispositivo. Observe que os eixos do NDC seguem a regra da mão esquerda, isto é, o eixo \\(z\\) positivo aponta para dentro da tela. Por uma questão de simplicidade, até agora representamos todos os objetos diretamente no NDC. Entretanto, essa abordagem é pouco flexível para a maioria das aplicações. Com frequência precisamos trabalhar com coordenadas em intervalos maiores em um sistema orientado segundo a regra da mão direita. Podemos representar mudanças de pontos entre diferentes quadros intermediários através de transformações matriciais, da forma que considerarmos mais conveniente. Só precisamos garantir que, no vertex shader, essas coordenadas serão finalmente mapeadas para o espaço homogêneo de recorte, que é o sistema de coordenadas utilizado na variável embutida gl_Position, ou diretamente para o NDC, fazendo com que a coordenada homogênea (\\(w\\)) seja sempre 1. Usaremos os seguintes quadros, nessa ordem: Espaço do objeto (local space ou object space). Espaço do mundo (world space), representando o quadro padrão. Espaço da câmera (view space, camera space ou eye space). Além desses, há os quadros utilizados durante o processamento do pipeline gráfico do OpenGL: Espaço de recorte (clip space). Espaço normalizado do dispositivo (NDC space). Espaço da janela (window space). Um modelo 3D está inicialmente no espaço do objeto. Esse é o espaço das coordenadas dos atributos dos vértices armazenados no VBO. No pipeline de renderização, os pontos/vetores do espaço local são convertidos para os espaços subsequentes através de multiplicações com matrizes de transformação (matrizes \\(4 \\times 4\\), como visto na seção anterior). A figura 8.15 mostra a sequência de transformações de pontos/vetores, do espaço do objeto ao espaço da janela. Figura 8.15: Etapas de transformação entre sistemas de coordenadas no pipeline gráfico. Nesta seção, serão abordados apenas os três primeiros espaços, que são os espaços definidos pelo usuário: Espaço do objeto; Espaço do mundo; Espaço da câmera. Os espaços restantes serão detalhados no próximo capítulo. Espaço do objeto É o espaço local no qual o modelo geométrico é definido inicialmente. Por exemplo, o modelo “Stanford Bunny” do arquivo bunny.obj (seção 7.4) foi definido em um sistema de coordenadas que segue a regra da mão direita (RHS, de right-handed coordinate system), sendo que o eixo \\(y\\) positivo aponta para cima (figura 8.16). A origem desse sistema de coordenadas é o centro da base do coelho. Além disso, as coordenadas do modelo estão na faixa \\(x \\in [-1, 0.7]\\), \\(y \\in [0, 1.6]\\), \\(z \\in [-0.5, 0.7]\\). Figura 8.16: Espaço do objeto do modelo do arquivo bunny.obj. O cubo definido no arquivo box.obj (seção 7.4) usa um sistema de coordenadas que segue a regra da mão esquerda (LHS, de left-handed coordinate system). A origem é o centro do cubo e as coordenadas variam de \\(-0.5\\) a \\(0.5\\) em cada dimensão. Figura 8.17: Espaço do objeto do modelo do arquivo box.obj. Observação Um triângulo definido em um espaço RHS tem sua orientação invertida quando renderizado sem modificações em um espaço LHS, como o NDC. No espaço RHS, o lado da frente de um triângulo no plano \\(xy\\) é o lado com orientação CCW para um observador olhando na direção de \\(z\\) negativo. Entretanto, se esse mesmo triângulo é utilizado sem modificação no NDC, o lado da frente ficará orientado no sentido CW após o mapeamento no espaço da janela, como se o observador agora olhasse na direção de \\(z\\) negativo do espaço LHS (figura 8.18). Figura 8.18: Mudança de orientação de um sistema RHS para LHS. Esse problema pode ser resolvido através da negação de cada coordenada \\(z\\) do modelo. Faremos isso na matriz de projeção, pois sempre consideraremos que o espaço do objeto é RHS. Espaço do mundo O espaço do mundo é, geralmente, o quadro padrão utilizado para dispor os diferentes objetos em um cenário virtual. O espaço do mundo segue a regra da mão direita. Por convenção, consideramos que o eixo \\(y\\) positivo aponta para cima, e o plano \\(xz\\) com altura \\(y=0\\) corresponde ao plano do “chão”. A figura 8.19 ilustra a composição de uma cena através da disposição de objetos sobre o plano \\(y=0\\) do espaço do mundo. Figura 8.19: Cena no espaço do mundo. Em uma cena composta por vários objetos, a transformação que posiciona e orienta um objeto na cena é definida através de uma matriz de modelo (model matrix). A matriz de modelo é uma concatenação de transformações de rotação, escala e translação que representa uma mudança de quadro: do espaço do objeto para o espaço do mundo. Cada objeto de uma cena deve ter a sua própria matriz de modelo. Se o objeto foi definido originalmente no quadro padrão, então sua matriz de modelo é uma matriz identidade. Na cena da figura 8.19, as bases cuboides compartilham o mesmo modelo de um cubo mostrado na figura 8.20, mas cada um usa uma matriz de modelo diferente, pois cada cuboide está numa posição/orientação/escala diferente na cena. Figura 8.20: Cubo unitário centralizado na origem. Por exemplo, para o objeto cuboide que serve de base para o coelho, a matriz de modelo é a seguinte concatenação de transformações: \\[\\mathbf{M}=\\mathbf{T}\\left(-3,\\frac{1}{2},-\\frac{1}{2}\\right).\\mathbf{R}_y\\left(\\frac{7\\pi}{36}\\right).\\mathbf{S}\\left(\\frac{5}{4}, \\frac{1}{2}, \\frac{5}{4}\\right). \\] A matriz representa a aplicação das transformações na ordem de leitura da direita para a esquerda (figura 8.21): Escala de \\(s_x=1.25\\), \\(s_y=0.5\\), \\(s_z=1.25\\); Rotação por \\(7\\pi/36\\) radianos (\\(35^{\\circ}\\)) em torno de \\(y\\); Translação por \\(t_x=-3\\), \\(t_y=0.5\\), \\(t_z=-0.5\\). Figura 8.21: Sequência de transformações de uma matriz de modelo. Se a matriz de modelo é a matriz que converte pontos no quadro local para pontos no quadro do mundo, então a inversa da matriz de modelo faz o mapeamento inverso, isto é, do quadro do mundo para o quadro local. No caso da base cuboide, essa transformação inversa é \\[ \\begin{align} \\mathbf{M}^{-1}&amp;=\\left(\\mathbf{T}\\left(-3,\\frac{1}{2},-\\frac{1}{2}\\right).\\mathbf{R}_y\\left(\\frac{7\\pi}{36}\\right).\\mathbf{S}\\left(\\frac{5}{4}, \\frac{1}{2}, \\frac{5}{4}\\right)\\right)^{-1}\\\\ &amp;=\\mathbf{S}\\left(\\frac{5}{4}, \\frac{1}{2}, \\frac{5}{4}\\right)^{-1}.\\mathbf{R}_y\\left(\\frac{7\\pi}{36}\\right)^{-1}.\\mathbf{T}\\left(-3,\\frac{1}{2},-\\frac{1}{2}\\right)^{-1}\\\\ &amp;=\\mathbf{S}\\left(\\frac{4}{5}, 2, \\frac{4}{5}\\right).\\mathbf{R}_y\\left(-\\frac{7\\pi}{36}\\right).\\mathbf{T}\\left(3,-\\frac{1}{2},\\frac{1}{2}\\right). \\end{align} \\] Note que as transformações concatenadas da matriz inversa desfazem cada uma das transformações da figura 8.21, no sentido contrário (da etapa 3 até o modelo original). Espaço da câmera O espaço da câmera representa o ponto de vista da câmera virtual posicionada no mundo, isto é, o ponto de vista de um observador em primeira pessoa dentro da cena. No espaço da câmera, a câmera está posicionada na origem, olhando na direção do eixo \\(z\\) negativo. As coordenadas de todos os objetos da cena são descritos em relação à câmera. A figura 8.22 ilustra o quadro de uma câmera em relação ao mundo. A direção de visão é representada pela seta tracejada, que é a direção do eixo \\(z\\) negativo do quadro da câmera. Figura 8.22: Quadro da câmera em relação ao quadro do mundo. A figura 8.23 ilustra como a cena é vista a partir da câmera, e como a câmera vê o quadro do mundo. Figura 8.23: Quadro do mundo do ponto de vista da câmera. A transformação que transforma pontos do espaço do mundo para o espaço da câmera é definida através de uma matriz de visão (view matrix). Essa matriz é uma concatenação de rotações e uma translação. Para construir uma matriz de visão, precisamos de uma posição e uma orientação. A posição é a localização da câmera no espaço do mundo. Do ponto de vista da câmera, é a origem (ponto \\((0,0,0)\\)) de seu quadro. Essa informação fica armazenada na parte de translação da matriz de visão (parte \\(3 \\times 1\\) da quarta coluna) A orientação é uma base ortonormal, e corresponde à parte \\(3 \\times 3\\) superior da matriz de visão (mudança de base). Descreveremos na seção 8.6 o processo de construção de uma matriz de visão a partir da posição da câmera, a posição para onde a câmera está olhando, e um vetor de direção para cima, que geralmente é o vetor \\(\\hat{\\mathbf{j}}=\\begin{bmatrix}0&amp;1&amp;0\\end{bmatrix}^T\\) do \\(\\mathbb{R}^3\\). Concatenação das matrizes de modelo e visão Sempre que um objeto for renderizado, a posição de cada um de seus vértices precisa ser transformada. Isso pode ser feito em duas etapas: Conversão do espaço local para o espaço do mundo: \\[\\mathbf{p}&#39;=\\mathbf{M}_{\\textrm{model}}.\\mathbf{p},\\] onde \\(\\mathbf{M}_{\\textrm{model}}\\) é a matriz de modelo do objeto que está sendo renderizado. Conversão do espaço do mundo para o espaço da câmera: \\[\\mathbf{p}&#39;&#39;=\\mathbf{M}_{\\textrm{view}}.\\mathbf{p}&#39;,\\] onde \\(\\mathbf{M}_{\\textrm{view}}\\) é a matriz de visão. A matriz de visão deve ser a mesma para todos os objetos da cena renderizada. É comum combinar as duas transformações em uma só matriz modelo-visão: \\[ \\mathbf{M}_{\\textrm{modelview}}=\\mathbf{M}_{\\textrm{view}}.\\mathbf{M}_{\\textrm{model}}. \\] Assim, no vertex shader basta uma multiplicação matricial para transformar a posição do vértice pela matriz modelo-visão. O resultado será um ponto no espaço da câmera. Observação Após a transformação do ponto para o espaço da câmera, é necessário aplicar ainda uma transformação projetiva através de uma matriz de projeção \\(\\mathbf{M}_{\\textrm{proj}}\\). A matriz de projeção converte um ponto do espaço da câmera para o espaço homogêneo de recorte, que é o espaço esperado pela variável embutida gl_Position no vertex shader. A transformação completa fica como a seguir: \\[ \\mathbf{p}&#39;=\\mathbf{M}_{\\textrm{proj}}.\\mathbf{M}_{\\textrm{view}}.\\mathbf{M}_{\\textrm{model}}.\\mathbf{p}, \\] onde \\(\\mathbf{p}\\) é a entrada do vertex shader, isto é, a posição do vértice no formato \\(\\begin{bmatrix}x&amp;y&amp;z&amp;1\\end{bmatrix}^T\\); \\(\\mathbf{p}&#39;\\) é a posição transformada no formato \\(\\begin{bmatrix}x&#39;&amp;y&#39;&amp;z&#39;&amp;w\\end{bmatrix}^T\\). Essa é a posição que será copiada para gl_Position. Os conceitos sobre transformações de projeção e o processo de construir a matriz \\(\\mathbf{M}_{\\textrm{proj}}\\) serão abordados no próximo capítulo. "],["lookat.html", "8.6 Câmera LookAt", " 8.6 Câmera LookAt Câmera LookAt é o nome dado ao quadro de câmera virtual \\(\\{P_{\\textrm{eye}}, \\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\) construído a partir das seguintes informações: Um ponto \\(P_\\textrm{eye}\\) que corresponde à posição da câmera no espaço do mundo; Um ponto \\(P_\\textrm{at}\\) que corresponde à posição aonde a câmera está olhando, também no espaço do mundo1. Um vetor \\(\\mathbf{v}_\\textrm{up}\\) utilizado para indicar a direção “para cima” da câmera. Geralmente esse vetor é a direção \\((0,1,0)\\). A figura 8.24 ilustra esses elementos, incluindo os vetores \\(\\{\\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\) que formam a base ortonormal da câmera. Figura 8.24: Quadro da câmera, representado em relação ao mundo. O sistema de coordenadas da câmera segue a regra da mão direita. Note que a câmera está olhando na direção \\(-\\hat{\\mathbf{n}}\\) no espaço do mundo, que corresponde à direção do eixo \\(z\\) negativo da câmera. Inicialmente, não temos a base ortonormal \\(\\{\\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\). Só temos as seguintes informações (ilustradas na figura 8.25): A posição da câmera, \\(P_\\textrm{eye}\\); A posição para onde a câmera deve ser direcionada, \\(P_\\textrm{at}\\); O vetor \\(\\mathbf{v}_\\textrm{up}\\), que vamos considerar como sendo o vetor \\((0,1,0)\\). Figura 8.25: Parâmetros de uma câmera LookAt. Através dessas informações construiremos a base \\(\\{\\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\). Com a base e o ponto de referência (\\(P_{\\textrm{eye}}\\)) temos o quadro completo para criar a matriz de visão \\(\\mathbf{M}_{\\textrm{view}}\\). Como vimos anteriormente, a matriz de visão representa uma mudança de quadro: do espaço do mundo para o espaço da câmera. Construindo o vetor n Para construir a base ortonormal, primeiro fazemos \\(P_{\\textrm{eye}}-P_{\\textrm{at}}\\) para obter o vetor que aponta na direção contrária da direção de visão. Esse vetor é então normalizado para obter \\(\\hat{\\mathbf{n}}\\) (figura 8.26): \\[ \\hat{\\mathbf{n}}=\\frac{P_{\\textrm{eye}}-P_{\\textrm{at}}}{|P_{\\textrm{eye}}-P_{\\textrm{at}}|}. \\] Figura 8.26: Construção do vetor n da câmera LookAt. Note que \\(\\hat{\\mathbf{n}}\\) está sendo representado em coordenadas do espaço do mundo. Em relação à câmera, \\(\\hat{\\mathbf{n}}\\) torna-se o vetor \\(\\hat{\\mathbf{k}}=(0,0,1)\\), isto é, a direção do eixo \\(z\\) positivo da câmera (direção para trás da câmera). Construindo o vetor u Agora que temos \\(\\hat{\\mathbf{n}}\\), o segundo passo é calcular o produto vetorial \\(\\mathbf{v}_{\\textrm{up}} \\times \\hat{\\mathbf{n}}\\) e normalizar o resultado. Com isso obtemos o vetor \\(\\hat{\\mathbf{u}}\\) perpendicular ao plano formado por \\(\\mathbf{v}_{\\textrm{up}}\\) e \\(\\hat{\\mathbf{n}}\\) (figura 8.27): \\[ \\hat{\\mathbf{u}}=\\frac{\\mathbf{v}_{\\textrm{up}} \\times \\hat{\\mathbf{n}}}{|\\mathbf{v}_{\\textrm{up}} \\times \\hat{\\mathbf{n}}|}. \\] Figura 8.27: Construção do vetor u da câmera LookAt. No quadro da câmera, \\(\\hat{\\mathbf{u}}\\) corresponde ao vetor \\(\\hat{\\mathbf{i}}=(1,0,0)\\), isto é, a direção do eixo \\(x\\) da câmera (direção à direita). Construindo o vetor v Embora \\(\\hat{\\mathbf{u}}\\) seja perpendicular a \\(\\hat{\\mathbf{n}}\\) e a \\(\\mathbf{v}_{\\textrm{up}}\\), ainda não temos uma base ortonormal pois \\(\\mathbf{v}_{\\textrm{up}}\\) não é necessariamente perpendicular a \\(\\hat{\\mathbf{n}}\\). Na figura 8.27, \\(\\mathbf{v}_{\\textrm{up}}\\) e \\(\\hat{\\mathbf{n}}\\) formam um ângulo menor que \\(90^{\\circ}\\). Para obter um vetor que seja mutuamente ortogonal a \\(\\hat{\\mathbf{n}}\\) e \\(\\hat{\\mathbf{u}}\\), basta calcularmos o produto vetorial \\(\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{u}}\\). O resultado é \\(\\hat{\\mathbf{v}}\\) (figura 8.28) que já está normalizado pois \\(\\hat{\\mathbf{n}}\\) e \\(\\hat{\\mathbf{u}}\\) também têm comprimento 1. \\[ \\hat{\\mathbf{v}}=\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{u}}. \\] Figura 8.28: Construção do vetor v da câmera LookAt. Note que, em relação à câmera, \\(\\hat{\\mathbf{v}}\\) corresponde ao vetor \\(\\hat{\\mathbf{j}}=(0,1,0)\\), isto é, o eixo \\(y\\) da câmera (direção para cima). Os vetores \\(\\{\\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\) formam a base ortonormal da câmera, representados em relação ao espaço do mundo. Construindo a matriz de visão Para a construção da matriz de mudança de quadro, vamos relembrar primeiro a matriz de mudança de base. A matriz com colunas formadas pelos vetores \\(\\{T(\\mathbf{\\hat{\\mathbf{i}}}),T(\\mathbf{\\hat{\\mathbf{j}}}),T(\\mathbf{\\hat{\\mathbf{k}}})\\}\\) representa uma mudança da base \\(\\{\\hat{\\mathbf{i}}, \\hat{\\mathbf{j}}, \\hat{\\mathbf{k}}\\}\\) para a base transformada. A transformação \\(T\\) é uma composição de rotações (por exemplo, \\(\\mathbf{R}_z\\mathbf{R}_y\\mathbf{R}_x\\)), que tem o efeito de rodar a base original para a nova. O que temos atualmente é a base \\(\\{\\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\). Esses vetores estão representados em relação ao espaço do mundo. Se estivessem representados em relação ao espaço da câmera, a base seria \\(\\{\\hat{\\mathbf{i}}, \\hat{\\mathbf{j}}, \\hat{\\mathbf{k}}\\}\\). Então, se construirmos a matriz \\(\\mathbf{R}\\) de mudança de base, \\[ \\mathbf{R}= \\begin{bmatrix} u_{11} &amp; v_{12} &amp; n_{13} &amp; 0 \\\\ u_{21} &amp; v_{22} &amp; n_{23} &amp; 0 \\\\ u_{31} &amp; v_{32} &amp; n_{33} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}, \\] tal matriz representa a mudança do espaço da câmera para o espaço do mundo. Não é bem o que queremos. Gostaríamos da matriz que faz a transformação inversa, isto é, que converte coordenadas do mundo para a câmera. Entretanto, vamos prosseguir com \\(\\mathbf{R}\\) da forma como está. Ao final poderemos calcular a matriz inversa da transformação completa, para finalmente obter \\(\\mathbf{M}_{\\textrm{view}}\\). Com a matriz \\(\\mathbf{R}\\), a base \\(\\{\\hat{\\mathbf{i}}, \\hat{\\mathbf{j}}, \\hat{\\mathbf{k}}\\}\\) no espaço da câmera é transformada por rotações para resultar na base \\(\\{\\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\) representada no espaço do mundo. Isso é ilustrado na figura 8.29. Figura 8.29: Rotação da base representada no espaço da câmera, para a base representada no espaço do mundo. Além da base, um quadro também precisa de um ponto de referência. Esse ponto de referência é o próprio \\(P_\\textrm{eye}\\), que representa a origem \\(O\\) no espaço da câmera. \\(P_\\textrm{eye}\\) é o deslocamento necessário para mover a origem do espaço da câmera para sua posição no espaço do mundo. Em outras palavras, temos uma transformação de translação que pode ser representada pela matriz \\[ \\mathbf{T}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; P_{\\textrm{eye}_x} \\\\ 0 &amp; 1 &amp; 0 &amp; P_{\\textrm{eye}_y} \\\\ 0 &amp; 0 &amp; 1 &amp; P_{\\textrm{eye}_z} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\] Fazendo a composição das transformações, temos \\[ \\mathbf{M} = \\mathbf{T} \\mathbf{R} \\] \\[ \\mathbf{M}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; P_{\\textrm{eye}_x} \\\\ 0 &amp; 1 &amp; 0 &amp; P_{\\textrm{eye}_y} \\\\ 0 &amp; 0 &amp; 1 &amp; P_{\\textrm{eye}_z} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} u_{11} &amp; v_{12} &amp; n_{13} &amp; 0 \\\\ u_{21} &amp; v_{22} &amp; n_{23} &amp; 0 \\\\ u_{31} &amp; v_{32} &amp; n_{33} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\] A figura 8.30 ilustra como a matriz de transformação \\(\\mathbf{M}\\) converte coordenadas do espaço da câmera para o espaço do mundo, que é o equivalente a rodar a base \\(\\{\\hat{\\mathbf{i}}, \\hat{\\mathbf{j}}, \\hat{\\mathbf{k}}\\}\\) para \\(\\{\\hat{\\mathbf{u}}, \\hat{\\mathbf{v}}, \\hat{\\mathbf{n}}\\}\\) (matriz de rotação \\(\\mathbf{R}\\)), e então transladar a origem \\(O\\) para \\(P_{\\textrm{eye}}\\) (matriz de translação \\(\\mathbf{T}\\)). Figura 8.30: Mudança do espaço da câmera para o espaço do mundo. Para obter \\(\\mathbf{M}_{\\textrm{view}}\\), basta calcularmos a inversa de \\(\\mathbf{M}\\). Lembre-se que a inversa de uma matriz de rotação é a sua transposta, e a inversa da translação por \\(P_{\\textrm{eye}}\\) é a translação por \\(-P_{\\textrm{eye}}\\). Portanto, \\[ \\begin{align} \\mathbf{M}_{\\textrm{view}} &amp;= \\mathbf{M}^{-1}\\\\ &amp;= (\\mathbf{T} \\mathbf{R})^{-1}\\\\ &amp;= \\left( \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; P_{\\textrm{eye}_x} \\\\ 0 &amp; 1 &amp; 0 &amp; P_{\\textrm{eye}_y} \\\\ 0 &amp; 0 &amp; 1 &amp; P_{\\textrm{eye}_z} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} u_{11} &amp; v_{12} &amp; n_{13} &amp; 0 \\\\ u_{21} &amp; v_{22} &amp; n_{23} &amp; 0 \\\\ u_{31} &amp; v_{32} &amp; n_{33} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\right)^{-1}\\\\ &amp;= \\begin{bmatrix} u_{11} &amp; v_{12} &amp; n_{13} &amp; 0 \\\\ u_{21} &amp; v_{22} &amp; n_{23} &amp; 0 \\\\ u_{31} &amp; v_{32} &amp; n_{33} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}^{-1} \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; P_{\\textrm{eye}_x} \\\\ 0 &amp; 1 &amp; 0 &amp; P_{\\textrm{eye}_y} \\\\ 0 &amp; 0 &amp; 1 &amp; P_{\\textrm{eye}_z} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}^{-1}\\\\ &amp;= \\begin{bmatrix} u_{11} &amp; u_{21} &amp; u_{23} &amp; 0 \\\\ v_{12} &amp; v_{22} &amp; v_{33} &amp; 0 \\\\ n_{13} &amp; v_{23} &amp; n_{33} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -P_{\\textrm{eye}_x} \\\\ 0 &amp; 1 &amp; 0 &amp; -P_{\\textrm{eye}_y} \\\\ 0 &amp; 0 &amp; 1 &amp; -P_{\\textrm{eye}_z} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\\\\ &amp;= \\begin{bmatrix} u_{11} &amp; u_{21} &amp; u_{23} &amp; -\\hat{\\mathbf{u}}\\cdot P_{\\textrm{eye}} \\\\ v_{12} &amp; v_{22} &amp; v_{33} &amp; -\\hat{\\mathbf{v}}\\cdot P_{\\textrm{eye}} \\\\ n_{13} &amp; v_{23} &amp; n_{33} &amp; -\\hat{\\mathbf{n}}\\cdot P_{\\textrm{eye}} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\end{align} \\] A biblioteca GLM possui a função glm::lookAt, definida em cabeçalho glm/gtc/matrix_transform.hpp: glm::mat4 glm::lookAt(glm::vec3 const&amp; eye, glm::vec3 const&amp; center, glm::vec3 const&amp; up); glm::dmat4 glm::lookAt(glm::dvec3 const&amp; eye, glm::dvec3 const&amp; center, glm::dvec3 const&amp; up); glm::lookAt gera a matriz \\(\\mathbf{M}_{\\textrm{view}}\\) de uma câmera LookAt, dados os parâmetros \\(P_{\\textrm{eye}}\\) (eye), \\(P_{\\textrm{at}}\\) (center) e \\(\\mathbf{v}_\\textrm{up}\\) (up). Internamente, a função chama glm::lookAtRH para gerar o quadro baseado na regra da mão direita. O conteúdo dessa função é dado a seguir: template&lt;typename T, qualifier Q&gt; GLM_FUNC_QUALIFIER mat&lt;4, 4, T, Q&gt; lookAtRH(vec&lt;3, T, Q&gt; const&amp; eye, vec&lt;3, T, Q&gt; const&amp; center, vec&lt;3, T, Q&gt; const&amp; up) { vec&lt;3, T, Q&gt; const f(normalize(center - eye)); vec&lt;3, T, Q&gt; const s(normalize(cross(f, up))); vec&lt;3, T, Q&gt; const u(cross(s, f)); mat&lt;4, 4, T, Q&gt; Result(1); Result[0][0] = s.x; Result[1][0] = s.y; Result[2][0] = s.z; Result[0][1] = u.x; Result[1][1] = u.y; Result[2][1] = u.z; Result[0][2] =-f.x; Result[1][2] =-f.y; Result[2][2] =-f.z; Result[3][0] =-dot(s, eye); Result[3][1] =-dot(u, eye); Result[3][2] = dot(f, eye); return Result; } Na linha 4, f (vetor “forward”) é equivalente ao nosso \\(-\\hat{\\mathbf{n}}\\). Na linha 5, s (vetor “side”) é o nosso vetor \\(\\hat{\\mathbf{u}}\\), calculado como \\(-\\hat{\\mathbf{n}} \\times \\mathbf{v}_\\textrm{up}\\), que é o mesmo que \\(\\mathbf{v}_\\textrm{up} \\times \\hat{\\mathbf{n}}\\), seguido de uma normalização. Na linha 6, u é o nosso vetor \\(\\hat{\\mathbf{v}}\\), calculado como \\(\\hat{\\mathbf{u}} \\times -\\hat{\\mathbf{n}}\\), que é o mesmo que \\(\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{u}}\\). Nas linhas 9 a 21 é montada a matriz Result, que é a matriz \\(\\mathbf{M}_{\\textrm{view}}\\). Internamente, a GLM armazena as matrizes no formato column-major, o que significa que o primeiro índice é a coluna, e o segundo índice é a linha. Levando isso em consideração, observe que a matriz resultante é de fato: \\[ \\begin{align} \\mathbf{M}_{\\textrm{view}} &amp;= \\begin{bmatrix} u_{11} &amp; u_{21} &amp; u_{23} &amp; -\\hat{\\mathbf{u}}\\cdot P_{\\textrm{eye}} \\\\ v_{12} &amp; v_{22} &amp; v_{33} &amp; -\\hat{\\mathbf{v}}\\cdot P_{\\textrm{eye}} \\\\ n_{13} &amp; v_{23} &amp; n_{33} &amp; -\\hat{\\mathbf{n}}\\cdot P_{\\textrm{eye}} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}. \\end{align} \\] O ponto “at” também é chamado de “center” ou “target”.↩︎ "],["lookatproject.html", "8.7 LookAt na prática", " 8.7 LookAt na prática Nesta seção, seguiremos o passo a passo de desenvolvimento de uma aplicação que renderiza uma cena 3D do ponto de vista de uma câmera LookAt. A cena 3D será composta por quatro instâncias do modelo “Stanford Bunny” dispostos sobre o plano \\(xz\\) do espaço do mundo. A câmera LookAt simulará um observador em primeira pessoa. A figura 8.31 mostra o posicionamento dos objetos e a localização inicial da câmera. Figura 8.31: Objetos e elementos de cena dispostos no espaço do mundo. Na figura acima, os vetores \\(\\hat{\\mathbf{i}}\\),\\(\\hat{\\mathbf{j}}\\),\\(\\hat{\\mathbf{k}}\\) correspondem às direções dos eixos \\(x\\),\\(y\\),\\(z\\) do quadro padrão com ponto de referência na origem \\((0,0,0)\\). Os vetores \\(\\hat{\\mathbf{u}}\\),\\(\\hat{\\mathbf{v}}\\),\\(\\hat{\\mathbf{n}}\\) são os vetores de base do quadro da câmera com \\(P_0=(0, 0.5, 2.5)\\). A câmera está localizada na origem de seu quadro e está olhando na direção de seu eixo \\(z\\) negativo. O coelho vermelho está na posição \\((0,0,0)\\) do quadro padrão e tem escala de \\(10\\%\\) do tamanho original. O coelho cinza está na posição \\((-1,0,0)\\) do quadro padrão e está rodado em \\(90^{\\circ}\\) em torno do eixo \\(y\\) de seu quadro local. O coelho azul está na posição \\((1,0,0)\\) do quadro padrão e está rodado em \\(-90^{\\circ}\\) em torno do eixo \\(y\\) de seu quadro local. O coelho amarelo está na posição \\((0,0,-1)\\) do quadro padrão e está com sua orientação original. A posição e orientação da câmera podem ser modificadas através do teclado: As setas para cima/baixo (ou W/S) fazem a câmera ir para a frente e para trás ao longo da direção de visão (direção de \\(\\pm\\hat{\\mathbf{n}}\\)). Esse movimento de câmera é conhecido como dolly no jargão da cinematografia. As setas para os lados (ou A/D) fazem a câmera girar em torno de seu eixo \\(y\\) (vetor \\(\\hat{\\mathbf{v}}\\)). Esse movimento é chamado de pan. As teclas Q/E fazem a câmera deslizar para os lados (direção de \\(\\pm\\hat{\\mathbf{u}}\\)). Esse movimento é chamado de truck ou dolly lateral. Neste exemplo, a altura da câmera permanecerá sempre em \\(y=0.5\\). O resultado ficará como a seguir: Observação Para controlar a câmera usando o teclado é necessário abrir o link original e clicar na área de desenho. Desse modo a aplicação terá o foco do teclado. Configuração inicial No arquivo abcg/examples/CMakeLists.txt, inclua a linha: add_subdirectory(lookat) Crie o subdiretório abcg/examples/lookat e o arquivo abcg/examples/lookat/CMakeLists.txt com o seguinte conteúdo: project(lookat) add_executable(${PROJECT_NAME} camera.cpp ground.cpp main.cpp window.cpp) enable_abcg(${PROJECT_NAME}) Crie os arquivos camera.cpp, camera.hpp, ground.cpp, ground.hpp, main.cpp, window.cpp e window.hpp. Crie o subdiretório abcg/examples/lookat/assets. Dentro dele, crie os arquivos lookat.frag e lookat.vert. Além disso, baixe o arquivo bunny.zip e descompacte-o em assets. A estrutura de abcg/examples/lookat ficará assim: lookat/ │ CMakeLists.txt │ camera.hpp │ camera.cpp │ ground.hpp │ ground.cpp │ main.cpp │ window.hpp │ window.cpp │ └───assets/ │ bunny.obj │ lookat.frag └ lookat.vert main.cpp Exceto pelo título da janela, o conteúdo de main.cpp é o mesmo do projeto anterior: #include &quot;window.hpp&quot; int main(int argc, char **argv) { try { abcg::Application app(argc, argv); Window window; window.setOpenGLSettings({.samples = 4}); window.setWindowSettings({ .width = 600, .height = 600, .title = &quot;LookAt Camera&quot;, }); app.run(window); } catch (std::exception const &amp;exception) { fmt::print(stderr, &quot;{}\\n&quot;, exception.what()); return -1; } return 0; } lookat.vert O vertex shader ficará como a seguir: #version 300 es layout(location = 0) in vec3 inPosition; uniform vec4 color; uniform mat4 modelMatrix; uniform mat4 viewMatrix; uniform mat4 projMatrix; out vec4 fragColor; void main() { vec4 posEyeSpace = viewMatrix * modelMatrix * vec4(inPosition, 1); float i = 1.0 - (-posEyeSpace.z / 5.0); fragColor = vec4(i, i, i, 1) * color; gl_Position = projMatrix * posEyeSpace; } O atributo de entrada, inPosition, é a posição \\((x,y,z)\\) do vértice. Vamos supor que estas coordenadas estão no espaço do objeto. O atributo de saída, fragColor, é uma cor RGBA. As variáveis uniformes são utilizadas para determinar a cor do objeto (color, na linha 5) e as matrizes \\(4 \\times 4\\) de transformação geométrica (linhas 6 a 8): Matriz de modelo: modelMatrix; Matriz de visão: viewMatrix; Matriz de projeção: projMatrix. Embora ainda não tenhamos visto a fundamentação teórica sobre a construção de uma matriz de projeção, vamos utilizar essa matriz desde já. Ela será necessária para obter o efeito de perspectiva e assim manter a ilusão de que a câmera LookAt é um observador dentro de um cenário 3D. No código de main, a linha 13 transforma a posição de entrada usando as matrizes de modelo e visão. Para entendermos a ordem das transformações a partir do espaço do objeto, temos de ler os operandos da direita para a esquerda: vec4 posEyeSpace = viewMatrix * modelMatrix * vec4(inPosition, 1); Primeiro, vec4(inPosition, 1) produz a posição \\((x,y,z,1)\\), isto é, o ponto/vértice em coordenadas homogêneas que corresponde à posição \\((x,y,z)\\) no espaço do objeto. Esse vértice é transformado, através do produto matricial, pela matriz de modelo modelMatrix. A transformação pela matriz de modelo converte coordenadas do espaço do objeto para o espaço do mundo. Em seguida há uma transformação pela matriz de visão viewMatrix. A matriz de visão converte coordenadas do espaço do mundo para coordenadas do espaço da câmera. Assim, o resultado armazenado em posEyeSpace é a posição do vértice no espaço da câmera. Na linha 15, calculamos um valor i de intensidade de cor a partir da coordenada \\(z\\) do vértice no espaço da câmera: float i = 1.0 - (-posEyeSpace.z / 5.0); Lembre-se que, no espaço da câmera, a câmera está olhando na direção de seu eixo \\(z\\) negativo. Logo, do ponto de vista da câmera, todos os objetos à sua frente têm valor \\(z\\) negativo. Ao fazermos -PosEyeSpace.z, tornamos esse valor positivo, correspondendo à distância entre o vértice e a câmera ao longo do eixo \\(z\\). A ideia aqui é transformar essa distância em um valor de intensidade de cor. A intensidade será máxima (1) se o objeto estiver o mais próximo possível da câmera (isto é, se estiver na mesma posição da câmera), e mínima (0) se estiver a 5 ou mais unidades de distância na direção de visão. Na linha 16, esse valor de intensidade é utilizado para multiplicar as componentes RGB da cor color. fragColor = vec4(i, i, i, 1) * color; Assim, quanto mais longe o objeto estiver da câmera, mais escuro ele ficará. A partir da distância 5, a intensidade fica negativa, mas nesse caso o OpenGL fixa automaticamente o valor de cor para zero, pois uma cor não pode ter intensidade negativa. Na linha 18, projMatrix * posEyeSpace faz com que as coordenadas no espaço da câmera sejam convertidas para o espaço de recorte. É esse o resultado final armazenado em gl_Position: gl_Position = projMatrix * posEyeSpace; lookat.frag O conteúdo do fragment shader ficará assim: #version 300 es precision mediump float; in vec4 fragColor; out vec4 outColor; void main() { if (gl_FrontFacing) { outColor = fragColor; } else { outColor = fragColor * 0.5; } } Se o triângulo estiver orientado de frente para a câmera, a cor final do fragmento será a cor de entrada (fragColor). Caso contrário, a cor terá metade da intensidade original (a cor RGB é multiplicada por 0.5). Assim, se a câmera estiver dentro de um objeto, os triângulos serão desenhados com uma cor mais escura, pois estaremos vendo o lado de trás da malha triangular. camera.hpp Neste arquivo definiremos a classe Camera que gerenciará a câmera LookAt. O conteúdo ficará como a seguir: #ifndef CAMERA_HPP_ #define CAMERA_HPP_ #include &lt;glm/mat4x4.hpp&gt; #include &lt;glm/vec3.hpp&gt; class Camera { public: void computeViewMatrix(); void computeProjectionMatrix(glm::vec2 const &amp;size); void dolly(float speed); void truck(float speed); void pan(float speed); glm::mat4 const &amp;getViewMatrix() const { return m_viewMatrix; } glm::mat4 const &amp;getProjMatrix() const { return m_projMatrix; } private: glm::vec3 m_eye{0.0f, 0.5f, 2.5f}; // Camera position glm::vec3 m_at{0.0f, 0.5f, 0.0f}; // Look-at point glm::vec3 m_up{0.0f, 1.0f, 0.0f}; // &quot;up&quot; direction // Matrix to change from world space to camera space glm::mat4 m_viewMatrix; // Matrix to change from camera space to clip space glm::mat4 m_projMatrix; }; #endif Observe, nas linhas 20 a 22, que a classe tem todos os atributos necessários para criar o quadro de uma câmera LookAt: m_eye: posição da câmera \\((0, 0.5, 2.5)\\). m_at: posição para onde a câmera está olhando \\((0, 0.5, 0)\\). m_up: vetor de direção para cima \\((0, 1, 0)\\). Na linha 25 temos a matriz de visão (m_viewMatrix) que será calculada pela função Camera::computeViewMatrix declarada na linha 9. Na linha 28 temos a matriz de projeção (m_projMatrix) que será calculada pela função Camera::computeProjectionMatrix declarada na linha 10. As funções Camera::dolly, Camera::truck e Camera::pan serão chamadas a partir de Window em resposta à entrada do teclado. Internamente, essas funções modificarão as variáveis m_eye e m_at, fazendo a câmera mudar de posição e orientação. Camera::getViewMatrix e Camera::getProjMatrix são funções de acesso à matriz de visão e projeção. camera.cpp A definição das funções membro de Camera ficará como a seguir: #include &quot;camera.hpp&quot; #include &lt;glm/gtc/matrix_transform.hpp&gt; void Camera::computeProjectionMatrix(glm::vec2 const &amp;size) { m_projMatrix = glm::mat4(1.0f); auto const aspect{size.x / size.y}; m_projMatrix = glm::perspective(glm::radians(70.0f), aspect, 0.1f, 5.0f); } void Camera::computeViewMatrix() { m_viewMatrix = glm::lookAt(m_eye, m_at, m_up); } void Camera::dolly(float speed) { // Compute forward vector (view direction) auto const forward{glm::normalize(m_at - m_eye)}; // Move eye and center forward (speed &gt; 0) or backward (speed &lt; 0) m_eye += forward * speed; m_at += forward * speed; computeViewMatrix(); } void Camera::truck(float speed) { // Compute forward vector (view direction) auto const forward{glm::normalize(m_at - m_eye)}; // Compute vector to the left auto const left{glm::cross(m_up, forward)}; // Move eye and center to the left (speed &lt; 0) or to the right (speed &gt; 0) m_at -= left * speed; m_eye -= left * speed; computeViewMatrix(); } void Camera::pan(float speed) { glm::mat4 transform{1.0f}; // Rotate camera around its local y axis transform = glm::translate(transform, m_eye); transform = glm::rotate(transform, -speed, m_up); transform = glm::translate(transform, -m_eye); m_at = transform * glm::vec4(m_at, 1.0f); computeViewMatrix(); } No próximo capítulo, quando tivermos visto o conteúdo teórico sobre matrizes de projeção, descreveremos o funcionamento da função Camera::computeProjectionMatrix. Por enquanto, basta sabermos que ela calcula uma matriz de projeção perspectiva. Em Camera::computeViewMatrix, chamamos a função lookAt da GLM usando os atributos da câmera: void Camera::computeViewMatrix() { m_viewMatrix = glm::lookAt(m_eye, m_at, m_up); } Camera::computeViewMatrix será chamada sempre que houver alguma alteração em m_eye ou m_at. Em Camera::dolly, os pontos m_eye e m_at são deslocados para a frente ou para trás ao longo da direção de visão (vetor forward): void Camera::dolly(float speed) { // Compute forward vector (view direction) auto const forward{glm::normalize(m_at - m_eye)}; // Move eye and center forward (speed &gt; 0) or backward (speed &lt; 0) m_eye += forward * speed; m_at += forward * speed; computeViewMatrix(); } Veja que, ao final, Camera::computeViewMatrix é chamada para reconstruir a matriz de visão. Camera::truck funciona de forma parecida com Camera::dolly. Os pontos m_eye e m_at são deslocados nas laterais de acordo com a direção do vetor left. O vetor left é o produto vetorial entre o vetor up e o vetor forward. void Camera::truck(float speed) { // Compute forward vector (view direction) auto const forward{glm::normalize(m_at - m_eye)}; // Compute vector to the left auto const left{glm::cross(m_up, forward)}; // Move eye and center to the left (speed &lt; 0) or to the right (speed &gt; 0) m_at -= left * speed; m_eye -= left * speed; computeViewMatrix(); } Camera::pan faz o movimento de girar a câmera em torno de seu eixo \\(y\\). Isso é feito alterando apenas o ponto m_at: void Camera::pan(float speed) { glm::mat4 transform{1.0f}; // Rotate camera around its local y axis transform = glm::translate(transform, m_eye); transform = glm::rotate(transform, -speed, m_up); transform = glm::translate(transform, -m_eye); m_at = transform * glm::vec4(m_at, 1.0f); computeViewMatrix(); } Após a linha 40, a matriz transform representa uma concatenação de transformações na forma: \\[ \\mathbf{M}=\\mathbf{I}.\\mathbf{T}(\\mathbf{p}_{\\textrm{eye}}).\\mathbf{R}_y(\\theta).\\mathbf{T}(-\\mathbf{p}_{\\textrm{eye}}). \\] A ordem de aplicação das transformações é obtida lendo a expressão acima da direita para a esquerda (no código, lemos de baixo para cima, da linha 45 à linha 40): \\(\\mathbf{T}(-\\mathbf{p}_{\\textrm{eye}})\\) (linha 45) tem o efeito de transladar a câmera para a origem do mundo, isto é, faz o ponto \\(\\mathbf{p}_{\\textrm{eye}}\\) virar a origem \\(O\\). \\(\\mathbf{R}_y(\\theta)\\) (linha 44) roda a câmera em torno do eixo \\(y\\) do mundo. Como a câmera agora está na origem, é como se a câmera fosse girada em torno de seu próprio eixo \\(y\\). \\(\\mathbf{T}(\\mathbf{p}_{\\textrm{eye}})\\) (linha 43) é a transformação inversa da primeira, isto é, faz a câmera voltar à sua posição original (mas note que, por causa do passo anterior, a orientação da câmera não é mais a orientação original). \\(\\mathbf{I}\\) é a matriz identidade (criada na linha 40). A linha 47 transforma m_at por transform. O resultado é rodar m_at em torno do eixo \\(y\\) local da câmera. Observação As operações da linha 40 até a linha 45 em Camera::pan são equivalentes ao pseudocódigo: transform = I; transform = transform * T(m_eye); transform = transform * Ry(-speed); transform = transform * T(-m_eye); que é o mesmo que transform = I * T(m_eye) * Ry(-speed) * T(-m_eye); onde I, Ry e T são as matrizes de transformação identidade, rotação em \\(y\\), e translação. window.hpp Deixaremos a definição da classe Window como a seguir: #ifndef WINDOW_HPP_ #define WINDOW_HPP_ #include &quot;abcgOpenGL.hpp&quot; #include &quot;camera.hpp&quot; #include &quot;ground.hpp&quot; struct Vertex { glm::vec3 position; friend bool operator==(Vertex const &amp;, Vertex const &amp;) = default; }; class Window : public abcg::OpenGLWindow { protected: void onEvent(SDL_Event const &amp;event) override; void onCreate() override; void onPaint() override; void onPaintUI() override; void onResize(glm::ivec2 const &amp;size) override; void onDestroy() override; void onUpdate() override; private: glm::ivec2 m_viewportSize{}; GLuint m_VAO{}; GLuint m_VBO{}; GLuint m_EBO{}; GLuint m_program{}; GLint m_viewMatrixLocation{}; GLint m_projMatrixLocation{}; GLint m_modelMatrixLocation{}; GLint m_colorLocation{}; Camera m_camera; float m_dollySpeed{}; float m_truckSpeed{}; float m_panSpeed{}; Ground m_ground; std::vector&lt;Vertex&gt; m_vertices; std::vector&lt;GLuint&gt; m_indices; void loadModelFromFile(std::string_view path); }; #endif O código é semelhante ao dos projetos anteriores. As principais diferenças estão nas seguintes linhas: Linhas 6 e 7: inclusão dos cabeçalhos camera.hpp e ground.hpp; Linhas 33 a 36: identificadores das variáveis uniform do vertex shader; Linha 38: definição de um objeto da classe Camera para controlar a câmera LookAt; Linhas 39 a 41: definição de variáveis de controle de velocidade de dolly, truck e pan; Linha 43: definição de um objeto da classe Ground para desenhar o chão. Algumas coisas foram removidas em relação ao projeto loadmodel, como a variável que controlava o número de triângulos exibidos e a função OpenGLWindow::standardize que normalizava e centralizava o modelo no NDC. Dessa vez, o modelo armazenado no VBO será o modelo sem modificações, isto é, o modelo lido diretamente do arquivo. Para mudar a escala e posição do modelo, usaremos a matriz de modelo. window.cpp No início de window.cpp fazemos a especialização explícita de std::hash para Vertex, como fizemos no projeto anterior: #include &quot;window.hpp&quot; #include &lt;unordered_map&gt; // Explicit specialization of std::hash for Vertex template &lt;&gt; struct std::hash&lt;Vertex&gt; { size_t operator()(Vertex const &amp;vertex) const noexcept { auto const h1{std::hash&lt;glm::vec3&gt;()(vertex.position)}; return h1; } }; A definição de Window::onEvent vem a seguir: void Window::onEvent(SDL_Event const &amp;event) { if (event.type == SDL_KEYDOWN) { if (event.key.keysym.sym == SDLK_UP || event.key.keysym.sym == SDLK_w) m_dollySpeed = 1.0f; if (event.key.keysym.sym == SDLK_DOWN || event.key.keysym.sym == SDLK_s) m_dollySpeed = -1.0f; if (event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_a) m_panSpeed = -1.0f; if (event.key.keysym.sym == SDLK_RIGHT || event.key.keysym.sym == SDLK_d) m_panSpeed = 1.0f; if (event.key.keysym.sym == SDLK_q) m_truckSpeed = -1.0f; if (event.key.keysym.sym == SDLK_e) m_truckSpeed = 1.0f; } if (event.type == SDL_KEYUP) { if ((event.key.keysym.sym == SDLK_UP || event.key.keysym.sym == SDLK_w) &amp;&amp; m_dollySpeed &gt; 0) m_dollySpeed = 0.0f; if ((event.key.keysym.sym == SDLK_DOWN || event.key.keysym.sym == SDLK_s) &amp;&amp; m_dollySpeed &lt; 0) m_dollySpeed = 0.0f; if ((event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_a) &amp;&amp; m_panSpeed &lt; 0) m_panSpeed = 0.0f; if ((event.key.keysym.sym == SDLK_RIGHT || event.key.keysym.sym == SDLK_d) &amp;&amp; m_panSpeed &gt; 0) m_panSpeed = 0.0f; if (event.key.keysym.sym == SDLK_q &amp;&amp; m_truckSpeed &lt; 0) m_truckSpeed = 0.0f; if (event.key.keysym.sym == SDLK_e &amp;&amp; m_truckSpeed &gt; 0) m_truckSpeed = 0.0f; } } Os eventos de teclado são tratados de forma separada para as teclas pressionadas (SDL_KEYDOWN, linhas 14 a 27) e para as teclas liberadas (SDL_KEYUP, linhas 28 a 46). Quando uma tecla é pressionada (setas ou QEWASD), a velocidade de dolly, pan ou truck é modificada para +1 ou -1. Quando a tecla é liberada, a velocidade correspondente volta para 0. Vamos agora à definição de Window::onCreate, que também é bem parecida com a do projeto loadmodel: void Window::onCreate() { auto const &amp;assetsPath{abcg::Application::getAssetsPath()}; abcg::glClearColor(0, 0, 0, 1); // Enable depth buffering abcg::glEnable(GL_DEPTH_TEST); // Create program m_program = abcg::createOpenGLProgram({{.source = assetsPath + &quot;lookat.vert&quot;, .stage = abcg::ShaderStage::Vertex}, {.source = assetsPath + &quot;lookat.frag&quot;, .stage = abcg::ShaderStage::Fragment}}); m_ground.create(m_program); // Get location of uniform variables m_viewMatrixLocation = abcg::glGetUniformLocation(m_program, &quot;viewMatrix&quot;); m_projMatrixLocation = abcg::glGetUniformLocation(m_program, &quot;projMatrix&quot;); m_modelMatrixLocation = abcg::glGetUniformLocation(m_program, &quot;modelMatrix&quot;); m_colorLocation = abcg::glGetUniformLocation(m_program, &quot;color&quot;); // Load model loadModelFromFile(assetsPath + &quot;bunny.obj&quot;); // Generate VBO abcg::glGenBuffers(1, &amp;m_VBO); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); abcg::glBufferData(GL_ARRAY_BUFFER, sizeof(m_vertices.at(0)) * m_vertices.size(), m_vertices.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Generate EBO abcg::glGenBuffers(1, &amp;m_EBO); abcg::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_EBO); abcg::glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m_indices.at(0)) * m_indices.size(), m_indices.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // Create VAO abcg::glGenVertexArrays(1, &amp;m_VAO); // Bind vertex attributes to current VAO abcg::glBindVertexArray(m_VAO); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); auto const positionAttribute{ abcg::glGetAttribLocation(m_program, &quot;inPosition&quot;)}; abcg::glEnableVertexAttribArray(positionAttribute); abcg::glVertexAttribPointer(positionAttribute, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); abcg::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_EBO); // End of binding to current VAO abcg::glBindVertexArray(0); } Em relação ao projeto anterior, modificamos o nomes dos shaders lidos (linhas 58 a 62) e chamamos Ground::create na linha 64 para inicializar o VAO/VBO do chão. A definição de Window::loadModelFromFile é a mesma do projeto anterior: void Window::loadModelFromFile(std::string_view path) { tinyobj::ObjReader reader; if (!reader.ParseFromFile(path.data())) { if (!reader.Error().empty()) { throw abcg::RuntimeError( fmt::format(&quot;Failed to load model {} ({})&quot;, path, reader.Error())); } throw abcg::RuntimeError(fmt::format(&quot;Failed to load model {}&quot;, path)); } if (!reader.Warning().empty()) { fmt::print(&quot;Warning: {}\\n&quot;, reader.Warning()); } auto const &amp;attributes{reader.GetAttrib()}; auto const &amp;shapes{reader.GetShapes()}; m_vertices.clear(); m_indices.clear(); // A key:value map with key=Vertex and value=index std::unordered_map&lt;Vertex, GLuint&gt; hash{}; // Loop over shapes for (auto const &amp;shape : shapes) { // Loop over indices for (auto const offset : iter::range(shape.mesh.indices.size())) { // Access to vertex auto const index{shape.mesh.indices.at(offset)}; // Vertex position auto const startIndex{3 * index.vertex_index}; auto const vx{attributes.vertices.at(startIndex + 0)}; auto const vy{attributes.vertices.at(startIndex + 1)}; auto const vz{attributes.vertices.at(startIndex + 2)}; Vertex const vertex{.position = {vx, vy, vz}}; // If map doesn&#39;t contain this vertex if (!hash.contains(vertex)) { // Add this index (size of m_vertices) hash[vertex] = m_vertices.size(); // Add this vertex m_vertices.push_back(vertex); } m_indices.push_back(hash[vertex]); } } } Vamos à definição de Window::onPaint: void Window::onPaint() { // Clear color buffer and depth buffer abcg::glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); abcg::glViewport(0, 0, m_viewportSize.x, m_viewportSize.y); abcg::glUseProgram(m_program); // Set uniform variables for viewMatrix and projMatrix // These matrices are used for every scene object abcg::glUniformMatrix4fv(m_viewMatrixLocation, 1, GL_FALSE, &amp;m_camera.getViewMatrix()[0][0]); abcg::glUniformMatrix4fv(m_projMatrixLocation, 1, GL_FALSE, &amp;m_camera.getProjMatrix()[0][0]); abcg::glBindVertexArray(m_VAO); // Draw white bunny glm::mat4 model{1.0f}; model = glm::translate(model, glm::vec3(-1.0f, 0.0f, 0.0f)); model = glm::rotate(model, glm::radians(90.0f), glm::vec3(0, 1, 0)); model = glm::scale(model, glm::vec3(0.5f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 1.0f, 1.0f, 1.0f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); // Draw yellow bunny model = glm::mat4(1.0); model = glm::translate(model, glm::vec3(0.0f, 0.0f, -1.0f)); model = glm::scale(model, glm::vec3(0.5f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 1.0f, 0.8f, 0.0f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); // Draw blue bunny model = glm::mat4(1.0); model = glm::translate(model, glm::vec3(1.0f, 0.0f, 0.0f)); model = glm::rotate(model, glm::radians(-90.0f), glm::vec3(0, 1, 0)); model = glm::scale(model, glm::vec3(0.5f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 0.0f, 0.8f, 1.0f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); // Draw red bunny model = glm::mat4(1.0); model = glm::scale(model, glm::vec3(0.1f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 1.0f, 0.25f, 0.25f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); abcg::glBindVertexArray(0); // Draw ground m_ground.paint(); abcg::glUseProgram(0); } Nas linhas 173 a 176, o conteúdo das matrizes de visão e projeção é enviado às variáveis uniformes no shader: // Set uniform variables for viewMatrix and projMatrix // These matrices are used for every scene object abcg::glUniformMatrix4fv(viewMatrixLoc, 1, GL_FALSE, &amp;m_camera.m_viewMatrix[0][0]); abcg::glUniformMatrix4fv(projMatrixLoc, 1, GL_FALSE, &amp;m_camera.m_projMatrix[0][0]); Observe o uso da função glUniformMatrix4fv. Essa função tem a assinatura void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); onde location é o identificador de localização da variável uniforme no shader; count é o número de matrizes que queremos transferir à variável uniforme; transpose é um valor booleano que indica se queremos enviar a transposta da matriz; value é o ponteiro para o primeiro elemento do arranjo de elementos da matriz. A renderização do coelho branco é configurada nas linhas 181 a 189: // Draw white bunny glm::mat4 model{1.0f}; model = glm::translate(model, glm::vec3(-1.0f, 0.0f, 0.0f)); model = glm::rotate(model, glm::radians(90.0f), glm::vec3(0, 1, 0)); model = glm::scale(model, glm::vec3(0.5f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 1.0f, 1.0f, 1.0f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); Nas linhas 181 a 184 é criada a concatenação de transformações que forma a matriz de modelo (model). Para o coelho branco, essa concatenação é \\[ \\mathbf{M}_{\\textrm{model}}=\\mathbf{I}.\\mathbf{T}(-1,0,0).\\mathbf{R}_y\\left(\\frac{\\pi}{2}\\right).\\mathbf{S}(0.5, 0.5, 0.5). \\] Essas transformações servem para posicionar o modelo do coelho no mundo. Inicialmente o modelo está em seu quadro local, com posição e orientação definida no arquivo bunny.obj: na origem, sobre o plano \\(y=0\\), como vimos na figura 8.16. As transformações são aplicadas da seguinte forma: Transformação de escala para reduzir o tamanho do coelho para \\(50\\%\\) de seu tamanho original (linha 184); Rotação em \\(90^{\\circ}\\) em torno do eixo \\(y\\) do espaço do objeto, que é o mesmo eixo \\(y\\) do espaço do mundo (linha 183); Translação pelo vetor \\((-1,0,0)\\), que posiciona o coelho em sua posição final na cena (linha 182); Transformação identidade (linha 181). Na linha 186, a matriz de modelo é enviada à variável uniforme m_modelMatrix no vertex shader. Na linha 187, a variável uniforme color é definida com \\((1,1,1,1)\\) (branco) no vertex shader. Na linha 188 é feita a chamada ao comando de renderização. Observe como um procedimento semelhante é feito para os outros coelhos. Mudam apenas as transformações que serão usadas para criar a matriz model, e o valor de cor definido na variável uniforme color. Para o coelho amarelo: // Draw yellow bunny model = glm::mat4(1.0); model = glm::translate(model, glm::vec3(0.0f, 0.0f, -1.0f)); model = glm::scale(model, glm::vec3(0.5f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 1.0f, 0.8f, 0.0f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); Para o coelho azul: // Draw blue bunny model = glm::mat4(1.0); model = glm::translate(model, glm::vec3(1.0f, 0.0f, 0.0f)); model = glm::rotate(model, glm::radians(-90.0f), glm::vec3(0, 1, 0)); model = glm::scale(model, glm::vec3(0.5f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 0.0f, 0.8f, 1.0f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); Para o pequeno coelho vermelho: // Draw red bunny model = glm::mat4(1.0); model = glm::scale(model, glm::vec3(0.1f)); abcg::glUniformMatrix4fv(m_modelMatrixLocation, 1, GL_FALSE, &amp;model[0][0]); abcg::glUniform4f(m_colorLocation, 1.0f, 0.25f, 0.25f, 1.0f); abcg::glDrawElements(GL_TRIANGLES, m_indices.size(), GL_UNSIGNED_INT, nullptr); Note que todos os modelos foram renderizados com o mesmo VAO (linha 178), pois todos compartilham o mesmo VBO. É apenas a matriz de modelo que faz com que cada coelho tenha uma transformação diferente no cenário 3D. Ao fim de Window::onPaint temos o seguinte código: abcg::glBindVertexArray(0); // Draw ground m_ground.paint(); abcg::glUseProgram(0); Na linha 221, o VAO dos coelhos deixa de ser usado. Em seguida, na linha 224, o chão é desenhado. O chão tem seu próprio VAO, mas usa os mesmos shaders dos coelhos. É por isso que o programa de shader só é desabilitado na linha 226 com a chamada a glUseProgram(0). A definição de Window::onPaintUI e Window::onResize é dada a seguir: void Window::onPaintUI() { abcg::OpenGLWindow::onPaintUI(); } void Window::onResize(glm::ivec2 const &amp;size) { m_viewportSize = size; m_camera.computeProjectionMatrix(size); } A função Camera::computeProjectioMatrix é chamada dentro de Window::onResize para reconstruir a matriz de projeção. Os valores da matriz dependem do tamanho atual da janela. A definição de Window::destroy ficará como a seguir: void Window::onDestroy() { m_ground.destroy(); abcg::glDeleteProgram(m_program); abcg::glDeleteBuffers(1, &amp;m_EBO); abcg::glDeleteBuffers(1, &amp;m_VBO); abcg::glDeleteVertexArrays(1, &amp;m_VAO); } Não há nada de muito novo nesse código, exceto a chamada a Ground::destroy para liberar o VAO e VBO do chão. Finalmente, a definição de Window::onUpdate ficará como a seguir: void Window::onUpdate() { auto const deltaTime{gsl::narrow_cast&lt;float&gt;(getDeltaTime())}; // Update LookAt camera m_camera.dolly(m_dollySpeed * deltaTime); m_camera.truck(m_truckSpeed * deltaTime); m_camera.pan(m_panSpeed * deltaTime); } Aqui, a posição e a orientação da câmera LookAt são atualizadas antes da chamada de Window::onPaint. As funções de movimentação da câmera são chamadas usando as variáveis de velocidade (m_dollySpeed, m_truckSpeed, m_panSpeed) que tiveram seus valores determinados em Window::onEvent de acordo com as teclas pressionadas. ground.hpp A classe Ground é responsável pelo desenho do chão. Embora não seja uma classe derivada de abcg::OpenGLWindow, os nomes das funções são semelhantes (create, paint e destroy). Como vimos anteriormente, essas funções são chamadas nas respectivas funções de Window: #ifndef GROUND_HPP_ #define GROUND_HPP_ #include &quot;abcgOpenGL.hpp&quot; class Ground { public: void create(GLuint program); void paint(); void destroy(); private: GLuint m_VAO{}; GLuint m_VBO{}; GLint m_modelMatrixLoc{}; GLint m_colorLoc{}; }; #endif Ground::create recebe como parâmetro o identificador de um programa de shader já existente. Assim, o chão pode usar os mesmos shaders dos coelhos. Em Ground::paint, veremos que o chão é desenhado como um padrão de xadrez. Como é um padrão composto por quadriláteros, o VBO não precisa ser a malha geométrica do chão inteiro, mas apenas um quadrilátero de tamanho unitário. Esse quadrilátero será desenhado várias vezes para formar um ladrilho com padrão de xadrez. ground.cpp Vamos começar com a definição de Ground::create: #include &quot;ground.hpp&quot; void Ground::create(GLuint program) { // Unit quad on the xz plane std::array&lt;glm::vec3, 4&gt; vertices{{{-0.5f, 0.0f, +0.5f}, {-0.5f, 0.0f, -0.5f}, {+0.5f, 0.0f, +0.5f}, {+0.5f, 0.0f, -0.5f}}}; // Generate VBO abcg::glGenBuffers(1, &amp;m_VBO); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); abcg::glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices.data(), GL_STATIC_DRAW); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); // Create VAO and bind vertex attributes abcg::glGenVertexArrays(1, &amp;m_VAO); abcg::glBindVertexArray(m_VAO); abcg::glBindBuffer(GL_ARRAY_BUFFER, m_VBO); auto const positionAttribute{ abcg::glGetAttribLocation(program, &quot;inPosition&quot;)}; abcg::glEnableVertexAttribArray(positionAttribute); abcg::glVertexAttribPointer(positionAttribute, 3, GL_FLOAT, GL_FALSE, 0, nullptr); abcg::glBindBuffer(GL_ARRAY_BUFFER, 0); abcg::glBindVertexArray(0); // Save location of uniform variables m_modelMatrixLoc = abcg::glGetUniformLocation(program, &quot;modelMatrix&quot;); m_colorLoc = abcg::glGetUniformLocation(program, &quot;color&quot;); } No início da função, definimos os vértices de um quadrilátero de tamanho unitário centralizado no plano \\(xz\\). Em seguida, criamos o VBO e fazemos a ligação do VBO com o atributo inPosition do shader program. Por fim, salvamos a localização das variáveis uniformes que serão utilizadas em Ground::paint. A propósito, eis o código de Ground::paint: void Ground::paint() { abcg::glBindVertexArray(m_VAO); // Draw a grid of 2N+1 x 2N+1 tiles on the xz plane, centered around the // origin auto const N{5}; for (auto const z : iter::range(-N, N + 1)) { for (auto const x : iter::range(-N, N + 1)) { // Set model matrix as a translation matrix glm::mat4 model{1.0f}; model = glm::translate(model, glm::vec3(x, 0.0f, z)); abcg::glUniformMatrix4fv(m_modelMatrixLoc, 1, GL_FALSE, &amp;model[0][0]); // Set color (checkerboard pattern) auto const gray{(z + x) % 2 == 0 ? 1.0f : 0.5f}; abcg::glUniform4f(m_colorLoc, gray, gray, gray, 1.0f); abcg::glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); } } abcg::glBindVertexArray(0); } Aqui, desenhamos uma grade de 11x11 quadriláteros (variando \\(z\\) e \\(x\\) de -5 a 5). Cada quadrilátero é transladado através de uma matriz de modelo e então desenhado com glDrawArrays usando a primitiva GL_TRIANGLE_STRIP. A cor utilizada – configurada pela variável uniforme do shader – é modificada de acordo com a paridade das coordenadas da grade de modo a formar o padrão de xadrez. Em Ground::destroy, o VBO e o VAO são liberados: void Ground::destroy() { abcg::glDeleteBuffers(1, &amp;m_VBO); abcg::glDeleteVertexArrays(1, &amp;m_VAO); } Como o programa de shader é o mesmo dos coelhos, o responsável pela liberação dos shaders é Window, como já vimos em Window::onDestroy. Isso conclui o projeto lookat. Baixe o código completo a partir deste link. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
