[["index.html", "MCTA008-17 Computação Gráfica Apresentação", " MCTA008-17 Computação Gráfica Harlen Batagelo (harlen.batagelo@ufabc.edu.br) Bruno Marques (bruno.marques@ufabc.edu.br) Universidade Federal do ABC 3º quadrimestre de 2021 Apresentação Caro/a estudante, Este site contém as notas de aula da disciplina MCTA008-17 Computação Gráfica adaptada ao ensino remoto do 3º quadrimestre de 2021. O conteúdo é organizado no formato de um livro voltado ao estudo autodirigido. Os capítulos estão divididos em tópicos teóricos sobre o processo de geração de imagens no computador, e partes práticas de desenvolvimento de aplicações gráficas interativas. Cada capítulo corresponde aproximadamente ao conteúdo de uma semana de aula. Para informações sobre o cronograma das atividades e critérios de avaliação, consulte o plano de ensino disponível no Moodle. Bons estudos!  Harlen e Bruno "],["pré-requisitos.html", "Pré-requisitos", " Pré-requisitos Para acompanhar o curso de forma satisfatória é recomendável ter conhecimento prévio do conteúdo abordado nas disciplinas de Algoritmos e Estruturas de Dados I e Geometria Analítica. As atividades práticas avaliativas serão desenvolvidas na linguagem C++. Embora não seja necessário ter fluência em C++, é recomendável ter proficiência em programação em C e familiaridade com conceitos básicos de programação orientada a objetos. Também é recomendável ter familiaridade com o Git e ser capaz de gerenciar seus próprios repositórios. Atividades práticas Para realizar as atividades práticas é necessário ter um computador com sistema operacional 64 bits (Windows, Linux ou macOS) e placa de vídeo compatível com OpenGL 4.1 ou superior. O OpenGL 4.1 é suportado em placas gráficas da família Nvidia GeForce 400 (2010) ou mais recentes, AMD Radeon HD 5000 (2009) em diante e Intel HD Graphics a partir dos processadores Intel de 7ª geração (2012). Caso a sua placa de vídeo seja de uma geração a partir de 2012, provavelmente ela deve suportar OpenGL 4.1. Se não suportar, há a possibilidade de simular o processamento gráfico em software através do driver Gallium llvmpipe da biblioteca Mesa. Visualizando este site Parte do conteúdo deste site requer um navegador com suporte a WebGL 2.0. Para informações detalhadas sobre o suporte do seu navegador a WebGL 2.0, consulte o WebGL Report. Dica Para garantir a visualização correta do conteúdo WebGL 2.0, utilize a versão mais recente do Mozilla FireFox ou Google Chrome. Além disso, use o navegador em um computador desktop ou laptop. Embora o site funcione em tablets e smartphones, pode ser difícil interagir com o conteúdo WebGL nesses dispositivos. Dependendo das configurações de DPI utilizadas no sistema de janelas, podem ocorrer problemas de redimensionamento dos elementos de interface no Chrome e em navegadores baseados no Chromium, como o Microsoft Edge. Por exemplo, o cubo exibido acima pode ser redimensionado e as arestas podem apresentar distorções, parecendo mais serrilhadas que o normal: No Chrome, isso geralmente é resolvido iniciando o navegador com a opção /high-dpi-support=1 /force-device-scale-factor=1 na linha de comando (ou incluindo essas opções no atalho), ou ajustando o zoom . Importante No momento da escrita deste texto, o Apple Safari não possui suporte a WebGL 2.0. Entretanto, o Safari Technology Preview tem o WebGL 2.0 habilitado por padrão e está disponível a partir do macOS Catalina. Consulte em https://caniuse.com/webgl2 o suporte a WebGL 2.0 em diferentes navegadores. "],["config.html", "1 Configuração do ambiente", " 1 Configuração do ambiente Neste capítulo veremos como configurar o ambiente de desenvolvimento para realizar as atividades práticas no computador. Qualquer que seja a plataforma  Linux, macOS ou Windows  é necessário instalar as seguintes ferramentas e bibliotecas: CMake: para automatizar a geração de scripts de compilação e ligação de forma independente de plataforma; Emscripten: para compilar código C++ e gerar binário em WebAssembly de modo a executar nossas aplicações no navegador; Git: para clonar o repositório do SDK do Emscripten e da biblioteca de desenvolvimento que usaremos na disciplina, e para o controle de versão das atividades; GLEW: para carregamento das funções da API gráfica OpenGL; Simple DirectMedia Layer (SDL) 2.0: para gerenciamento de dispositivos de vídeo, dispositivos de entrada, áudio, entre outros componentes de hardware. SDL_image 2.0: para leitura de arquivos de imagem. Precisamos também usar um compilador recente com suporte a C++17 e suporte pelo menos parcial a C++20, como o GCC 10 ou Clang 11. Acompanhe nas seções a seguir o passo a passo da instalação desses recursos de acordo com o sistema operacional utilizado: Seção 1.1 para instalação no Linux; Seção 1.2 para instalação no macOS; Seção 1.3 para instalar no Windows. Não é necessário usar um IDE ou editor específico de código-fonte para o desenvolvimento das atividades. A compilação pode ser disparada através de scripts de linha de comando. Entretanto, como um exemplo, veremos na seção 1.4 como fazer a configuração básica do Visual Studio Code para o desenvolvimento de aplicações C++ com CMake. Na seção 1.5 veremos como instalar uma biblioteca auxiliar (a ABCg) criada especialmente para esta disciplina. Ela será utilizada em todas as atividades do curso para facilitar o desenvolvimento das aplicações gráficas. Dica Caso o seu computador tenha recursos de processamento e memória suficientes, é possível configurar todo o ambiente de desenvolvimento em um sistema operacional instalado em uma máquina virtual. O VMware Workstation Player (Windows e Linux) e VMWare Fusion Player (macOS) possuem suporte a aceleração gráfica 3D usando OpenGL 4.1 e são adequados para desenvolver as atividades da disciplina. Tanto o VMWare Workstation Player quanto o Fusion Player podem ser utilizados gratuitamente através de uma licença de uso pessoal. No Windows 10, o Windows Subsystem for Linux (WSL) também suporta aceleração gráfica 3D (disponível somente no WSL 2). Entretanto, a configuração é mais complexa e exige a instalação de um servidor do X Window System, como o VcXsrv. "],["linux.html", "1.1 Linux", " 1.1 Linux As ferramentas e bibliotecas necessárias estão disponíveis nos repositórios de pacotes das principais distribuições Linux. A seguir veremos como instalar os pacotes no Ubuntu. Entretanto, em outras distribuições há pacotes equivalentes e o procedimento é semelhante. Em um terminal, execute os passos a seguir. Atualize o sistema: sudo apt update &amp;&amp; sudo apt upgrade Instale o pacote build-essential (GCC, GDB, Make, etc): sudo apt install build-essential Instale o CMake e Git: sudo apt install cmake git Instale as bibliotecas GLEW, SDL 2.0 e SDL_image 2.0: sudo apt install libglew-dev libsdl2-dev libsdl2-image-dev Opcionalmente, instale as ferramentas de linting do GLSL. Essas ferramentas poderão ser utilizadas no Visual Studio Code para fazer a análise estática do código da linguagem de shaders GLSL (OpenGL Shading Language) que será abordada na disciplina: sudo apt install glslang-tools Habilitando o OpenGL O suporte ao OpenGL já vem integrado no kernel do Linux através dos drivers de código aberto da biblioteca Mesa (drivers Intel/AMD/Nouveau). Para as placas da NVIDIA e AMD há a possibilidade de instalar os drivers proprietários do repositório nonfree (repositório restricted no Ubuntu), ou diretamente dos sites dos fabricantes: AMD ou NVIDIA. Os drivers proprietários, especialmente os da NVIDIA, geralmente têm desempenho superior aos de código aberto. Para verificar a versão do OpenGL suportada pelos drivers instalados, instale primeiro o pacote mesa-utils: sudo apt install mesa-utils Execute o comando: glxinfo | grep version O resultado deverá ser parecido com o seguinte: server glx version string: 1.4 client glx version string: 1.4 GLX version: 1.4 Max core profile version: 4.1 Max compat profile version: 4.1 Max GLES1 profile version: 1.1 Max GLES[23] profile version: 2.0 OpenGL core profile version string: 4.1 (Core Profile) Mesa 21.0.3 OpenGL core profile shading language version string: 4.10 OpenGL version string: 4.1 (Compatibility Profile) Mesa 21.0.3 OpenGL shading language version string: 4.10 OpenGL ES profile version string: OpenGL ES 2.0 Mesa 21.0.3 OpenGL ES profile shading language version string: OpenGL ES GLSL ES 1.0.16 Importante A versão em OpenGL version string ou OpenGL core profile version string deve ser 4.1 ou superior. Caso não seja, instale os drivers proprietários e certifique-se de que sua placa de vídeo suporta OpenGL 4.1. Atualizando o GCC As atividades farão uso de uma biblioteca de desenvolvimento que exige um compilador com suporte a C++17 e suporte parcial a C++20. Esse requisito é atendido se instalarmos uma versão recente do GCC, como o GCC 10. Nas últimas versões do Fedora e Manjaro, o GCC instalado por padrão já é a versão 10 ou superior. No Ubuntu, apenas o Ubuntu 20.10 (Groovy Gorilla) em diante vem com GCC 10 ou mais recente. Siga os passos a seguir caso sua distribuição seja de uma versão anterior, ou caso a saída de g++ --version mostre um número de versão menor que 10. Por exemplo, no Ubuntu 20.04 a saída de g++ --version é: g++ (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. O padrão no Ubuntu 20.04 é o GCC 9.3. Logo, precisamos instalar uma versão mais recente. Em um terminal, adicione o PPA ubuntu-toolchain-r/test: sudo apt install software-properties-common sudo add-apt-repository ppa:ubuntu-toolchain-r/test Instale o GCC 10: sudo apt install gcc-10 g++-10 A instalação do GCC 10 não substituirá a versão mais antiga já instalada. Entretanto, é necessário criar links simbólicos de gcc e g++ para a versão mais recente. Uma forma simples de fazer isso é através do update-alternatives. Primeiro, execute o comando a seguir para definir um valor de prioridade (neste caso, 100) para o GCC 10: sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10 Use o comando a seguir para definir um valor de prioridade mais baixo (por exemplo, 90) para a versão anterior do GCC, que neste exemplo é a versão 9: sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9 Agora execute o comando a seguir para escolher qual a versão do GCC instalada no sistema será utilizada: sudo update-alternatives --config gcc Na lista de versões instaladas, selecione o GCC 10 caso ainda não esteja selecionado. Isso criará os links simbólicos. Para testar se a versão correta do GCC está sendo utilizada, execute g++ --version. A saída deverá ser parecida com a seguinte: g++ (Ubuntu 10.3.0-1ubuntu1~20.04) 10.3.0 Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Dica Opcionalmente, instale o Ccache para acelerar a recompilação das atividades: Instale o pacote ccache: sudo apt install ccache Atualize os links simbólicos dos compiladores instalados: sudo /usr/sbin/update-ccache-symlinks Insira a seguinte linha no final do arquivo ~/.bashrc de modo a prefixar o caminho do Ccache no PATH: export PATH=&quot;/usr/lib/ccache:$PATH&quot; Reabra o terminal ou execute source ~/.bashrc. Para testar se o Ccache está ativado, execute o comando which g++. A saída deverá incluir o caminho /usr/lib/ccache/, como a seguir: /usr/lib/ccache/g++`. Instalando o Emscripten Vá para o seu diretório home: cd Clone o repositório do SDK do Emscripten: git clone https://github.com/emscripten-core/emsdk.git Entre no diretório recém-criado: cd emsdk Baixe e instale o SDK atualizado (latest): ./emsdk install latest Ative o SDK latest para o usuário atual. Um arquivo .emscripten será gerado: ./emsdk activate latest Configure as variáveis de ambiente e PATH do compilador para o terminal atual: source ./emsdk_env.sh Execute o comando emcc --version. A saída deverá ser parecida com a seguinte: emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 2.0.29 (28ca7fb7ce895b21013212e4644a5794a15a76f9) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Importante Refaça o passo 6 sempre que abrir um terminal. Como alternativa, insira o comando a seguir na última linha de ~/.bashrc. Isso fará com que o script seja executado automaticamente toda vez que um terminal for aberto: source ./emsdk/emsdk_env.sh &gt; /dev/null 2&gt;&amp;1 O trecho &gt; /dev/null 2&gt;&amp;1 serve para omitir a saída padrão (stdout) e erro padrão (stderr). "],["macos.html", "1.2 macOS", " 1.2 macOS Em um terminal, execute os passos a seguir: Execute o comando gcc. Se o GCC não estiver instalado, aparecerá uma caixa de diálogo solicitando a instalação das ferramentas de desenvolvimento de linha de comando. Clique em Install. Esse procedimento também instalará outras ferramentas, como o Make e Git. Para verificar se o GCC foi instalado, execute gcc --version. A saída deverá ser parecida com a seguinte (note que o GCC é apenas um atalho para o Apple Clang): Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk/usr/include/c++/4.2.1 Apple clang version 12.0.0 (clang-1200.0.32.28) Target: x86_64-apple-darwin19.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin Se o procedimento acima não funcionar (as instruções acima foram testadas no macOS Catalina), baixe o Command Line Tools for Xcode usando sua conta de desenvolvedor do Apple Developer, ou execute xcode-select --version no terminal. Em versões mais antigas do macOS pode ser necessário instalar o Xcode. Para instalar os demais pacotes de bibliotecas e ferramentas, instale o Homebrew com o seguinte comando: /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; Instale o CMake: brew install cmake Instale o GLEW, SDL 2.0 e SDL_image 2.0: brew install glew brew install sdl2 brew install sdl2_image Está pronto! Dica Opcionalmente, instale o Ccache para acelerar a recompilação das atividades: Instale o Ccache usando o Homebrew: brew install ccache Anote a saída de echo $(brew --prefix) (por exemplo, /usr/local). Abra o modo de edição do PATH: sudo nano /etc/paths Insira como primeira linha o caminho $(brew --prefix)/opt/ccache/libexec, onde $(brew --prefix) é a saída do passo 2. Por exemplo, /usr/local/opt/ccache/libexec. Salve (Ctrl+X e Y) e reinicie o terminal. Para testar, digite which gcc. A saída deverá ser um caminho que inclui o Ccache, como a seguir: /usr/local/opt/ccache/libexec/gc Instalando o Emscripten Vá para o seu diretório home: cd Clone o repositório do SDK do Emscripten: git clone https://github.com/emscripten-core/emsdk.git Entre no diretório recém-criado: cd emsdk Baixe e instale o SDK atualizado (latest): ./emsdk install latest Ative o SDK latest para o usuário atual. Um arquivo .emscripten será gerado: ./emsdk activate latest Configure as variáveis de ambiente e PATH do compilador para o terminal atual: source ./emsdk_env.sh Execute o comando emcc --version. A saída deverá ser parecida com a seguinte: emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 2.0.29 (28ca7fb7ce895b21013212e4644a5794a15a76f9) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Importante Refaça o passo 6 sempre que abrir um terminal. Como alternativa, insira o comando a seguir na última linha do arquivo ~/.zshrc (shell Zsh no macOS Catalina ou posterior) ou ~/.bashrc (shell Bash em versões anteriores) para que o script seja executado automaticamente toda vez que um terminal for aberto: source ./emsdk/emsdk_env.sh &gt; /dev/null 2&gt;&amp;1 O trecho &gt; /dev/null 2&gt;&amp;1 serve para omitir a saída padrão (stdout) e erro padrão (stderr). "],["windows.html", "1.3 Windows", " 1.3 Windows Para a instalação das ferramentas e bibliotecas de desenvolvimento no Windows utilizaremos o MSYS2. MSYS2 é um ambiente de terminal tipo Unix com acesso a um repositório de ferramentas e bibliotecas de desenvolvimento de aplicações nativas em Windows através do gerenciador de pacotes pacman. Essas ferramentas e bibliotecas incluem o CMake, Git, GLEW, SDL 2.0 e SDL_image 2.0, entre outras que vamos utilizar na disciplina. O MSYS2 também permite instalar o MinGW-W64. Com isso podemos usar o GCC (compilador) e o GDB (depurador) no Windows e gerar binário nativo para 64-bit e 32-bit. Siga os passos a seguir para instalar o MSYS2 e as ferramentas/bibliotecas de desenvolvimento: Baixe o instalador de https://www.msys2.org e siga os passos descritos na página. Abra o shell do MSYS2 (aplicativo MSYS2 MSYS a partir no menu Iniciar) e execute o seguinte comando: pacman -S git mingw-w64-x86_64-ccache mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-gdb mingw-w64-x86_64-ninja mingw-w64-x86_64-glew mingw-w64-x86_64-SDL2 mingw-w64-x86_64-SDL2_image Isso instalará as ferramentas Git, Ccache, CMake, Ninja (o Ninja substitui o GNU Make no Windows), GCC e GDB (do MinGW-W64), e as bibliotecas GLEW, SDL 2.0 e SDL_image 2.0. Opcionalmente, instale o pacote mingw-w64-x86_64-glslang com o comando a seguir. Isso instalará as ferramentas que poderão ser usadas para linting da linguagem GLSL (linguagem de shading que será abordada na disciplina): pacman -S mingw-w64-x86_64-glslang Ao terminar a instalação, feche o shell do MSYS2. Instale o Python 3.9+ para Windows. Durante a instalação, certifique-se de ativar a opção Add Python 3.9 to PATH. Após a instalação, abra o Prompt de Comando (cmd.exe) e execute o comando which python: C:\\&gt;which python /c/Users/ufabc/AppData/Local/Programs/Python/Python39/python O caminho exibido deve ser o caminho do executável do Python que acabou de ser instalado. No exemplo acima, o Python foi instalado no local padrão (%LocalAppData%\\Programs\\Python\\Python39) e o nome do usuário é ufabc. No Painel de Controle do Windows, abra a opção Editar as Variáveis de Ambiente do Sistema. Edite a variável de ambiente PATH e inclua os caminhos para mingw64\\bin e usr\\bin do MSYS2. Por exemplo, se o MSYS2 foi instalado em C:\\msys64, inclua os seguintes caminhos no PATH: C:\\msys64\\usr\\bin C:\\msys64\\mingw64\\bin Edite a ordem dos caminhos de tal forma que o caminho do Python apareça antes do caminho do MSYS2, como mostra a figura a seguir: Para testar se o MSYS2 foi instalado corretamente, abra o Prompt de Comando e execute o comando g++ --version. A saída deverá ser parecida com a seguinte: g++ (Rev5, Built by MSYS2 project) 10.3.0 Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Habilitando o OpenGL O suporte ao OpenGL vem integrado no Windows. Apenas certifique-se de instalar os drivers mais recentes da placa de vídeo. Instalando o Emscripten Abra o Prompt de Comando em algum caminho onde queira instalar a pasta do SDK do Emscripten (por exemplo, C:\\). Note the o terminal deve ser o Prompt de Comando e não o PowerShell. Clone o repositório do SDK: git clone https://github.com/emscripten-core/emsdk.git Entre na pasta recém-criada: cd emsdk Baixe e instale o SDK atualizado (latest): emsdk install latest Ative o SDK latest para o usuário atual: emsdk activate latest Configure as variáveis de ambiente e PATH do compilador para o terminal atual: emsdk_env.bat Para testar se a instalação foi bem-sucedida, execute o comando emcc --version. A saída deverá ser parecida com a seguinte: emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 2.0.29 (28ca7fb7ce895b21013212e4644a5794a15a76f9) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Importante Refaça o passo 6 sempre que abrir um terminal ou execute o comando a seguir para registrar permanentemente as variáveis de ambiente no registro do sistema: emsdk_env.bat --permanent Caso não queira modificar o registro do sistema, uma opção é criar um atalho para cmd.exe e use a opção /k para executar o arquivo emsdk_env.bat sempre que o Prompt de Comando for aberto. Por exemplo: cmd.exe /k &quot;C:\\emsdk\\emsdk_env.bat&quot; Mude esse caminho de acordo com o local onde emsdk_env.bat foi instalado. "],["vscode.html", "1.4 Visual Studio Code", " 1.4 Visual Studio Code Para desenvolver as atividades não é necessário usar um IDE ou editor em particular. Os códigos podem ser escritos em qualquer editor de texto não formatado e a compilação pode ser feita em linha de comando. Entretanto, é recomendável utilizar um editor/IDE como o CLion, Emacs, Sublime Text, Vim, Visual Studio Code, ou outro semelhante que seja capaz de oferecer funcionalidades de preenchimento automático de código, detecção de erros, ajuda sensível ao contexto e integração de construção com o CMake. A seguir veremos como configurar o Visual Studio Code (VS Code) para deixá-lo pronto para o desenvolvimento das atividades. O procedimento é simples e é o mesmo no Linux, macOS e Windows: Instale o VS Code através do instalador disponível em https://code.visualstudio.com/. No editor, instale as seguintes extensões: C/C++ for Visual Studio Code: para habilitar o suporte à edição e depuração de código C/C++ e as funcionalidades de preenchimento automático e referência cruzada do IntelliSense. CMake Tools: para integrar o CMake com o Visual Studio Code. Com essa extensão o editor consegue varrer o sistema em busca dos kits de compilação disponíveis e permite disparar o processo de configuração e compilação a partir do editor. Isso já é o suficiente para começarmos a trabalhar. Ainda precisaremos de algumas configurações extras para habilitar a depuração de código, mas veremos isso na seção a seguir (1.5). Caso você queira usar outro editor ou IDE, consulte a documentação específica do produto sobre como fazer a integração com o CMake e sobre como usar o GDB/LLDB para depurar código. Importante Qualquer que seja o IDE/editor utilizado, certifique-se de que o CMake e GCC estejam instalados e visíveis no PATH de acordo com as instruções mostradas nas seções anteriores. Dicas Opcionalmente, instale a extensão CMake For VisualStudio Code para ter suporte à edição de código dos scripts CMake. Em sistemas que possuem as ferramentas extras do Clang para linting e formatação de código tais como Clang-Tidy e ClangFormat, é possível instalar extensões para usá-las em tempo real e para formatar o código automaticamente sempre que o arquivo é salvo. Uma dessas extensões é o vscode-clangd, baseado no servidor clangd do LLVM. Infelizmente essa extensão não funciona corretamente no Windows com MSYS2, mas há diversas alternativas no Visual Studio Code Marketplace. Procure extensões com as palavras-chave clang-tidy e clang-format. Essas ferramentas ajudam a evitar os erros e bugs mais comuns e melhoram bastante a produtividade. No Ubuntu, o ClangFormat e Clang-Tidy podem ser instalados com: sudo apt install clang-tidy clang-format Isso instalará também o compilador Clang. No MSYS2: pacman -S mingw-w64-x86_64-clang-tools-extra Para ativar a formatação automática de código sempre que o arquivo é salvo, adicione a chave \"editor.formatOnSave\": true no arquivo de configuração do VS Code (settings.json). Para a análise estática em tempo real de código GLSL, instale a extensão GLSL Lint. Isso ajudará a evitar bugs e erros comuns na programação dos shaders em GLSL. "],["abcg.html", "1.5 ABCg", " 1.5 ABCg Para facilitar o desenvolvimento das atividades práticas utilizaremos a biblioteca ABCg desenvolvida especialmente para esta disciplina. A ABCg permite a prototipagem rápida de aplicações gráficas interativas 3D em C++ capazes de rodar tanto no desktop (binário nativo) quanto no navegador (binário WebAssembly). Internamente a ABCg utiliza a biblioteca SDL para gerenciar o acesso a dispositivos de entrada (mouse/teclado/gamepad) e saída (vídeo e áudio) de forma independente de plataforma, e a biblioteca GLEW para acesso às funções da API gráfica OpenGL. Além disso, a API do Emscripten é utilizada sempre que a aplicação é compilada para gerar binário WebAssembly. A ABCg é mais propriamente um framework do que uma biblioteca de funções, pois assume o controle da aplicação. Por outro lado, a camada de abstração para as APIs utilizadas é mínima e é possível acessar as funções da SDL e OpenGL diretamente (e faremos isso sempre que possível). Outras bibliotecas também utilizadas e que podem ser acessadas diretamente são: CPPIterTools: para o suporte a laços range-based em C++ usando funções do tipo range, enumerate e zip similares às do Python; Dear ImGui: para gerenciamento de widgets de interface gráfica do usuário, tais como janelas, botões e caixas de edição; {fmt}: como alternativa mais eficiente ao stdio da linguagem C (printf, scanf, etc) e iostreams do C++ (std::cout, std::cin, etc), e para formatação de strings com uma sintaxe similar ao str-format do Python; Guidelines Support Library (GSL): para uso de funções e tipos de dados recomendados pelo C++ Core Guidelines; OpenGL Mathematics (GLM): para suporte a operações de transformação geométrica com vetores e matrizes; tinyobjloader: para a leitura de modelos 3D no formato Wavefront OBJ. A seguir veremos como instalar e compilar a ABCg junto com um exemplo de uso. Instalação Em um terminal, clone o repositório do GitHub: git clone https://github.com/hbatagelo/abcg.git Observação A versão mais recente da ABCg (atualmente v2.0.0) também pode ser baixada como um arquivo compactado de https://github.com/hbatagelo/abcg/releases/latest. O repositório tem a estrutura mostrada a seguir. Para simplificar, os arquivos e subdiretórios .git* foram omitidos: abcg  .clang-format  .clang-tidy  build.bat  build.sh  build-wasm.bat  build-wasm.sh  CMakeLists.txt  LICENSE  README.md  runweb.bat  runweb.sh  VERSION.md  abcg   ...  cmake   ...  examples   ...  public  ... Os arquivos .clang-format e .clang-tidy são arquivos de configuração utilizados pelas ferramentas ClangFormat (formatação) e Clang-Tidy (linter) caso estejam instaladas. Os arquivos .sh são shell scripts de compilação e execução em linha de comando. Note que há scripts correspondentes com extensão .bat para usar no Prompt de Comando do Windows (o PowerShell não é suportado): build.sh: para compilar a biblioteca e os exemplos em binários nativos; build-wasm.sh: similar ao build.sh, mas para gerar binário em WebAssembly dentro do subdiretório public; runweb.sh: para rodar um servidor web local que serve o conteúdo de public. O arquivo CMakeLists.txt é o script de configuração utilizado internamente pelo CMake. Os subdiretórios são os seguintes: abcg contém o código-fonte da biblioteca e suas dependências; cmake contém scripts auxiliares de configuração do CMake; examples contém um exemplo de uso da ABCg: um Hello, World! que usa OpenGL e interface da ImGui; public contém páginas web para exibir o exemplo Hello, World! no navegador. Compilando em linha de comando Execute o script build.sh (Linux/macOS) ou build.bat (Windows) para iniciar o processo de configuração e construção. A saída será similar a esta (o exemplo a seguir é do Windows): -- The C compiler identification is GNU 10.3.0 -- The CXX compiler identification is GNU 10.3.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: C:/msys64/mingw64/bin/gcc.exe - skipped -- Detecting C compile features -- Detecting C compile features - done -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: C:/msys64/mingw64/bin/g++.exe - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done Using ccache -- Found OpenGL: opengl32 -- Found GLEW: C:/msys64/mingw64/lib/cmake/glew/glew-config.cmake -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success -- Found Threads: TRUE -- Found SDL2: mingw32;-mwindows;C:/msys64/mingw64/lib/libSDL2main.a;C:/msys64/mingw64/lib/libSDL2.dll.a -- Found SDL2_image: C:/msys64/mingw64/lib/libSDL2_image.dll.a -- Configuring done -- Generating done -- Build files have been written to: C:/abcg/build ... [22/22] Linking CXX executable bin\\helloworld.exe Ao final, os binários estarão disponíveis no subdiretório build. A biblioteca estática estará em build/abcg/libabcg.a e o executável do exemplo Hello, World! estará em build/bin/helloworld. Para testar, execute o helloworld. No Linux/macOS: ./build/bin/helloworld/helloworld No Windows: .\\build\\bin\\helloworld\\helloworld.exe | cat Importante No Windows, a saída deve sempre ser redirecionada para cat ou tee. Se isso não for feito, nenhuma saída de texto será exibida no terminal. Isso se deve a um bug do MSYS2. Observação Observe o conteúdo de build.sh (build.bat contém instruções equivalentes): #!/bin/bash set -euo pipefail BUILD_TYPE=Debug # Reset build directory rm -rf build mkdir -p build &amp;&amp; cd build # Configure cmake -DCMAKE_BUILD_TYPE=$BUILD_TYPE .. # Build if [[ &quot;$OSTYPE&quot; == &quot;darwin&quot;* ]]; then # macOS NUM_PROCESSORS=$(sysctl -n hw.ncpu) else NUM_PROCESSORS=$(nproc) fi cmake --build . --config $BUILD_TYPE -- -j $NUM_PROCESSORS A variável BUILD_TYPE está como Debug, mas pode ser modificada para Release, MinSizeRel ou RelWithDebInfo. Use a opção Debug (padrão) ou RelWithDebInfo enquanto estiver depurando o código. Use Release para gerar um binário otimizado e sem arquivos de símbolos de depuração (otimiza para gerar código mais rápido) ou MinSizeRel (otimiza para gerar binário de menor tamanho). Observe que o script apaga o subdiretório build antes de criá-lo novamente. Portanto, não salve arquivos dentro de build pois eles serão apagados na próxima compilação! A geração dos binários usando o CMake é composta de duas etapas: configuração (cmake -DCMAKE_BUILD_TYPE=$BUILD_TYPE ..) e construção (cmake --build . --config $BUILD_TYPE). A configuração gera os scripts do sistema de compilação nativo (por exemplo, arquivos Makefile ou Ninja). A construção dispara a compilação e ligação usando tais scripts. Todos os arquivos gerados na configuração e construção ficam armazenados no subdiretório build. Compilando no Visual Studio Code Primeiramente, clone o repositório abcg do GitHub como mostrado na seção anterior. Apague o subdiretório build caso você já tenha compilado via linha de comando. No Visual Studio Code, selecione o menu File &gt; Open Folder e abra a pasta abcg. No canto inferior direito da janela aparecerá uma notificação solicitando se você quer configurar o projeto. Selecione Yes. Ao fazer isso, será feita uma varredura no sistema para identificar os compiladores e toolchains visíveis no PATH. Uma lista de kits encontrados aparecerá na janela Output do CMake/Build, como a seguir: [kit] Found Kit: Clang 11.0.0 [kit] Found Kit: GCC for x86_64-w64-mingw32 10.2.0 Ao final da varredura, selecione o kit GCC for x86_64-w64-mingw32 versão 10 ou posterior. Ao fazer isso, será iniciado o processo de configuração do CMake. Esse processo gera os arquivos que serão utilizados pelo sistema de construção nativo dentro de um subdiretório build do projeto. Se aparecer uma notificação pedindo para configurar o projeto sempre que ele for aberto, Responda Yes: Após o término da configuração do CMake, aparecerá uma outra notificação solicitando permissão para configurar o Intellisense. Responda Allow. Se, além disso, aparecer uma notificação sobre o arquivo compile_commands.json, como a seguir, responda Yes novamente: compile_commands.json é um arquivo gerado automaticamente pelo CMake e que contém os comandos de compilação e o caminho de cada unidade de tradução utilizada no projeto. O IntelliSense utiliza as informações desse arquivo para habilitar as referências cruzadas. Importante A construção dos projetos usando o CMake é feita em duas etapas: Configuração: consiste na geração dos scripts do sistema de compilação nativo (por exemplo, arquivos Makefile ou Ninja); Construção: consiste no disparo da compilação e ligação usando os scripts gerados na configuração, além da execução de etapas de pré e pós-construção definidas nos scripts dos arquivos CMakeList.txt. Tanto os arquivos da configuração quanto os da construção (binários) são gravados no subdiretório build. Geralmente a configuração só precisa ser feita uma vez e depois refeita caso o subdiretório build tenha sido apagado, ou após a alteração do kit de compilação, ou após a alteração do build type (por exemplo, de Debug para Release). Como indicado na figura abaixo, na barra de status há botões para selecionar o build type e configurar o CMake, selecionar o kit de compilação, e construir a aplicação. A opção de construir já se encarrega de configurar o CMake caso os arquivos de configuração ainda não tenham sido gerados. Essas opções também estão disponíveis na paleta de comandos do editor, acessada com Ctrl+Shift+P. Os comandos são: CMake: Select Variant: para selecionar um build type; CMake: Select a Kit: para selecionar um kit de compilação; CMake: Configure: para configurar o CMake usando o kit e o build type atual; CMake: Build: para construir o projeto. Observação Os build types permitidos no CMake são: Debug para gerar binários não otimizados e com arquivos de símbolos de depuração. Esse é o build type padrão; RelWithDebInfo para gerar arquivos de símbolos de depuração com binários otimizados; Release para gerar binários otimizados e favorecer código mais rápido. Essa opção não gera os arquivos de símbolos de depuração; MinSizeRel, semelhante ao Release, mas a otimização tenta gerar binário de menor tamanho. Para compilar e gerar os binários, tecle F7 ou clique em Build na barra de status. O progresso será exibido na janela Output do CMake/Build. Se a construção terminar com sucesso, a última linha de texto da janela Output será: [build] Build finished with exit code 0 Os arquivos gerados na construção ficam armazenados no subdiretório build, da mesma forma como ocorre na compilação via linha de comando. Para testar, abra um terminal e execute ./build/bin/helloworld/helloworld (Linux/macOS) ou .\\build\\bin\\helloworld\\helloworld.exe (Windows). Atenção A configuração do CMake gerada a partir do Visual Studio Code não é necessariamente a mesma gerada usando os scripts de linha de comando: o compilador pode ser diferente, ou o build type pode ser diferente. Se em algum momento você construir o projeto via linha de comando usando os scripts .sh ou .bat e depois quiser construir pelo editor, certifique-se de apagar o subdiretório build antes de entrar no VS Code. Isso forçará uma nova configuração do CMake e evitará erros de incompatibilidade entre as configurações. Depurando no Visual Studio Code Podemos depurar o código com GDB ou LLDB usando a interface do Visual Studio Code. Após construir o projeto com build type Debug ou RelWithDebInfo, selecione a opção Run (Ctrl+Shift+D ou botão na barra de atividades) e então a opção create a launch.json file para criar um arquivo launch.json no subdiretório .vscode da pasta do projeto: Em Select Environment, selecione C++ (GDB/LLDB). Isso criará uma configuração inicial para o arquivo json: No arquivo launch.json, modifique o valor da chave program para apontar para o executável que se deseja depurar. Por exemplo, ${workspaceFolder}/build/bin/helloworld/helloworld para apontar para o executável do Hello, World! Observação ${workspaceFolder} é uma variável pré-definida do Visual Studio Code que contém o caminho da pasta do projeto. Consulte a documentação para informações sobre outras variáveis disponíveis. Modifique o valor da chave miDebuggerPath para o caminho do executável do GDB ou LLDB, ou deixe vazio para usar o padrão do sistema. No Windows, a chave miDebuggerPath deve conter explicitamente o caminho completo para o GDB, que é C:\\msys64\\mingw64\\bin\\gdb.exe caso o MSYS2 tenha sido instalado em C:\\msys64. No Windows também é necessário configurar o terminal padrão do VS Code para Command Prompt no lugar de PowerShell. O exemplo abaixo mostra o conteúdo completo de launch.json para depurar o Hello, World! no Windows. { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceFolder}/build/bin/helloworld/helloworld.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] } ] } Observe que o valor da chave externalConsole foi modificado para true para que um terminal de saída seja aberto durante a depuração. Consulte a documentação sobre depuração para informações sobre outras opções e informações gerais sobre como depurar código no editor. Após modificar o arquivo launch.json, selecione novamente a opção Run na barra de atividades ou tecle F5 para iniciar o programa no modo de depuração. Reedite o arquivo launch.json sempre que mudar o nome do executável que se queira depurar. Compilando para WebAssembly Podemos compilar as aplicações ABCg para WebAssembly de modo a rodá-las diretamente no navegador. A construção é feita via linha de comando usando o toolchain Emscripten. Acompanhe a seguir como construir o exemplo Hello, World! para WebAssembly e abri-lo no navegador: Em um terminal (shell ou Prompt de Comando), ative as variáveis de ambiente do Emscripten (script emsdk-env.sh/emsdk-env.bat do SDK). Após isso, o compilador emcc deverá estar visível no PATH; No diretório abcg, execute build-wasm.sh (Linux/macOS) ou build-wasm.bat (Windows). Isso iniciará a configuração do CMake e a construção dos binários. Os arquivos resultantes serão gerados no subdiretório public: nesse caso, helloworld.data (arquivo de dados/assets), helloworld.js (arquivo JavaScript) e helloworld.wasm (binário WebAssembly); Execute o script runweb.sh (Linux/macOS) ou runweb.bat (Windows) para rodar um servidor web local. O conteúdo de public estará disponível em http://localhost:8080/; Abra a página http://localhost:8080/helloworld.html que chama o script helloworld.js recém-criado. A página HTML não faz parte do processo de construção e foi criada previamente. O resultado será semelhante ao exibido a seguir (uma aplicação mostrando um triângulo colorido e uma caixa de diálogo com alguns controles de interface). A pequena janela de texto abaixo da janela da aplicação mostra o conteúdo do terminal. Nesse caso, são exibidas algumas informações sobre o OpenGL (versão utilizada, fornecedor do driver, etc). Observação O subdiretório public contém, além do helloworld.html: full_window.html: para exibir o Hello, World! ocupando a janela inteira do navegador; full_window_console.html: idêntico ao anterior, mas com a sobreposição das mensagens do console na tela. Nos próximos capítulos veremos como construir novas aplicações usando a ABCg. Dica Aproveite o restante da primeira semana de aula para se familiarizar com os conceitos do chamado C++ moderno (C++11 em diante): ponteiros inteligentes (smart pointers), expressões lambda, variáveis auto e semântica de movimentação (move semantics). Isso facilitará o entendimento do código da ABCg nos próximos capítulos. Uma referência rápida (cheatsheet) ao C++ moderno está disponível em https://github.com/AnthonyCalandra/modern-cpp-features. Um excelente livro é o A Tour of C++, de Bjarne Stroustrup. Se não puder ter acesso ao livro, há recursos gratuitos como os sites learncpp.com e tutorialspoint.com. A documentação da Microsoft sobre C++ é uma opção em português. Há uma referência sobre a linguagem C++ e sobre a biblioteca C++ padrão. Consulte também o C++ Core Guidelines para ficar a par das boas práticas de programação. Para uma referência completa da linguagem, consulte cppreference.com. Algumas partes estão traduzidas para o português. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
