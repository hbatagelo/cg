<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>3.4 Triângulo de Sierpinski | MCTA008-17 Computação Gráfica</title>
  <meta name="description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  <meta name="generator" content="bookdown 0.24 and GitBook 2.6.7" />

  <meta property="og:title" content="3.4 Triângulo de Sierpinski | MCTA008-17 Computação Gráfica" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  <meta name="github-repo" content="hbatagelo/cgbook" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="3.4 Triângulo de Sierpinski | MCTA008-17 Computação Gráfica" />
  
  <meta name="twitter:description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="framebuffer.html"/>
<link rel="next" href="referências.html"/>
<script src="libs/header-attrs-2.10/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { font-weight: bold; } /* Alert */
code span.an { font-style: italic; } /* Annotation */
code span.cf { font-weight: bold; } /* ControlFlow */
code span.co { font-style: italic; } /* Comment */
code span.cv { font-style: italic; } /* CommentVar */
code span.do { font-style: italic; } /* Documentation */
code span.dt { text-decoration: underline; } /* DataType */
code span.er { font-weight: bold; } /* Error */
code span.in { font-style: italic; } /* Information */
code span.kw { font-weight: bold; } /* Keyword */
code span.pp { font-weight: bold; } /* Preprocessor */
code span.wa { font-style: italic; } /* Warning */
</style>

<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Computação Gráfica</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Apresentação</a>
<ul>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html"><i class="fa fa-check"></i>Pré-requisitos</a>
<ul>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html#atividades-práticas"><i class="fa fa-check"></i>Atividades práticas</a></li>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html#visualizando-este-site"><i class="fa fa-check"></i>Visualizando este site</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="1" data-path="config.html"><a href="config.html"><i class="fa fa-check"></i><b>1</b> Configuração do ambiente</a>
<ul>
<li class="chapter" data-level="1.1" data-path="linux.html"><a href="linux.html"><i class="fa fa-check"></i><b>1.1</b> Linux</a>
<ul>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#habilitando-o-opengl"><i class="fa fa-check"></i>Habilitando o OpenGL</a></li>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#atualizando-o-gcc"><i class="fa fa-check"></i>Atualizando o GCC</a></li>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#instalando-o-emscripten"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="macos.html"><a href="macos.html"><i class="fa fa-check"></i><b>1.2</b> macOS</a>
<ul>
<li class="chapter" data-level="" data-path="macos.html"><a href="macos.html#instalando-o-emscripten-1"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="windows.html"><a href="windows.html"><i class="fa fa-check"></i><b>1.3</b> Windows</a>
<ul>
<li class="chapter" data-level="" data-path="windows.html"><a href="windows.html#habilitando-o-opengl-1"><i class="fa fa-check"></i>Habilitando o OpenGL</a></li>
<li class="chapter" data-level="" data-path="windows.html"><a href="windows.html#instalando-o-emscripten-2"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="vscode.html"><a href="vscode.html"><i class="fa fa-check"></i><b>1.4</b> Visual Studio Code</a></li>
<li class="chapter" data-level="1.5" data-path="abcg.html"><a href="abcg.html"><i class="fa fa-check"></i><b>1.5</b> ABCg</a>
<ul>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#instalação"><i class="fa fa-check"></i>Instalação</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-em-linha-de-comando"><i class="fa fa-check"></i>Compilando em linha de comando</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-no-visual-studio-code"><i class="fa fa-check"></i>Compilando no Visual Studio Code</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#depurando-no-visual-studio-code"><i class="fa fa-check"></i>Depurando no Visual Studio Code</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-para-webassembly"><i class="fa fa-check"></i>Compilando para WebAssembly</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> Introdução</a>
<ul>
<li class="chapter" data-level="2.1" data-path="áreas-correlatas.html"><a href="áreas-correlatas.html"><i class="fa fa-check"></i><b>2.1</b> Áreas correlatas</a></li>
<li class="chapter" data-level="2.2" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html"><i class="fa fa-check"></i><b>2.2</b> Linha do tempo</a>
<ul>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section"><i class="fa fa-check"></i>1950</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-1"><i class="fa fa-check"></i>1960</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-2"><i class="fa fa-check"></i>1970</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-3"><i class="fa fa-check"></i>1980</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-4"><i class="fa fa-check"></i>1990</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-5"><i class="fa fa-check"></i>2000</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-6"><i class="fa fa-check"></i>2010</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-7"><i class="fa fa-check"></i>2020</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="firstapp.html"><a href="firstapp.html"><i class="fa fa-check"></i><b>2.3</b> Primeiro programa</a>
<ul>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#configuração-inicial"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#main.cpp"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#openglwindow.hpp"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#openglwindow.cpp"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#compilando-para-webassembly-1"><i class="fa fa-check"></i>Compilando para WebAssembly</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="graphicssystem.html"><a href="graphicssystem.html"><i class="fa fa-check"></i><b>3</b> Sistemas gráficos</a>
<ul>
<li class="chapter" data-level="3.1" data-path="vectorxraster.html"><a href="vectorxraster.html"><i class="fa fa-check"></i><b>3.1</b> Vetorial <em>x</em> matricial</a>
<ul>
<li class="chapter" data-level="" data-path="vectorxraster.html"><a href="vectorxraster.html#representação-vetorial"><i class="fa fa-check"></i>Representação vetorial</a></li>
<li class="chapter" data-level="" data-path="vectorxraster.html"><a href="vectorxraster.html#representação-matricial"><i class="fa fa-check"></i>Representação matricial</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="es.html"><a href="es.html"><i class="fa fa-check"></i><b>3.2</b> Dispositivos de E/S</a>
<ul>
<li class="chapter" data-level="" data-path="es.html"><a href="es.html#dispositivos-de-entrada"><i class="fa fa-check"></i>Dispositivos de entrada</a></li>
<li class="chapter" data-level="" data-path="es.html"><a href="es.html#dispositivos-de-saída"><i class="fa fa-check"></i>Dispositivos de saída</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="framebuffer.html"><a href="framebuffer.html"><i class="fa fa-check"></i><b>3.3</b> Framebuffer</a>
<ul>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#screen-tearing"><i class="fa fa-check"></i>Screen tearing</a></li>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#vsync"><i class="fa fa-check"></i>Vsync</a></li>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#backbuffering"><i class="fa fa-check"></i>Backbuffering</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="sierpinski.html"><a href="sierpinski.html"><i class="fa fa-check"></i><b>3.4</b> Triângulo de Sierpinski</a>
<ul>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#configuração-inicial-1"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#main.cpp-1"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#openglwindow.hpp-1"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#openglwindow.cpp-1"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="referências.html"><a href="referências.html"><i class="fa fa-check"></i>Referências</a></li>
<li class="divider"></li>
<li>
<a href="mailto:harlen.batagelo@ufabc.edu.br" target="blank">Harlen Batagelo</a>
<a href="mailto:bruno.marques@ufabc.edu.br" target="blank">Bruno Marques</a>
<br>
</li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">MCTA008-17 Computação Gráfica</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="sierpinski" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Triângulo de Sierpinski</h2>
<p>O triângulo de Sierpinski é um fractal que pode ser gerado por um tipo de sistema dinâmico chamado de sistema de função iterativa (<em>iterated function system</em>, ou IFS). Esse processo pode ser implementado através de um algoritmo chamado <a href="https://mathworld.wolfram.com/ChaosGame.html"><em>jogo do caos</em></a>.</p>
<p>Para jogar o jogo do caos, vamos começar primeiro definindo três pontos <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> e <span class="math inline">\(C\)</span> não colineares. Esses pontos formarão os vértices de um triângulo fractal. Por exemplo, <span class="math inline">\(A=(0, 1)\)</span>, <span class="math inline">\(B=(-1, -1)\)</span> e <span class="math inline">\(C=(1, -1)\)</span>:</p>
<p><img src="images/03_sierpinski1.svg" width="55%" style="display: block; margin: auto;" /></p>
<p>Além dos pontos <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> e <span class="math inline">\(C\)</span>, definiremos mais um ponto <span class="math inline">\(P\)</span> em uma posição aleatória do plano. Com <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> e <span class="math inline">\(P\)</span> definidos, o jogo do caos consiste nos seguintes passos:</p>
<ol style="list-style-type: decimal">
<li>Mova <span class="math inline">\(P\)</span> para o ponto médio entre <span class="math inline">\(P\)</span> e um dos pontos <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> escolhido de forma aleatória;</li>
<li>Volte ao passo 1.</li>
</ol>
<p>Para gerar o triângulo de Sierpinski, basta desenharmos <span class="math inline">\(P\)</span> a cada iteração. O jogo não tem fim, mas quanto maior o número de iterações, mais pontos serão desenhados e mais detalhes terá o fractal (figura <a href="sierpinski.html#fig:sierpinski1">3.30</a>).</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:sierpinski1"></span>
<img src="images/03_sierpinski2.gif" alt="Triângulo de Sierpinski desenhado com 1.000, 10.000 e 100.000 iterações em uma área de 210x210 pixels."  />
<p class="caption">
Figura 3.30: Triângulo de Sierpinski desenhado com 1.000, 10.000 e 100.000 iterações em uma área de 210x210 pixels.
</p>
</div>
<p>Vamos implementar o jogo do caos com a ABCg, usando a estrutura da aplicação que fizemos no projeto <code>firstapp</code> (seção <a href="firstapp.html#firstapp">2.3</a>). O procedimento será simples: para cada chamada de <code>paintGL</code>, faremos uma iteração do jogo e desenharemos um ponto na posição <span class="math inline">\(P\)</span> usando um comando de renderização do OpenGL. Os pontos desenhados serão acumulados no framebuffer e visualizaremos o fractal.</p>
<div id="configuração-inicial-1" class="section level3 unnumbered">
<h3>Configuração inicial</h3>
<p>Repita a configuração inicial do projeto <code>firstapp</code>, mas mudando o nome do projeto para <code>sierpinski</code>.</p>
<p>O arquivo <code>abcg/examples/CMakeLists.txt</code> ficará assim:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb87-1"><a href="sierpinski.html#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">add_subdirectory</span>(helloworld)</span>
<span id="cb87-2"><a href="sierpinski.html#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">add_subdirectory</span>(firstapp)</span>
<span id="cb87-3"><a href="sierpinski.html#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">add_subdirectory</span>(sierpinski)</span></code></pre></div>
<p>Para a construção não ficar muito lenta, podemos comentar as linhas de <code>add_subdirectory</code> dos projetos anteriores para que eles não sejam compilados. Por exemplo:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb88-1"><a href="sierpinski.html#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co">#add_subdirectory(helloworld)</span></span>
<span id="cb88-2"><a href="sierpinski.html#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="co">#add_subdirectory(firstapp)</span></span>
<span id="cb88-3"><a href="sierpinski.html#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="kw">add_subdirectory</span>(sierpinski)</span></code></pre></div>
<p>O arquivo <code>abcg/examples/sierpinski/CMakeLists.txt</code> ficará assim:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb89-1"><a href="sierpinski.html#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">project</span>(sierpinski)</span>
<span id="cb89-2"><a href="sierpinski.html#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="kw">add_executable</span>(<span class="dv">${PROJECT_NAME}</span> main.cpp openglwindow.cpp)</span>
<span id="cb89-3"><a href="sierpinski.html#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="fu">enable_abcg</span>(<span class="dv">${PROJECT_NAME}</span>)</span></code></pre></div>
<p>Crie também os arquivos <code>main.cpp</code>, <code>openglwindow.cpp</code> e <code>openglwindow.hpp</code> em <code>abcg/examples/sierpinski</code>. Vamos editá-los a seguir.</p>
</div>
<div id="main.cpp-1" class="section level3 unnumbered">
<h3>main.cpp</h3>
<p>O conteúdo de <code>main.cpp</code> ficará como a seguir:</p>
<div class="sourceCode" id="cb90" startFrom="1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb90-1"><a href="sierpinski.html#cb90-1"></a><span class="pp">#include </span><span class="im">&lt;fmt/core.h&gt;</span></span>
<span id="cb90-2"><a href="sierpinski.html#cb90-2"></a></span>
<span id="cb90-3"><a href="sierpinski.html#cb90-3"></a><span class="pp">#include </span><span class="im">&quot;abcg.hpp&quot;</span></span>
<span id="cb90-4"><a href="sierpinski.html#cb90-4"></a><span class="pp">#include </span><span class="im">&quot;openglwindow.hpp&quot;</span></span>
<span id="cb90-5"><a href="sierpinski.html#cb90-5"></a></span>
<span id="cb90-6"><a href="sierpinski.html#cb90-6"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</span>
<span id="cb90-7"><a href="sierpinski.html#cb90-7"></a>  <span class="cf">try</span> {</span>
<span id="cb90-8"><a href="sierpinski.html#cb90-8"></a>    <span class="co">// Create application instance</span></span>
<span id="cb90-9"><a href="sierpinski.html#cb90-9"></a>    abcg::Application app(argc, argv);</span>
<span id="cb90-10"><a href="sierpinski.html#cb90-10"></a></span>
<span id="cb90-11"><a href="sierpinski.html#cb90-11"></a>    <span class="co">// Create OpenGL window</span></span>
<span id="cb90-12"><a href="sierpinski.html#cb90-12"></a>    <span class="kw">auto</span> window{<span class="bu">std::</span>make_unique&lt;OpenGLWindow&gt;()};</span>
<span id="cb90-13"><a href="sierpinski.html#cb90-13"></a>    window-&gt;setOpenGLSettings(</span>
<span id="cb90-14"><a href="sierpinski.html#cb90-14"></a>        {.samples = <span class="dv">2</span>, .preserveWebGLDrawingBuffer = <span class="kw">true</span>});</span>
<span id="cb90-15"><a href="sierpinski.html#cb90-15"></a>    window-&gt;setWindowSettings({.width = <span class="dv">600</span>,</span>
<span id="cb90-16"><a href="sierpinski.html#cb90-16"></a>                               .height = <span class="dv">600</span>,</span>
<span id="cb90-17"><a href="sierpinski.html#cb90-17"></a>                               .showFullscreenButton = <span class="kw">false</span>,</span>
<span id="cb90-18"><a href="sierpinski.html#cb90-18"></a>                               .title = <span class="st">&quot;Sierpinski Triangle&quot;</span>});</span>
<span id="cb90-19"><a href="sierpinski.html#cb90-19"></a></span>
<span id="cb90-20"><a href="sierpinski.html#cb90-20"></a>    <span class="co">// Run application</span></span>
<span id="cb90-21"><a href="sierpinski.html#cb90-21"></a>    app.run(<span class="bu">std::</span>move(window);</span>
<span id="cb90-22"><a href="sierpinski.html#cb90-22"></a>  } <span class="cf">catch</span> (<span class="at">const</span> abcg::Exception &amp;exception) {</span>
<span id="cb90-23"><a href="sierpinski.html#cb90-23"></a>    fmt::print(stderr, <span class="st">&quot;</span><span class="sc">{}\n</span><span class="st">&quot;</span>, exception.what());</span>
<span id="cb90-24"><a href="sierpinski.html#cb90-24"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb90-25"><a href="sierpinski.html#cb90-25"></a>  }</span>
<span id="cb90-26"><a href="sierpinski.html#cb90-26"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb90-27"><a href="sierpinski.html#cb90-27"></a>}</span></code></pre></div>
<p>Esse código é bem parecido com o <code>main.cpp</code> do projeto <code>firstapp</code>. As únicas diferenças estão nas linhas 13 a 18:</p>
<div class="sourceCode" id="cb91" startFrom="13"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 12;"><span id="cb91-13"><a href="sierpinski.html#cb91-13"></a>    window-&gt;setOpenGLSettings(</span>
<span id="cb91-14"><a href="sierpinski.html#cb91-14"></a>        {.samples = <span class="dv">2</span>, .preserveWebGLDrawingBuffer = <span class="kw">true</span>});</span>
<span id="cb91-15"><a href="sierpinski.html#cb91-15"></a>    window-&gt;setWindowSettings({.width = <span class="dv">600</span>,</span>
<span id="cb91-16"><a href="sierpinski.html#cb91-16"></a>                               .height = <span class="dv">600</span>,</span>
<span id="cb91-17"><a href="sierpinski.html#cb91-17"></a>                               .showFullscreenButton = <span class="kw">false</span>,</span>
<span id="cb91-18"><a href="sierpinski.html#cb91-18"></a>                               .title = <span class="st">&quot;Sierpinski Triangle&quot;</span>});</span></code></pre></div>
<ul>
<li><code>setOpenGLSettings</code> é um método de <code>abcg::OpenGLWindow</code> que recebe uma estrutura <code>abcg::OpenGLSettings</code> com as configurações de inicialização do OpenGL. Essas configurações são usadas pela SDL no momento da criação de um “contexto do OpenGL” que representa o framebuffer vinculado à janela:
<ul>
<li>O atributo <code>samples = 2</code> faz com que o framebuffer suporte suavização de serrilhado (<em>antialiasing</em>) das primitivas do OpenGL;</li>
<li>O atributo <code>preserveWebGLDrawingBuffer = true</code> é utilizado apenas no binário em WebAssembly. No WebGL, <code>preserveDrawingBuffer</code> é uma configuração de criação do contexto do OpenGL que faz com que o framebuffer vinculado ao canvas da página Web não seja apagado entre os quadros de exibição.</li>
</ul></li>
<li>Em <code>setWindowSettings</code>, utilizamos alguns atributos novos de definição de propriedades da janela. Definimos a largura (<code>width</code>) e altura (<code>height</code>) inicial da janela, e desligamos a exibição do botão de tela cheia (<code>showFullscreenButton = false</code>) para que o botão não obstrua o desenho do triângulo. Mesmo sem o botão, o modo janela pode ser alternado com o modo de tela cheia pela tecla <code>F11</code>.</li>
</ul>
</div>
<div id="openglwindow.hpp-1" class="section level3 unnumbered">
<h3>openglwindow.hpp</h3>
<p>Na definição da classe <code>OpenGLWindow</code>, vamos substituir novos métodos virtuais de <code>abcg::OpenGLWindow</code> e vamos definir variáveis que serão utilizados para atualizar o jogo do caos e para desenhar o ponto na tela:</p>
<div class="sourceCode" id="cb92" startFrom="1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb92-1"><a href="sierpinski.html#cb92-1"></a><span class="pp">#ifndef OPENGLWINDOW_HPP_</span></span>
<span id="cb92-2"><a href="sierpinski.html#cb92-2"></a><span class="pp">#define OPENGLWINDOW_HPP_</span></span>
<span id="cb92-3"><a href="sierpinski.html#cb92-3"></a></span>
<span id="cb92-4"><a href="sierpinski.html#cb92-4"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb92-5"><a href="sierpinski.html#cb92-5"></a><span class="pp">#include </span><span class="im">&lt;glm/vec2.hpp&gt;</span></span>
<span id="cb92-6"><a href="sierpinski.html#cb92-6"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb92-7"><a href="sierpinski.html#cb92-7"></a></span>
<span id="cb92-8"><a href="sierpinski.html#cb92-8"></a><span class="pp">#include </span><span class="im">&quot;abcg.hpp&quot;</span></span>
<span id="cb92-9"><a href="sierpinski.html#cb92-9"></a></span>
<span id="cb92-10"><a href="sierpinski.html#cb92-10"></a><span class="kw">class</span> OpenGLWindow : <span class="kw">public</span> abcg::OpenGLWindow {</span>
<span id="cb92-11"><a href="sierpinski.html#cb92-11"></a> <span class="kw">protected</span>:</span>
<span id="cb92-12"><a href="sierpinski.html#cb92-12"></a>  <span class="dt">void</span> initializeGL() <span class="kw">override</span>;</span>
<span id="cb92-13"><a href="sierpinski.html#cb92-13"></a>  <span class="dt">void</span> paintGL() <span class="kw">override</span>;</span>
<span id="cb92-14"><a href="sierpinski.html#cb92-14"></a>  <span class="dt">void</span> paintUI() <span class="kw">override</span>;</span>
<span id="cb92-15"><a href="sierpinski.html#cb92-15"></a>  <span class="dt">void</span> resizeGL(<span class="dt">int</span> width, <span class="dt">int</span> height) <span class="kw">override</span>;</span>
<span id="cb92-16"><a href="sierpinski.html#cb92-16"></a>  <span class="dt">void</span> terminateGL() <span class="kw">override</span>;</span>
<span id="cb92-17"><a href="sierpinski.html#cb92-17"></a></span>
<span id="cb92-18"><a href="sierpinski.html#cb92-18"></a> <span class="kw">private</span>:</span>
<span id="cb92-19"><a href="sierpinski.html#cb92-19"></a>  GLuint <span class="va">m_vao</span>{};</span>
<span id="cb92-20"><a href="sierpinski.html#cb92-20"></a>  GLuint <span class="va">m_vboVertices</span>{};</span>
<span id="cb92-21"><a href="sierpinski.html#cb92-21"></a>  GLuint <span class="va">m_program</span>{};</span>
<span id="cb92-22"><a href="sierpinski.html#cb92-22"></a></span>
<span id="cb92-23"><a href="sierpinski.html#cb92-23"></a>  <span class="dt">int</span> <span class="va">m_viewportWidth</span>{};</span>
<span id="cb92-24"><a href="sierpinski.html#cb92-24"></a>  <span class="dt">int</span> <span class="va">m_viewportHeight</span>{};</span>
<span id="cb92-25"><a href="sierpinski.html#cb92-25"></a></span>
<span id="cb92-26"><a href="sierpinski.html#cb92-26"></a>  <span class="bu">std::</span>default_random_engine <span class="va">m_randomEngine</span>;</span>
<span id="cb92-27"><a href="sierpinski.html#cb92-27"></a></span>
<span id="cb92-28"><a href="sierpinski.html#cb92-28"></a>  <span class="at">const</span> <span class="bu">std::</span>array&lt;glm::vec2, <span class="dv">3</span>&gt; <span class="va">m_points</span>{glm::vec2( <span class="dv">0</span>,  <span class="dv">1</span>), </span>
<span id="cb92-29"><a href="sierpinski.html#cb92-29"></a>                                          glm::vec2(-<span class="dv">1</span>, -<span class="dv">1</span>),</span>
<span id="cb92-30"><a href="sierpinski.html#cb92-30"></a>                                          glm::vec2( <span class="dv">1</span>, -<span class="dv">1</span>)};</span>
<span id="cb92-31"><a href="sierpinski.html#cb92-31"></a>  glm::vec2 <span class="va">m_P</span>{};</span>
<span id="cb92-32"><a href="sierpinski.html#cb92-32"></a></span>
<span id="cb92-33"><a href="sierpinski.html#cb92-33"></a>  <span class="dt">void</span> setupModel();</span>
<span id="cb92-34"><a href="sierpinski.html#cb92-34"></a>};</span>
<span id="cb92-35"><a href="sierpinski.html#cb92-35"></a><span class="pp">#endif</span></span></code></pre></div>
<p>Observe que, além de usarmos os métodos <code>initializeGL</code>, <code>paintGL</code> e <code>paintUI</code>, estamos agora substituindo mais dois métodos virtuais de <code>abcg::OpenGLWindow</code>:</p>
<ul>
<li><p><code>resizeGL</code> <strong>é chamado pela ABCg sempre que o tamanho da janela é alterado</strong>. O novo tamanho é recebido pelos parâmetros <code>width</code> e <code>height</code>. Na nossa aplicação, vamos armazenar esses valores nas variáveis <code>m_viewportWidth</code> (linha 23) e <code>m_viewportHeight</code> (linha 24). Precisamos disso para fazer com que a janela de exibição (<em>viewport</em>) do OpenGL tenha o mesmo tamanho da janela da aplicação. O conceito de viewport será detalhado mais adiante.</p></li>
<li><p><code>terminateGL</code> <strong>é chamado pela ABCg quando a janela é destruída</strong>, no fim da aplicação. Essa é a função complementar de <code>initializeGL</code>, usada para liberar os recursos do OpenGL que foram alocados no <code>initializeGL</code> ou durante a aplicação.</p></li>
</ul>
<p>Da linha 19 a 31 temos a definição das variáveis da classe:</p>
<div class="sourceCode" id="cb93" startFrom="19"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 18;"><span id="cb93-19"><a href="sierpinski.html#cb93-19"></a>  GLuint <span class="va">m_vao</span>{};</span>
<span id="cb93-20"><a href="sierpinski.html#cb93-20"></a>  GLuint <span class="va">m_vboVertices</span>{};</span>
<span id="cb93-21"><a href="sierpinski.html#cb93-21"></a>  GLuint <span class="va">m_program</span>{};</span>
<span id="cb93-22"><a href="sierpinski.html#cb93-22"></a></span>
<span id="cb93-23"><a href="sierpinski.html#cb93-23"></a>  <span class="dt">int</span> <span class="va">m_viewportWidth</span>{};</span>
<span id="cb93-24"><a href="sierpinski.html#cb93-24"></a>  <span class="dt">int</span> <span class="va">m_viewportHeight</span>{};</span>
<span id="cb93-25"><a href="sierpinski.html#cb93-25"></a></span>
<span id="cb93-26"><a href="sierpinski.html#cb93-26"></a>  <span class="bu">std::</span>default_random_engine <span class="va">m_randomEngine</span>;</span>
<span id="cb93-27"><a href="sierpinski.html#cb93-27"></a></span>
<span id="cb93-28"><a href="sierpinski.html#cb93-28"></a>  <span class="at">const</span> <span class="bu">std::</span>array&lt;glm::vec2, <span class="dv">3</span>&gt; <span class="va">m_points</span>{glm::vec2( <span class="dv">0</span>,  <span class="dv">1</span>), </span>
<span id="cb93-29"><a href="sierpinski.html#cb93-29"></a>                                          glm::vec2(-<span class="dv">1</span>, -<span class="dv">1</span>),</span>
<span id="cb93-30"><a href="sierpinski.html#cb93-30"></a>                                          glm::vec2( <span class="dv">1</span>, -<span class="dv">1</span>)};</span>
<span id="cb93-31"><a href="sierpinski.html#cb93-31"></a>  glm::vec2 <span class="va">m_P</span>{};</span></code></pre></div>
<ul>
<li><p><code>m_vao</code>, <code>m_vboVertices</code> e <code>m_program</code> são identificadores de recursos alocados pelo OpenGL (recursos geralmente armazenados na memória da GPU). Esses recursos correspondem ao arranjo ordenado de vértices utilizado para montar as primitivas geométricas no pipeline de renderização<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a> e os shaders que definem o comportamento da renderização.</p></li>
<li><p><code>m_viewportWidth</code> e <code>m_viewportHeight</code> servem para armazenar o tamanho da janela da aplicação informado pelo <code>resizeGL</code>.</p></li>
<li><p><code>m_randomEngine</code> é um objeto do gerador de números pseudoaleatórios do C++ (observe o uso do <code>#include &lt;random&gt;</code> na linha 6). Esse objeto é utilizado para sortear a posição inicial de <span class="math inline">\(P\)</span> e para sortear qual ponto (<span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> ou <span class="math inline">\(C\)</span>) será utilizado em cada iteração do jogo do caos.</p></li>
<li><p><code>m_points</code> é um arranjo que contém a posição dos pontos <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> e <span class="math inline">\(C\)</span>. As coordenadas dos pontos são descritas por uma estrutura <code>glm::vec2</code>. O namespace <code>glm</code> contém definições da biblioteca <a href="https://github.com/g-truc/glm">OpenGL Mathematics</a> (GLM) que fornece estruturas e funções de operações matemáticas compatíveis com a especificação da linguagem de shaders do OpenGL. Observe que, para usar <code>glm::vec2</code>, incluímos o arquivo de cabeçalho <code>glm/vec2.hpp</code>.</p></li>
<li><p><code>m_P</code> é a posição do ponto <span class="math inline">\(P\)</span>.</p></li>
</ul>
<p>Além da definição das variáveis, na linha 33 é definido o método <code>setupModel</code> que cria os recursos identificados por <code>m_vao</code> e <code>m_vboVertices</code>. O método é chamado sempre que um novo ponto <span class="math inline">\(P\)</span> precisa ser desenhado.</p>
</div>
<div id="openglwindow.cpp-1" class="section level3 unnumbered">
<h3>openglwindow.cpp</h3>
<p>Vamos implementar primeiro a lógica do jogo do caos, sem desenhar nada na tela. Em seguida incluiremos o código que usa o OpenGL para desenhar os pontos.</p>
<p>Vamos começar incluindo os seguintes arquivos de cabeçalho:</p>
<div class="sourceCode" id="cb94" startFrom="1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb94-1"><a href="sierpinski.html#cb94-1"></a><span class="pp">#include </span><span class="im">&quot;openglwindow.hpp&quot;</span></span>
<span id="cb94-2"><a href="sierpinski.html#cb94-2"></a></span>
<span id="cb94-3"><a href="sierpinski.html#cb94-3"></a><span class="pp">#include </span><span class="im">&lt;fmt/core.h&gt;</span></span>
<span id="cb94-4"><a href="sierpinski.html#cb94-4"></a><span class="pp">#include </span><span class="im">&lt;imgui.h&gt;</span></span>
<span id="cb94-5"><a href="sierpinski.html#cb94-5"></a></span>
<span id="cb94-6"><a href="sierpinski.html#cb94-6"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span></code></pre></div>
<p>Em <code>OpenGLWindow::initializeGL</code>, iniciaremos o gerador de números pseudoaleatórios e sortearemos as coordenadas iniciais de <span class="math inline">\(P\)</span> (que no código é <code>m_P</code>):</p>
<div class="sourceCode" id="cb95" startFrom="8"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 7;"><span id="cb95-8"><a href="sierpinski.html#cb95-8"></a><span class="dt">void</span> OpenGLWindow::initializeGL() {</span>
<span id="cb95-9"><a href="sierpinski.html#cb95-9"></a>  <span class="co">// Start pseudo-random number generator</span></span>
<span id="cb95-10"><a href="sierpinski.html#cb95-10"></a>  <span class="kw">auto</span> seed{<span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now().time_since_epoch().count()};</span>
<span id="cb95-11"><a href="sierpinski.html#cb95-11"></a>  <span class="va">m_randomEngine</span>.seed(seed);</span>
<span id="cb95-12"><a href="sierpinski.html#cb95-12"></a></span>
<span id="cb95-13"><a href="sierpinski.html#cb95-13"></a>  <span class="co">// Randomly choose a pair of coordinates in the interval [-1; 1]</span></span>
<span id="cb95-14"><a href="sierpinski.html#cb95-14"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; realDistribution(-<span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb95-15"><a href="sierpinski.html#cb95-15"></a>  <span class="va">m_P</span>.x = realDistribution(<span class="va">m_randomEngine</span>);</span>
<span id="cb95-16"><a href="sierpinski.html#cb95-16"></a>  <span class="va">m_P</span>.y = realDistribution(<span class="va">m_randomEngine</span>);</span>
<span id="cb95-17"><a href="sierpinski.html#cb95-17"></a>}</span></code></pre></div>
<p>O gerador <code>m_randomEngine</code> é iniciado usando como semente o tempo do sistema (para isso é preciso incluir o cabeçalho <code>&lt;chrono&gt;</code>).</p>
<p>As coordenadas de <code>m_P</code> são iniciadas como valores sorteados de um intervalo de -1 a 1. O intervalo poderia ser qualquer outro, mas fazendo assim garantimos que o ponto inicial será visto na tela. Na configuração padrão do OpenGL, só conseguimos visualizar as primitivas gráficas que estão situadas entre as coordenadas <span class="math inline">\((-1, -1)\)</span> e <span class="math inline">\((1, 1)\)</span>. A coordenada <span class="math inline">\((-1, -1)\)</span> geralmente é mapeada ao canto inferior esquerdo da janela, e a coordenada <span class="math inline">\((1, 1)\)</span> é mapeada ao canto superior direito (esse mapeamento será configurado posteriormente com a função <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml"><code>glViewport</code></a>).</p>
<p>Vamos agora implementar o passo iterativo do jogo. Faremos isso no <code>paintGL</code>, de modo que cada quadro de exibição corresponderá a uma iteração<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>:</p>
<div class="sourceCode" id="cb96" startFrom="48"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 47;"><span id="cb96-48"><a href="sierpinski.html#cb96-48"></a><span class="dt">void</span> OpenGLWindow::paintGL() {</span>
<span id="cb96-49"><a href="sierpinski.html#cb96-49"></a>  <span class="co">// Randomly choose a triangle vertex index</span></span>
<span id="cb96-50"><a href="sierpinski.html#cb96-50"></a>  <span class="bu">std::</span>uniform_int_distribution&lt;<span class="dt">int</span>&gt; intDistribution(<span class="dv">0</span>, <span class="va">m_points</span>.size() - <span class="dv">1</span>);</span>
<span id="cb96-51"><a href="sierpinski.html#cb96-51"></a>  <span class="dt">int</span> index{intDistribution(<span class="va">m_randomEngine</span>)};</span>
<span id="cb96-52"><a href="sierpinski.html#cb96-52"></a></span>
<span id="cb96-53"><a href="sierpinski.html#cb96-53"></a>  <span class="co">// The new position is the midpoint between the current position and the</span></span>
<span id="cb96-54"><a href="sierpinski.html#cb96-54"></a>  <span class="co">// chosen vertex</span></span>
<span id="cb96-55"><a href="sierpinski.html#cb96-55"></a>  <span class="va">m_P</span> = (<span class="va">m_P</span> + <span class="va">m_points</span>.at(index)) / <span class="fl">2.0</span><span class="bu">f</span>;</span>
<span id="cb96-56"><a href="sierpinski.html#cb96-56"></a></span>
<span id="cb96-57"><a href="sierpinski.html#cb96-57"></a>  <span class="co">// Print coordinates to the console</span></span>
<span id="cb96-58"><a href="sierpinski.html#cb96-58"></a>  <span class="co">// fmt::print(&quot;({:+.2f}, {:+.2f})\n&quot;, m_P.x, m_P.y);</span></span>
<span id="cb96-59"><a href="sierpinski.html#cb96-59"></a>}</span></code></pre></div>
<p>Neste trecho de código, <code>index</code> é um índice do arranjo <code>m_points</code>. Assim, <code>m_points.at(index)</code> é um dos pontos <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> ou <span class="math inline">\(C\)</span> que definem os vértices do triângulo. Observe que utilizamos uma distribuição uniforme para sortear o índice. Isso é importante para que o fractal seja desenhado como esperado<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>.</p>
<p>A nova posição de <code>m_P</code> é calculada como o ponto médio entre <code>m_P</code> e o ponto de <code>m_points</code>.</p>
<p>O código comentado pode ser utilizado para imprimir no terminal as novas coordenadas de <code>m_P</code>.</p>
<p>Basicamente isso conclui a lógica do jogo do caos. Todo o resto do código será para desenhar <code>m_P</code> como um ponto na tela. No OpenGL anterior à versão 3.1, isso seria tão simples quanto acrescentar o seguinte código em <code>paintGL</code>:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="sierpinski.html#cb97-1" aria-hidden="true" tabindex="-1"></a>glBegin(GL_POINTS);</span>
<span id="cb97-2"><a href="sierpinski.html#cb97-2" aria-hidden="true" tabindex="-1"></a>  glVertex2f(<span class="va">m_P</span>.x, <span class="va">m_P</span>.y);</span>
<span id="cb97-3"><a href="sierpinski.html#cb97-3" aria-hidden="true" tabindex="-1"></a>glEnd();</span></code></pre></div>
<p>Entretanto, como vimos na seção <a href="vectorxraster.html#vectorxraster">3.1</a>, esse código é obsoleto e não é mais suportado em muitos drivers e plataformas. Para desenhar um simples ponto na tela, precisaremos seguir os seguintes passos:</p>
<ol style="list-style-type: decimal">
<li><strong>Criar um “buffer de vértices” como recurso do OpenGL.</strong> Esse recurso é chamado VBO (<em>Vertex Buffer Object</em>) e corresponde ao arranjo ordenado de vértices utilizado pelo pipeline de renderização para montar as primitivas que serão renderizadas. No nosso caso, o buffer de vértices só precisa ter um vértice, que é a coordenada do ponto que queremos desenhar. A variável <code>m_vboVertices</code> é um inteiro que identifica esse recurso.</li>
<li><strong>Programar o comportamento do pipeline de renderização.</strong> Isso é feito compilando e ligando um par de shaders que fica armazenado na GPU como um único “programa de shader,” identificado pela variável <code>m_program</code>. No OpenGL, os shaders são escritos na linguagem GLSL (OpenGL Shading Language), que é parecida com a linguagem C, mas possui novos tipos de dados e operações.</li>
<li><strong>Especificar como o buffer de vértices será lido pelo programa de shader.</strong> No nosso código, o estado dessa configuração é armazenado como um objeto do OpenGL chamado VAO (<em>Vertex Array Object</em>), identificado pela variável <code>m_vao</code>.</li>
</ol>
<p>Somente após alocar e ativar esses recursos é que podemos iniciar o pipeline de renderização, chamando uma função de desenho no <code>paintGL</code>. Não se preocupe se tudo isso está parecendo muito complexo nesse momento. Nos próximos capítulos revisitaremos cada etapa várias vezes até nos familiarizarmos com todo o processo. Por enquanto, utilizaremos o código já pronto.</p>
<p>Primeiro, defina o método <code>setupModel</code> como a seguir:</p>
<div class="sourceCode" id="cb98" startFrom="109"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 108;"><span id="cb98-109"><a href="sierpinski.html#cb98-109"></a><span class="dt">void</span> OpenGLWindow::setupModel() {</span>
<span id="cb98-110"><a href="sierpinski.html#cb98-110"></a>  <span class="co">// Release previous VBO and VAO</span></span>
<span id="cb98-111"><a href="sierpinski.html#cb98-111"></a>  abcg::glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboVertices</span>);</span>
<span id="cb98-112"><a href="sierpinski.html#cb98-112"></a>  abcg::glDeleteVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb98-113"><a href="sierpinski.html#cb98-113"></a></span>
<span id="cb98-114"><a href="sierpinski.html#cb98-114"></a>  <span class="co">// Generate a new VBO and get the associated ID</span></span>
<span id="cb98-115"><a href="sierpinski.html#cb98-115"></a>  abcg::glGenBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboVertices</span>);</span>
<span id="cb98-116"><a href="sierpinski.html#cb98-116"></a>  <span class="co">// Bind VBO in order to use it</span></span>
<span id="cb98-117"><a href="sierpinski.html#cb98-117"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboVertices</span>);</span>
<span id="cb98-118"><a href="sierpinski.html#cb98-118"></a>  <span class="co">// Upload data to VBO</span></span>
<span id="cb98-119"><a href="sierpinski.html#cb98-119"></a>  abcg::glBufferData(GL_ARRAY_BUFFER, <span class="kw">sizeof</span>(<span class="va">m_P</span>), &amp;<span class="va">m_P</span>, GL_STATIC_DRAW);</span>
<span id="cb98-120"><a href="sierpinski.html#cb98-120"></a>  <span class="co">// Unbinding the VBO is allowed (data can be released now)</span></span>
<span id="cb98-121"><a href="sierpinski.html#cb98-121"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb98-122"><a href="sierpinski.html#cb98-122"></a></span>
<span id="cb98-123"><a href="sierpinski.html#cb98-123"></a>  <span class="co">// Get location of attributes in the program</span></span>
<span id="cb98-124"><a href="sierpinski.html#cb98-124"></a>  GLint positionAttribute{abcg::glGetAttribLocation(<span class="va">m_program</span>, <span class="st">&quot;inPosition&quot;</span>)};</span>
<span id="cb98-125"><a href="sierpinski.html#cb98-125"></a></span>
<span id="cb98-126"><a href="sierpinski.html#cb98-126"></a>  <span class="co">// Create VAO</span></span>
<span id="cb98-127"><a href="sierpinski.html#cb98-127"></a>  abcg::glGenVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb98-128"><a href="sierpinski.html#cb98-128"></a></span>
<span id="cb98-129"><a href="sierpinski.html#cb98-129"></a>  <span class="co">// Bind vertex attributes to current VAO</span></span>
<span id="cb98-130"><a href="sierpinski.html#cb98-130"></a>  abcg::glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb98-131"><a href="sierpinski.html#cb98-131"></a></span>
<span id="cb98-132"><a href="sierpinski.html#cb98-132"></a>  abcg::glEnableVertexAttribArray(positionAttribute);</span>
<span id="cb98-133"><a href="sierpinski.html#cb98-133"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboVertices</span>);</span>
<span id="cb98-134"><a href="sierpinski.html#cb98-134"></a>  abcg::glVertexAttribPointer(positionAttribute, <span class="dv">2</span>, GL_FLOAT, GL_FALSE, <span class="dv">0</span>,</span>
<span id="cb98-135"><a href="sierpinski.html#cb98-135"></a>                              <span class="kw">nullptr</span>);</span>
<span id="cb98-136"><a href="sierpinski.html#cb98-136"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb98-137"><a href="sierpinski.html#cb98-137"></a></span>
<span id="cb98-138"><a href="sierpinski.html#cb98-138"></a>  <span class="co">// End of binding to current VAO</span></span>
<span id="cb98-139"><a href="sierpinski.html#cb98-139"></a>  abcg::glBindVertexArray(<span class="dv">0</span>);</span>
<span id="cb98-140"><a href="sierpinski.html#cb98-140"></a>}</span></code></pre></div>
<p>Esse código cria o VBO (<code>m_vboVertices</code>) e VAO (<code>m_VAO</code>) usando a posição atual de <code>m_P</code>.</p>
<p>Agora, modifique <code>initializeGL</code> para o seguinte código final:</p>
<div class="sourceCode" id="cb99" startFrom="8"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 7;"><span id="cb99-8"><a href="sierpinski.html#cb99-8"></a><span class="dt">void</span> OpenGLWindow::initializeGL() {</span>
<span id="cb99-9"><a href="sierpinski.html#cb99-9"></a>  <span class="at">const</span> <span class="kw">auto</span> *vertexShader{<span class="st">R&quot;gl(</span></span>
<span id="cb99-10"><a href="sierpinski.html#cb99-10"></a><span class="st">    #version 410</span></span>
<span id="cb99-11"><a href="sierpinski.html#cb99-11"></a><span class="st">    layout(location = 0) in vec2 inPosition;</span></span>
<span id="cb99-12"><a href="sierpinski.html#cb99-12"></a><span class="st">    void main() { </span></span>
<span id="cb99-13"><a href="sierpinski.html#cb99-13"></a><span class="st">      gl_PointSize = 2.0;</span></span>
<span id="cb99-14"><a href="sierpinski.html#cb99-14"></a><span class="st">      gl_Position = vec4(inPosition, 0, 1); </span></span>
<span id="cb99-15"><a href="sierpinski.html#cb99-15"></a><span class="st">    }</span></span>
<span id="cb99-16"><a href="sierpinski.html#cb99-16"></a><span class="st">  )gl&quot;</span>};</span>
<span id="cb99-17"><a href="sierpinski.html#cb99-17"></a></span>
<span id="cb99-18"><a href="sierpinski.html#cb99-18"></a>  <span class="at">const</span> <span class="kw">auto</span> *fragmentShader{<span class="st">R&quot;gl(</span></span>
<span id="cb99-19"><a href="sierpinski.html#cb99-19"></a><span class="st">    #version 410</span></span>
<span id="cb99-20"><a href="sierpinski.html#cb99-20"></a><span class="st">    out vec4 outColor;</span></span>
<span id="cb99-21"><a href="sierpinski.html#cb99-21"></a><span class="st">    void main() { outColor = vec4(1); }</span></span>
<span id="cb99-22"><a href="sierpinski.html#cb99-22"></a><span class="st">  )gl&quot;</span>};</span>
<span id="cb99-23"><a href="sierpinski.html#cb99-23"></a></span>
<span id="cb99-24"><a href="sierpinski.html#cb99-24"></a>  <span class="co">// Create shader program</span></span>
<span id="cb99-25"><a href="sierpinski.html#cb99-25"></a>  <span class="va">m_program</span> = createProgramFromString(vertexShader, fragmentShader);</span>
<span id="cb99-26"><a href="sierpinski.html#cb99-26"></a></span>
<span id="cb99-27"><a href="sierpinski.html#cb99-27"></a>  <span class="co">// Clear window</span></span>
<span id="cb99-28"><a href="sierpinski.html#cb99-28"></a>  abcg::glClearColor(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb99-29"><a href="sierpinski.html#cb99-29"></a>  abcg::glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb99-30"><a href="sierpinski.html#cb99-30"></a></span>
<span id="cb99-31"><a href="sierpinski.html#cb99-31"></a><span class="pp">#if !defined(__EMSCRIPTEN__)</span></span>
<span id="cb99-32"><a href="sierpinski.html#cb99-32"></a>  abcg::glEnable(GL_PROGRAM_POINT_SIZE);</span>
<span id="cb99-33"><a href="sierpinski.html#cb99-33"></a><span class="pp">#endif</span></span>
<span id="cb99-34"><a href="sierpinski.html#cb99-34"></a>  <span class="bu">std::</span>array&lt;GLfloat, <span class="dv">2</span>&gt; sizes{};</span>
<span id="cb99-35"><a href="sierpinski.html#cb99-35"></a>  abcg::glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, sizes.data());</span>
<span id="cb99-36"><a href="sierpinski.html#cb99-36"></a>  fmt::print(<span class="st">&quot;Point size: </span><span class="sc">{:.2f}</span><span class="st"> (min), </span><span class="sc">{:.2f}</span><span class="st"> (max)</span><span class="sc">\n</span><span class="st">&quot;</span>, sizes[<span class="dv">0</span>], sizes[<span class="dv">1</span>]);</span>
<span id="cb99-37"><a href="sierpinski.html#cb99-37"></a></span>
<span id="cb99-38"><a href="sierpinski.html#cb99-38"></a>  <span class="co">// Start pseudo-random number generator</span></span>
<span id="cb99-39"><a href="sierpinski.html#cb99-39"></a>  <span class="kw">auto</span> seed{<span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now().time_since_epoch().count()};</span>
<span id="cb99-40"><a href="sierpinski.html#cb99-40"></a>  <span class="va">m_randomEngine</span>.seed(seed);</span>
<span id="cb99-41"><a href="sierpinski.html#cb99-41"></a></span>
<span id="cb99-42"><a href="sierpinski.html#cb99-42"></a>  <span class="co">// Randomly choose a pair of coordinates in the interval [-1; 1]</span></span>
<span id="cb99-43"><a href="sierpinski.html#cb99-43"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; realDistribution(-<span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb99-44"><a href="sierpinski.html#cb99-44"></a>  <span class="va">m_P</span>.x = realDistribution(<span class="va">m_randomEngine</span>);</span>
<span id="cb99-45"><a href="sierpinski.html#cb99-45"></a>  <span class="va">m_P</span>.y = realDistribution(<span class="va">m_randomEngine</span>);</span>
<span id="cb99-46"><a href="sierpinski.html#cb99-46"></a>}</span></code></pre></div>
<p>Neste método, <code>vertexShader</code> e <code>fragmentShader</code> são strings que contêm o código-fonte dos shaders. <code>vertexShader</code> é o código do chamado <em>vertex shader</em>, que programa o processamento de vértices na GPU. <code>fragmentShader</code> é o código do <em>fragment shader</em> que programa o processamento de pixels na GPU (ou, mais precisamente, o processamento de fragmentos, que são conjuntos de atributos que representam uma amostra de geometria rasterizada).</p>
<p>A compilação e ligação dos shaders é feita pelo método <code>createProgramFromString</code> que faz parte da <code>abcg::OpenGLWindow</code>. Se acontecer algum erro de compilação, a mensagem de erro será exibida no console e uma exceção será lançada.</p>
<p>Note que limpamos o buffer de cor com a cor preta, usando <code>glClearColor</code> e <code>glClear</code> (linhas 28 e 29).</p>
<p>Observe o trecho de código entre as diretivas de pré-processamento:</p>
<div class="sourceCode" id="cb100" startFrom="31"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 30;"><span id="cb100-31"><a href="sierpinski.html#cb100-31"></a><span class="pp">#if !defined(__EMSCRIPTEN__)</span></span>
<span id="cb100-32"><a href="sierpinski.html#cb100-32"></a>  glEnable(GL_PROGRAM_POINT_SIZE);</span>
<span id="cb100-33"><a href="sierpinski.html#cb100-33"></a><span class="pp">#endif</span></span></code></pre></div>
<p>Esse código só é compilado quando não estamos usando o Emscripten, isto é, quando estamos compilando para o desktop. No OpenGL para desktop, o código é necessário para que o tamanho do ponto que será desenhado possa ser definido no vertex shader. Quando o código é compilado com o Emscripten, a definição do tamanho do ponto no vertex shader já é suportada por padrão, pois o OpenGL utilizado é o <a href="https://www.khronos.org/opengles/">OpenGL ES</a> (o WebGL usa um subconjunto de funções do OpenGL ES).</p>
<p>Observe, no código do vertex shader, que o tamanho do ponto é definido com <code>gl_PointSize = 2.0</code> (tamanho em pixels). Definimos o tamanho como dois, mas poderíamos ter escolhido outro valor. A faixa de tamanhos depende do que é suportado pelo hardware. Para imprimir no console o tamanho mínimo e máximo, usamos esse trecho de código:</p>
<div class="sourceCode" id="cb101" startFrom="34"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 33;"><span id="cb101-34"><a href="sierpinski.html#cb101-34"></a>  <span class="bu">std::</span>array&lt;GLfloat, <span class="dv">2</span>&gt; sizes{};</span>
<span id="cb101-35"><a href="sierpinski.html#cb101-35"></a>  abcg::glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, sizes.data());</span>
<span id="cb101-36"><a href="sierpinski.html#cb101-36"></a>  fmt::print(<span class="st">&quot;Point size: </span><span class="sc">{:.2f}</span><span class="st"> (min), </span><span class="sc">{:.2f}</span><span class="st"> (max)</span><span class="sc">\n</span><span class="st">&quot;</span>, sizes[<span class="dv">0</span>], sizes[<span class="dv">1</span>]);</span></code></pre></div>
<p>A função <code>glFloatv</code> com o identificador <code>GL_ALIASED_POINT_SIZE_RANGE</code> preenche o arranjo <code>sizes</code> com os tamanhos mínimo e máximo suportados. Em seguida, <code>fmt::print</code> mostra os valores no console.</p>
<p>O código final de <code>paintGL</code> fica assim:</p>
<div class="sourceCode" id="cb102" startFrom="48"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 47;"><span id="cb102-48"><a href="sierpinski.html#cb102-48"></a><span class="dt">void</span> OpenGLWindow::paintGL() {</span>
<span id="cb102-49"><a href="sierpinski.html#cb102-49"></a>  <span class="co">// Create OpenGL buffers for the single point at m_P</span></span>
<span id="cb102-50"><a href="sierpinski.html#cb102-50"></a>  setupModel();</span>
<span id="cb102-51"><a href="sierpinski.html#cb102-51"></a></span>
<span id="cb102-52"><a href="sierpinski.html#cb102-52"></a>  <span class="co">// Set the viewport</span></span>
<span id="cb102-53"><a href="sierpinski.html#cb102-53"></a>  abcg::glViewport(<span class="dv">0</span>, <span class="dv">0</span>, <span class="va">m_viewportWidth</span>, <span class="va">m_viewportHeight</span>);</span>
<span id="cb102-54"><a href="sierpinski.html#cb102-54"></a></span>
<span id="cb102-55"><a href="sierpinski.html#cb102-55"></a>  <span class="co">// Start using the shader program</span></span>
<span id="cb102-56"><a href="sierpinski.html#cb102-56"></a>  abcg::glUseProgram(<span class="va">m_program</span>);</span>
<span id="cb102-57"><a href="sierpinski.html#cb102-57"></a>  <span class="co">// Start using VAO</span></span>
<span id="cb102-58"><a href="sierpinski.html#cb102-58"></a>  abcg::glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb102-59"><a href="sierpinski.html#cb102-59"></a></span>
<span id="cb102-60"><a href="sierpinski.html#cb102-60"></a>  <span class="co">// Draw a single point</span></span>
<span id="cb102-61"><a href="sierpinski.html#cb102-61"></a>  abcg::glDrawArrays(GL_POINTS, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb102-62"><a href="sierpinski.html#cb102-62"></a></span>
<span id="cb102-63"><a href="sierpinski.html#cb102-63"></a>  <span class="co">// End using VAO</span></span>
<span id="cb102-64"><a href="sierpinski.html#cb102-64"></a>  abcg::glBindVertexArray(<span class="dv">0</span>);</span>
<span id="cb102-65"><a href="sierpinski.html#cb102-65"></a>  <span class="co">// End using the shader program</span></span>
<span id="cb102-66"><a href="sierpinski.html#cb102-66"></a>  abcg::glUseProgram(<span class="dv">0</span>);</span>
<span id="cb102-67"><a href="sierpinski.html#cb102-67"></a></span>
<span id="cb102-68"><a href="sierpinski.html#cb102-68"></a>  <span class="co">// Randomly choose a triangle vertex index</span></span>
<span id="cb102-69"><a href="sierpinski.html#cb102-69"></a>  <span class="bu">std::</span>uniform_int_distribution&lt;<span class="dt">int</span>&gt; intDistribution(<span class="dv">0</span>, <span class="va">m_points</span>.size() - <span class="dv">1</span>);</span>
<span id="cb102-70"><a href="sierpinski.html#cb102-70"></a>  <span class="dt">int</span> index{intDistribution(<span class="va">m_randomEngine</span>)};</span>
<span id="cb102-71"><a href="sierpinski.html#cb102-71"></a></span>
<span id="cb102-72"><a href="sierpinski.html#cb102-72"></a>  <span class="co">// The new position is the midpoint between the current position and the</span></span>
<span id="cb102-73"><a href="sierpinski.html#cb102-73"></a>  <span class="co">// chosen vertex</span></span>
<span id="cb102-74"><a href="sierpinski.html#cb102-74"></a>  <span class="va">m_P</span> = (<span class="va">m_P</span> + <span class="va">m_points</span>.at(index)) / <span class="fl">2.0</span><span class="bu">f</span>;</span>
<span id="cb102-75"><a href="sierpinski.html#cb102-75"></a></span>
<span id="cb102-76"><a href="sierpinski.html#cb102-76"></a>  <span class="co">// Print coordinates to the console</span></span>
<span id="cb102-77"><a href="sierpinski.html#cb102-77"></a>  <span class="co">// fmt::print(&quot;({:+.2f}, {:+.2f})\n&quot;, m_P.x, m_P.y);</span></span>
<span id="cb102-78"><a href="sierpinski.html#cb102-78"></a>}</span></code></pre></div>
<p>Na linha 50, <code>setupModel</code> cria os recursos do OpenGL necessários para desenhar um ponto na posição atual de <code>m_P</code>.</p>
<p>Na linha 53, <code>glViewport</code> configura o mapeamento entre o sistema de coordenadas no qual nossos pontos foram definidos (coordenadas normalizadas do dispositivo, ou NDC, de <em>normalized device coordinates</em>), e o sistema de coordenadas da janela (<em>window coordinates</em>), em pixels, com origem no canto inferior esquerdo da janela da aplicação.</p>
<p>A figura <a href="sierpinski.html#fig:sierpinski2">3.31</a> ilustra como fica configurado o mapeamento entre coordenadas em NDC para coordenadas da janela, supondo uma chamada a <code>glViewport(x, y, w, h)</code>, onde <code>x</code>, <code>y</code>, <code>w</code> e <code>h</code> são inteiros dados em pixels da tela. Na figura, o chamado <em>viewport</em> do OpenGL é a janela formada pelo retângulo entre os pontos <span class="math inline">\((x,y)\)</span> e <span class="math inline">\((x+w,y+h)\)</span>.</p>
<p>No nosso código com <code>glViewport(0, 0, m_viewportWidth, m_viewportHeight)</code>, o ponto <span class="math inline">\((-1,-1)\)</span> em NDC é mapeado para o pixel <span class="math inline">\((0, 0)\)</span> da janela (canto inferior esquerdo), e o ponto <span class="math inline">\((1,1)\)</span> em NDC é mapeado para o pixel <span class="math inline">\((0,0)\)</span> + (<code>m_viewportWidth</code>, <code>m_viewportHeight</code>). Isso faz com que o viewport ocupe toda a janela da aplicação.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:sierpinski2"></span>
<img src="images/03_sierpinski2.svg" alt="Mapeamento das coordenadas normalizadas no dispositivo (NDC) para coordenadas da janela usando `glViewport(x, y, w, h)`."  />
<p class="caption">
Figura 3.31: Mapeamento das coordenadas normalizadas no dispositivo (NDC) para coordenadas da janela usando <code>glViewport(x, y, w, h)</code>.
</p>
</div>
<p>Com o viewport devidamente configurado, iniciamos o pipeline de renderização neste trecho:</p>
<div class="sourceCode" id="cb103" startFrom="55"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 54;"><span id="cb103-55"><a href="sierpinski.html#cb103-55"></a>  <span class="co">// Start using the shader program</span></span>
<span id="cb103-56"><a href="sierpinski.html#cb103-56"></a>  abcg::glUseProgram(<span class="va">m_program</span>);</span>
<span id="cb103-57"><a href="sierpinski.html#cb103-57"></a>  <span class="co">// Start using VAO</span></span>
<span id="cb103-58"><a href="sierpinski.html#cb103-58"></a>  abcg::glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb103-59"><a href="sierpinski.html#cb103-59"></a></span>
<span id="cb103-60"><a href="sierpinski.html#cb103-60"></a>  <span class="co">// Draw a single point</span></span>
<span id="cb103-61"><a href="sierpinski.html#cb103-61"></a>  abcg::glDrawArrays(GL_POINTS, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb103-62"><a href="sierpinski.html#cb103-62"></a></span>
<span id="cb103-63"><a href="sierpinski.html#cb103-63"></a>  <span class="co">// End using VAO</span></span>
<span id="cb103-64"><a href="sierpinski.html#cb103-64"></a>  abcg::glBindVertexArray(<span class="dv">0</span>);</span>
<span id="cb103-65"><a href="sierpinski.html#cb103-65"></a>  <span class="co">// End using the shader program</span></span>
<span id="cb103-66"><a href="sierpinski.html#cb103-66"></a>  abcg::glUseProgram(<span class="dv">0</span>);</span></code></pre></div>
<p>Na linha 56, <code>glUseProgram</code> ativa os shaders compilados no programa <code>m_program</code>.</p>
<p>Na linha 58, <code>glBindVertexArray</code> ativa o VAO (<code>m_VAO</code>), que contém as especificações de como o arranjo de vértices (VBO) será lido no vertex shader atualmente ativo. Ao ativar o VAO, também é ativado automaticamente o VBO identificado por <code>m_VBO</code>.</p>
<p>Finalmente, na linha 61, <code>glDrawArrays</code> inicia o pipeline de renderização usando os shaders e o VBO ativo. O primeiro argumento (<code>GL_POINTS</code>) indica que os vértices do arranjo de vértices devem ser tratados como pontos. O segundo argumento (<code>0</code>) é o índice inicial dos vértices no VBO, e o terceiro argumento (<code>1</code>) informa quantos vértices devem ser processados.</p>
<p>O processamento no pipeline de renderização é realizado de forma paralela (assíncrona) com a CPU. Isto é, <code>glDrawArrays</code> retorna imediatamente, enquanto a GPU trabalha em paralelo renderizando a geometria no framebuffer<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>.</p>
<p>Após o comando de renderização, as linhas 64 e 66 desativam o VAO e os shaders. Essa desativação é opcional pois, de qualquer forma, o mesmo VAO e os mesmos shaders serão utilizados na próxima chamada de <code>paintGL</code>. Ainda assim, é uma boa prática de programação desativá-los logo após o uso.</p>
<p>Vamos agora definir o método <code>resizeGL</code>, assim:</p>
<div class="sourceCode" id="cb104" startFrom="95"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 94;"><span id="cb104-95"><a href="sierpinski.html#cb104-95"></a><span class="dt">void</span> OpenGLWindow::resizeGL(<span class="dt">int</span> width, <span class="dt">int</span> height) {</span>
<span id="cb104-96"><a href="sierpinski.html#cb104-96"></a>  <span class="va">m_viewportWidth</span> = width;</span>
<span id="cb104-97"><a href="sierpinski.html#cb104-97"></a>  <span class="va">m_viewportHeight</span> = height;</span>
<span id="cb104-98"><a href="sierpinski.html#cb104-98"></a></span>
<span id="cb104-99"><a href="sierpinski.html#cb104-99"></a>  abcg::glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb104-100"><a href="sierpinski.html#cb104-100"></a>}</span></code></pre></div>
<p>Como vimos, <code>resizeGL</code> é chamado sempre que a janela da aplicação muda de tamanho. Observe que simplesmente armazenamos o tamanho da janela em <code>m_viewportWidth</code> e <code>m_viewportHeight</code>. Como essas variáveis são usadas em <code>glViewport</code>, garantimos que o viewport sempre ocupará toda a janela da aplicação.</p>
<p>Observe que também chamamos <code>glClear</code> para apagar o buffer de cor. Dessa forma, o triângulo de Sierpinski no novo tamanho não é desenhado sobre o triângulo do tamanho anterior, o que estragaria o fractal.</p>
<p>O método <code>terminateGL</code> é definido da seguinte maneira:</p>
<div class="sourceCode" id="cb105" startFrom="102"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 101;"><span id="cb105-102"><a href="sierpinski.html#cb105-102"></a><span class="dt">void</span> OpenGLWindow::terminateGL() {</span>
<span id="cb105-103"><a href="sierpinski.html#cb105-103"></a>  <span class="co">// Release shader program, VBO and VAO</span></span>
<span id="cb105-104"><a href="sierpinski.html#cb105-104"></a>  abcg::glDeleteProgram(<span class="va">m_program</span>);</span>
<span id="cb105-105"><a href="sierpinski.html#cb105-105"></a>  abcg::glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboVertices</span>);</span>
<span id="cb105-106"><a href="sierpinski.html#cb105-106"></a>  abcg::glDeleteVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb105-107"><a href="sierpinski.html#cb105-107"></a>}</span></code></pre></div>
<p>Os comandos <code>glDelete*</code> liberam os recursos alocado em <code>setupModel</code>.</p>
<p>Para finalizar, vamos definir <code>paintUI</code> usando o seguinte código:</p>
<div class="sourceCode" id="cb106" startFrom="80"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 79;"><span id="cb106-80"><a href="sierpinski.html#cb106-80"></a><span class="dt">void</span> OpenGLWindow::paintUI() {</span>
<span id="cb106-81"><a href="sierpinski.html#cb106-81"></a>  abcg::OpenGLWindow::paintUI();</span>
<span id="cb106-82"><a href="sierpinski.html#cb106-82"></a></span>
<span id="cb106-83"><a href="sierpinski.html#cb106-83"></a>  {</span>
<span id="cb106-84"><a href="sierpinski.html#cb106-84"></a>    ImGui::SetNextWindowPos(ImVec2(<span class="dv">5</span>, <span class="dv">81</span>));</span>
<span id="cb106-85"><a href="sierpinski.html#cb106-85"></a>    ImGui::Begin(<span class="st">&quot; &quot;</span>, <span class="kw">nullptr</span>, ImGuiWindowFlags_NoDecoration);</span>
<span id="cb106-86"><a href="sierpinski.html#cb106-86"></a></span>
<span id="cb106-87"><a href="sierpinski.html#cb106-87"></a>    <span class="cf">if</span> (ImGui::Button(<span class="st">&quot;Clear window&quot;</span>, ImVec2(<span class="dv">150</span>, <span class="dv">30</span>))) {</span>
<span id="cb106-88"><a href="sierpinski.html#cb106-88"></a>      abcg::glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb106-89"><a href="sierpinski.html#cb106-89"></a>    }</span>
<span id="cb106-90"><a href="sierpinski.html#cb106-90"></a></span>
<span id="cb106-91"><a href="sierpinski.html#cb106-91"></a>    ImGui::End();</span>
<span id="cb106-92"><a href="sierpinski.html#cb106-92"></a>  }</span>
<span id="cb106-93"><a href="sierpinski.html#cb106-93"></a>}</span></code></pre></div>
<p>Na linha 81 chamamos o <code>paintUI</code> da classe base, que é responsável por mostrar o contador de FPS (lembre-se que desabilitamos a exibição do botão de tela cheia).</p>
<p>O código nas linhas 83 a 92 cria um botão “Clear window” que chama <code>glClear</code> sempre que pressionado.</p>
<p>Isso é tudo! O código completo de <code>openglwindow.cpp</code> é mostrado a seguir:</p>
<div class="sourceCode" id="cb107" startFrom="1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb107-1"><a href="sierpinski.html#cb107-1"></a><span class="pp">#include </span><span class="im">&quot;openglwindow.hpp&quot;</span></span>
<span id="cb107-2"><a href="sierpinski.html#cb107-2"></a></span>
<span id="cb107-3"><a href="sierpinski.html#cb107-3"></a><span class="pp">#include </span><span class="im">&lt;fmt/core.h&gt;</span></span>
<span id="cb107-4"><a href="sierpinski.html#cb107-4"></a><span class="pp">#include </span><span class="im">&lt;imgui.h&gt;</span></span>
<span id="cb107-5"><a href="sierpinski.html#cb107-5"></a></span>
<span id="cb107-6"><a href="sierpinski.html#cb107-6"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb107-7"><a href="sierpinski.html#cb107-7"></a></span>
<span id="cb107-8"><a href="sierpinski.html#cb107-8"></a><span class="dt">void</span> OpenGLWindow::initializeGL() {</span>
<span id="cb107-9"><a href="sierpinski.html#cb107-9"></a>  <span class="at">const</span> <span class="kw">auto</span> *vertexShader{<span class="st">R&quot;gl(</span></span>
<span id="cb107-10"><a href="sierpinski.html#cb107-10"></a><span class="st">    #version 410</span></span>
<span id="cb107-11"><a href="sierpinski.html#cb107-11"></a><span class="st">    layout(location = 0) in vec2 inPosition;</span></span>
<span id="cb107-12"><a href="sierpinski.html#cb107-12"></a><span class="st">    void main() { </span></span>
<span id="cb107-13"><a href="sierpinski.html#cb107-13"></a><span class="st">      gl_PointSize = 2.0;</span></span>
<span id="cb107-14"><a href="sierpinski.html#cb107-14"></a><span class="st">      gl_Position = vec4(inPosition, 0, 1); </span></span>
<span id="cb107-15"><a href="sierpinski.html#cb107-15"></a><span class="st">    }</span></span>
<span id="cb107-16"><a href="sierpinski.html#cb107-16"></a><span class="st">  )gl&quot;</span>};</span>
<span id="cb107-17"><a href="sierpinski.html#cb107-17"></a></span>
<span id="cb107-18"><a href="sierpinski.html#cb107-18"></a>  <span class="at">const</span> <span class="kw">auto</span> *fragmentShader{<span class="st">R&quot;gl(</span></span>
<span id="cb107-19"><a href="sierpinski.html#cb107-19"></a><span class="st">    #version 410</span></span>
<span id="cb107-20"><a href="sierpinski.html#cb107-20"></a><span class="st">    out vec4 outColor;</span></span>
<span id="cb107-21"><a href="sierpinski.html#cb107-21"></a><span class="st">    void main() { outColor = vec4(1); }</span></span>
<span id="cb107-22"><a href="sierpinski.html#cb107-22"></a><span class="st">  )gl&quot;</span>};</span>
<span id="cb107-23"><a href="sierpinski.html#cb107-23"></a></span>
<span id="cb107-24"><a href="sierpinski.html#cb107-24"></a>  <span class="co">// Create shader program</span></span>
<span id="cb107-25"><a href="sierpinski.html#cb107-25"></a>  <span class="va">m_program</span> = createProgramFromString(vertexShader, fragmentShader);</span>
<span id="cb107-26"><a href="sierpinski.html#cb107-26"></a></span>
<span id="cb107-27"><a href="sierpinski.html#cb107-27"></a>  <span class="co">// Clear window</span></span>
<span id="cb107-28"><a href="sierpinski.html#cb107-28"></a>  abcg::glClearColor(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb107-29"><a href="sierpinski.html#cb107-29"></a>  abcg::glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb107-30"><a href="sierpinski.html#cb107-30"></a></span>
<span id="cb107-31"><a href="sierpinski.html#cb107-31"></a><span class="pp">#if !defined(__EMSCRIPTEN__)</span></span>
<span id="cb107-32"><a href="sierpinski.html#cb107-32"></a>  abcg::glEnable(GL_PROGRAM_POINT_SIZE);</span>
<span id="cb107-33"><a href="sierpinski.html#cb107-33"></a><span class="pp">#endif</span></span>
<span id="cb107-34"><a href="sierpinski.html#cb107-34"></a>  <span class="bu">std::</span>array&lt;GLfloat, <span class="dv">2</span>&gt; sizes{};</span>
<span id="cb107-35"><a href="sierpinski.html#cb107-35"></a>  abcg::glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, sizes.data());</span>
<span id="cb107-36"><a href="sierpinski.html#cb107-36"></a>  fmt::print(<span class="st">&quot;Point size: </span><span class="sc">{:.2f}</span><span class="st"> (min), </span><span class="sc">{:.2f}</span><span class="st"> (max)</span><span class="sc">\n</span><span class="st">&quot;</span>, sizes[<span class="dv">0</span>], sizes[<span class="dv">1</span>]);</span>
<span id="cb107-37"><a href="sierpinski.html#cb107-37"></a></span>
<span id="cb107-38"><a href="sierpinski.html#cb107-38"></a>  <span class="co">// Start pseudo-random number generator</span></span>
<span id="cb107-39"><a href="sierpinski.html#cb107-39"></a>  <span class="kw">auto</span> seed{<span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now().time_since_epoch().count()};</span>
<span id="cb107-40"><a href="sierpinski.html#cb107-40"></a>  <span class="va">m_randomEngine</span>.seed(seed);</span>
<span id="cb107-41"><a href="sierpinski.html#cb107-41"></a></span>
<span id="cb107-42"><a href="sierpinski.html#cb107-42"></a>  <span class="co">// Randomly choose a pair of coordinates in the interval [-1; 1]</span></span>
<span id="cb107-43"><a href="sierpinski.html#cb107-43"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">float</span>&gt; realDistribution(-<span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb107-44"><a href="sierpinski.html#cb107-44"></a>  <span class="va">m_P</span>.x = realDistribution(<span class="va">m_randomEngine</span>);</span>
<span id="cb107-45"><a href="sierpinski.html#cb107-45"></a>  <span class="va">m_P</span>.y = realDistribution(<span class="va">m_randomEngine</span>);</span>
<span id="cb107-46"><a href="sierpinski.html#cb107-46"></a>}</span>
<span id="cb107-47"><a href="sierpinski.html#cb107-47"></a></span>
<span id="cb107-48"><a href="sierpinski.html#cb107-48"></a><span class="dt">void</span> OpenGLWindow::paintGL() {</span>
<span id="cb107-49"><a href="sierpinski.html#cb107-49"></a>  <span class="co">// Create OpenGL buffers for the single point at m_P</span></span>
<span id="cb107-50"><a href="sierpinski.html#cb107-50"></a>  setupModel();</span>
<span id="cb107-51"><a href="sierpinski.html#cb107-51"></a></span>
<span id="cb107-52"><a href="sierpinski.html#cb107-52"></a>  <span class="co">// Set the viewport</span></span>
<span id="cb107-53"><a href="sierpinski.html#cb107-53"></a>  abcg::glViewport(<span class="dv">0</span>, <span class="dv">0</span>, <span class="va">m_viewportWidth</span>, <span class="va">m_viewportHeight</span>);</span>
<span id="cb107-54"><a href="sierpinski.html#cb107-54"></a></span>
<span id="cb107-55"><a href="sierpinski.html#cb107-55"></a>  <span class="co">// Start using the shader program</span></span>
<span id="cb107-56"><a href="sierpinski.html#cb107-56"></a>  abcg::glUseProgram(<span class="va">m_program</span>);</span>
<span id="cb107-57"><a href="sierpinski.html#cb107-57"></a>  <span class="co">// Start using VAO</span></span>
<span id="cb107-58"><a href="sierpinski.html#cb107-58"></a>  abcg::glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb107-59"><a href="sierpinski.html#cb107-59"></a></span>
<span id="cb107-60"><a href="sierpinski.html#cb107-60"></a>  <span class="co">// Draw a single point</span></span>
<span id="cb107-61"><a href="sierpinski.html#cb107-61"></a>  abcg::glDrawArrays(GL_POINTS, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb107-62"><a href="sierpinski.html#cb107-62"></a></span>
<span id="cb107-63"><a href="sierpinski.html#cb107-63"></a>  <span class="co">// End using VAO</span></span>
<span id="cb107-64"><a href="sierpinski.html#cb107-64"></a>  abcg::glBindVertexArray(<span class="dv">0</span>);</span>
<span id="cb107-65"><a href="sierpinski.html#cb107-65"></a>  <span class="co">// End using the shader program</span></span>
<span id="cb107-66"><a href="sierpinski.html#cb107-66"></a>  abcg::glUseProgram(<span class="dv">0</span>);</span>
<span id="cb107-67"><a href="sierpinski.html#cb107-67"></a></span>
<span id="cb107-68"><a href="sierpinski.html#cb107-68"></a>  <span class="co">// Randomly choose a triangle vertex index</span></span>
<span id="cb107-69"><a href="sierpinski.html#cb107-69"></a>  <span class="bu">std::</span>uniform_int_distribution&lt;<span class="dt">int</span>&gt; intDistribution(<span class="dv">0</span>, <span class="va">m_points</span>.size() - <span class="dv">1</span>);</span>
<span id="cb107-70"><a href="sierpinski.html#cb107-70"></a>  <span class="dt">int</span> index{intDistribution(<span class="va">m_randomEngine</span>)};</span>
<span id="cb107-71"><a href="sierpinski.html#cb107-71"></a></span>
<span id="cb107-72"><a href="sierpinski.html#cb107-72"></a>  <span class="co">// The new position is the midpoint between the current position and the</span></span>
<span id="cb107-73"><a href="sierpinski.html#cb107-73"></a>  <span class="co">// chosen vertex</span></span>
<span id="cb107-74"><a href="sierpinski.html#cb107-74"></a>  <span class="va">m_P</span> = (<span class="va">m_P</span> + <span class="va">m_points</span>.at(index)) / <span class="fl">2.0</span><span class="bu">f</span>;</span>
<span id="cb107-75"><a href="sierpinski.html#cb107-75"></a></span>
<span id="cb107-76"><a href="sierpinski.html#cb107-76"></a>  <span class="co">// Print coordinates to the console</span></span>
<span id="cb107-77"><a href="sierpinski.html#cb107-77"></a>  <span class="co">// fmt::print(&quot;({:+.2f}, {:+.2f})\n&quot;, m_P.x, m_P.y);</span></span>
<span id="cb107-78"><a href="sierpinski.html#cb107-78"></a>}</span>
<span id="cb107-79"><a href="sierpinski.html#cb107-79"></a></span>
<span id="cb107-80"><a href="sierpinski.html#cb107-80"></a><span class="dt">void</span> OpenGLWindow::paintUI() {</span>
<span id="cb107-81"><a href="sierpinski.html#cb107-81"></a>  abcg::OpenGLWindow::paintUI();</span>
<span id="cb107-82"><a href="sierpinski.html#cb107-82"></a></span>
<span id="cb107-83"><a href="sierpinski.html#cb107-83"></a>  {</span>
<span id="cb107-84"><a href="sierpinski.html#cb107-84"></a>    ImGui::SetNextWindowPos(ImVec2(<span class="dv">5</span>, <span class="dv">5</span> + <span class="dv">50</span> + <span class="dv">16</span> + <span class="dv">5</span>));</span>
<span id="cb107-85"><a href="sierpinski.html#cb107-85"></a>    ImGui::Begin(<span class="st">&quot; &quot;</span>, <span class="kw">nullptr</span>, ImGuiWindowFlags_NoDecoration);</span>
<span id="cb107-86"><a href="sierpinski.html#cb107-86"></a></span>
<span id="cb107-87"><a href="sierpinski.html#cb107-87"></a>    <span class="cf">if</span> (ImGui::Button(<span class="st">&quot;Clear window&quot;</span>, ImVec2(<span class="dv">150</span>, <span class="dv">30</span>))) {</span>
<span id="cb107-88"><a href="sierpinski.html#cb107-88"></a>      abcg::glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb107-89"><a href="sierpinski.html#cb107-89"></a>    }</span>
<span id="cb107-90"><a href="sierpinski.html#cb107-90"></a></span>
<span id="cb107-91"><a href="sierpinski.html#cb107-91"></a>    ImGui::End();</span>
<span id="cb107-92"><a href="sierpinski.html#cb107-92"></a>  }</span>
<span id="cb107-93"><a href="sierpinski.html#cb107-93"></a>}</span>
<span id="cb107-94"><a href="sierpinski.html#cb107-94"></a></span>
<span id="cb107-95"><a href="sierpinski.html#cb107-95"></a><span class="dt">void</span> OpenGLWindow::resizeGL(<span class="dt">int</span> width, <span class="dt">int</span> height) {</span>
<span id="cb107-96"><a href="sierpinski.html#cb107-96"></a>  <span class="va">m_viewportWidth</span> = width;</span>
<span id="cb107-97"><a href="sierpinski.html#cb107-97"></a>  <span class="va">m_viewportHeight</span> = height;</span>
<span id="cb107-98"><a href="sierpinski.html#cb107-98"></a></span>
<span id="cb107-99"><a href="sierpinski.html#cb107-99"></a>  abcg::glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb107-100"><a href="sierpinski.html#cb107-100"></a>}</span>
<span id="cb107-101"><a href="sierpinski.html#cb107-101"></a></span>
<span id="cb107-102"><a href="sierpinski.html#cb107-102"></a><span class="dt">void</span> OpenGLWindow::terminateGL() {</span>
<span id="cb107-103"><a href="sierpinski.html#cb107-103"></a>  <span class="co">// Release shader program, VBO and VAO</span></span>
<span id="cb107-104"><a href="sierpinski.html#cb107-104"></a>  abcg::glDeleteProgram(<span class="va">m_program</span>);</span>
<span id="cb107-105"><a href="sierpinski.html#cb107-105"></a>  abcg::glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboVertices</span>);</span>
<span id="cb107-106"><a href="sierpinski.html#cb107-106"></a>  abcg::glDeleteVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb107-107"><a href="sierpinski.html#cb107-107"></a>}</span>
<span id="cb107-108"><a href="sierpinski.html#cb107-108"></a></span>
<span id="cb107-109"><a href="sierpinski.html#cb107-109"></a><span class="dt">void</span> OpenGLWindow::setupModel() {</span>
<span id="cb107-110"><a href="sierpinski.html#cb107-110"></a>  <span class="co">// Release previous VBO and VAO</span></span>
<span id="cb107-111"><a href="sierpinski.html#cb107-111"></a>  abcg::glDeleteBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboVertices</span>);</span>
<span id="cb107-112"><a href="sierpinski.html#cb107-112"></a>  abcg::glDeleteVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb107-113"><a href="sierpinski.html#cb107-113"></a></span>
<span id="cb107-114"><a href="sierpinski.html#cb107-114"></a>  <span class="co">// Generate a new VBO and get the associated ID</span></span>
<span id="cb107-115"><a href="sierpinski.html#cb107-115"></a>  abcg::glGenBuffers(<span class="dv">1</span>, &amp;<span class="va">m_vboVertices</span>);</span>
<span id="cb107-116"><a href="sierpinski.html#cb107-116"></a>  <span class="co">// Bind VBO in order to use it</span></span>
<span id="cb107-117"><a href="sierpinski.html#cb107-117"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboVertices</span>);</span>
<span id="cb107-118"><a href="sierpinski.html#cb107-118"></a>  <span class="co">// Upload data to VBO</span></span>
<span id="cb107-119"><a href="sierpinski.html#cb107-119"></a>  abcg::glBufferData(GL_ARRAY_BUFFER, <span class="kw">sizeof</span>(<span class="va">m_P</span>), &amp;<span class="va">m_P</span>, GL_STATIC_DRAW);</span>
<span id="cb107-120"><a href="sierpinski.html#cb107-120"></a>  <span class="co">// Unbinding the VBO is allowed (data can be released now)</span></span>
<span id="cb107-121"><a href="sierpinski.html#cb107-121"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb107-122"><a href="sierpinski.html#cb107-122"></a></span>
<span id="cb107-123"><a href="sierpinski.html#cb107-123"></a>  <span class="co">// Get location of attributes in the program</span></span>
<span id="cb107-124"><a href="sierpinski.html#cb107-124"></a>  GLint positionAttribute{abcg::glGetAttribLocation(<span class="va">m_program</span>, <span class="st">&quot;inPosition&quot;</span>)};</span>
<span id="cb107-125"><a href="sierpinski.html#cb107-125"></a></span>
<span id="cb107-126"><a href="sierpinski.html#cb107-126"></a>  <span class="co">// Create VAO</span></span>
<span id="cb107-127"><a href="sierpinski.html#cb107-127"></a>  abcg::glGenVertexArrays(<span class="dv">1</span>, &amp;<span class="va">m_vao</span>);</span>
<span id="cb107-128"><a href="sierpinski.html#cb107-128"></a></span>
<span id="cb107-129"><a href="sierpinski.html#cb107-129"></a>  <span class="co">// Bind vertex attributes to current VAO</span></span>
<span id="cb107-130"><a href="sierpinski.html#cb107-130"></a>  abcg::glBindVertexArray(<span class="va">m_vao</span>);</span>
<span id="cb107-131"><a href="sierpinski.html#cb107-131"></a></span>
<span id="cb107-132"><a href="sierpinski.html#cb107-132"></a>  abcg::glEnableVertexAttribArray(positionAttribute);</span>
<span id="cb107-133"><a href="sierpinski.html#cb107-133"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="va">m_vboVertices</span>);</span>
<span id="cb107-134"><a href="sierpinski.html#cb107-134"></a>  abcg::glVertexAttribPointer(positionAttribute, <span class="dv">2</span>, GL_FLOAT, GL_FALSE, <span class="dv">0</span>,</span>
<span id="cb107-135"><a href="sierpinski.html#cb107-135"></a>                              <span class="kw">nullptr</span>);</span>
<span id="cb107-136"><a href="sierpinski.html#cb107-136"></a>  abcg::glBindBuffer(GL_ARRAY_BUFFER, <span class="dv">0</span>);</span>
<span id="cb107-137"><a href="sierpinski.html#cb107-137"></a></span>
<span id="cb107-138"><a href="sierpinski.html#cb107-138"></a>  <span class="co">// End of binding to current VAO</span></span>
<span id="cb107-139"><a href="sierpinski.html#cb107-139"></a>  abcg::glBindVertexArray(<span class="dv">0</span>);</span>
<span id="cb107-140"><a href="sierpinski.html#cb107-140"></a>}</span></code></pre></div>
<p>Construa a aplicação para ver o resultado:</p>
<iframe
  src="https://hbatagelo.github.io/abcgapps/sierpinski/index.html"
  allow="gamepad" frameborder="0" allowfullscreen="true" allowtransparency="true" emscriptenheight="740"
  ></iframe>

</div>
</div>
<!-- </div> -->
<div class="footnotes">
<hr />
<ol start="12">
<li id="fn12"><p>No nosso caso o arranjo de vértices contém apenas um vértice e equivale ao ponto <span class="math inline">\(P\)</span> que queremos desenhar.<a href="sierpinski.html#fnref12" class="footnote-back">↩︎</a></p></li>
<li id="fn13"><p>A numeração das linhas é a mesma do código completo de <code>openglwindow.cpp</code> mostrado no final do capítulo.<a href="sierpinski.html#fnref13" class="footnote-back">↩︎</a></p></li>
<li id="fn14"><p>Experimente outras distribuições e observe a mudança no comportamento do fractal.<a href="sierpinski.html#fnref14" class="footnote-back">↩︎</a></p></li>
<li id="fn15"><p>A ABCg habilita a técnica de backbuffering vista na seção <a href="framebuffer.html#framebuffer">3.3</a>. Desse modo, a GPU renderiza primeiro a geometria no backbuffer. Quando a renderização é concluída, o conteúdo é enviado automaticamente para o frontbuffer, que atualiza o dispositivo de exibição.<a href="sierpinski.html#fnref15" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="framebuffer.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="referências.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": {}
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": null,
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection",
"scroll_highlight": true
},
"toc_float": true,
"toolbar": {
"position": "fixed"
},
"info": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
