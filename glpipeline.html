<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>4.3 Pipeline do OpenGL | MCTA008-17 Computação Gráfica</title>
  <meta name="description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  <meta name="generator" content="bookdown 0.24 and GitBook 2.6.7" />

  <meta property="og:title" content="4.3 Pipeline do OpenGL | MCTA008-17 Computação Gráfica" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  <meta name="github-repo" content="hbatagelo/cgbook" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4.3 Pipeline do OpenGL | MCTA008-17 Computação Gráfica" />
  
  <meta name="twitter:description" content="Notas de aula de MCTA008-17 Computação Gráfica da Universidade Federal do ABC" />
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="ray-casting-x-rasterização.html"/>
<link rel="next" href="coloredtriangles.html"/>
<script src="libs/header-attrs-2.10/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { font-weight: bold; } /* Alert */
code span.an { font-style: italic; } /* Annotation */
code span.cf { font-weight: bold; } /* ControlFlow */
code span.co { font-style: italic; } /* Comment */
code span.cv { font-style: italic; } /* CommentVar */
code span.do { font-style: italic; } /* Documentation */
code span.dt { text-decoration: underline; } /* DataType */
code span.er { font-weight: bold; } /* Error */
code span.in { font-style: italic; } /* Information */
code span.kw { font-weight: bold; } /* Keyword */
code span.pp { font-weight: bold; } /* Preprocessor */
code span.wa { font-style: italic; } /* Warning */
</style>

<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Computação Gráfica</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Apresentação</a>
<ul>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html"><i class="fa fa-check"></i>Pré-requisitos</a>
<ul>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html#atividades-práticas"><i class="fa fa-check"></i>Atividades práticas</a></li>
<li class="chapter" data-level="" data-path="pré-requisitos.html"><a href="pré-requisitos.html#visualizando-este-site"><i class="fa fa-check"></i>Visualizando este site</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="1" data-path="config.html"><a href="config.html"><i class="fa fa-check"></i><b>1</b> Configuração do ambiente</a>
<ul>
<li class="chapter" data-level="1.1" data-path="linux.html"><a href="linux.html"><i class="fa fa-check"></i><b>1.1</b> Linux</a>
<ul>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#habilitando-o-opengl"><i class="fa fa-check"></i>Habilitando o OpenGL</a></li>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#atualizando-o-gcc"><i class="fa fa-check"></i>Atualizando o GCC</a></li>
<li class="chapter" data-level="" data-path="linux.html"><a href="linux.html#instalando-o-emscripten"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="macos.html"><a href="macos.html"><i class="fa fa-check"></i><b>1.2</b> macOS</a>
<ul>
<li class="chapter" data-level="" data-path="macos.html"><a href="macos.html#instalando-o-emscripten-1"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="windows.html"><a href="windows.html"><i class="fa fa-check"></i><b>1.3</b> Windows</a>
<ul>
<li class="chapter" data-level="" data-path="windows.html"><a href="windows.html#habilitando-o-opengl-1"><i class="fa fa-check"></i>Habilitando o OpenGL</a></li>
<li class="chapter" data-level="" data-path="windows.html"><a href="windows.html#instalando-o-emscripten-2"><i class="fa fa-check"></i>Instalando o Emscripten</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="vscode.html"><a href="vscode.html"><i class="fa fa-check"></i><b>1.4</b> Visual Studio Code</a></li>
<li class="chapter" data-level="1.5" data-path="abcg.html"><a href="abcg.html"><i class="fa fa-check"></i><b>1.5</b> ABCg</a>
<ul>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#instalação"><i class="fa fa-check"></i>Instalação</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-em-linha-de-comando"><i class="fa fa-check"></i>Compilando em linha de comando</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-no-visual-studio-code"><i class="fa fa-check"></i>Compilando no Visual Studio Code</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#depurando-no-visual-studio-code"><i class="fa fa-check"></i>Depurando no Visual Studio Code</a></li>
<li class="chapter" data-level="" data-path="abcg.html"><a href="abcg.html#compilando-para-webassembly"><i class="fa fa-check"></i>Compilando para WebAssembly</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> Introdução</a>
<ul>
<li class="chapter" data-level="2.1" data-path="áreas-correlatas.html"><a href="áreas-correlatas.html"><i class="fa fa-check"></i><b>2.1</b> Áreas correlatas</a></li>
<li class="chapter" data-level="2.2" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html"><i class="fa fa-check"></i><b>2.2</b> Linha do tempo</a>
<ul>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section"><i class="fa fa-check"></i>1950</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-1"><i class="fa fa-check"></i>1960</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-2"><i class="fa fa-check"></i>1970</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-3"><i class="fa fa-check"></i>1980</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-4"><i class="fa fa-check"></i>1990</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-5"><i class="fa fa-check"></i>2000</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-6"><i class="fa fa-check"></i>2010</a></li>
<li class="chapter" data-level="" data-path="linha-do-tempo.html"><a href="linha-do-tempo.html#section-7"><i class="fa fa-check"></i>2020</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="firstapp.html"><a href="firstapp.html"><i class="fa fa-check"></i><b>2.3</b> Primeiro programa</a>
<ul>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#configuração-inicial"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#main.cpp"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#openglwindow.hpp"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#openglwindow.cpp"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
<li class="chapter" data-level="" data-path="firstapp.html"><a href="firstapp.html#compilando-para-webassembly-1"><i class="fa fa-check"></i>Compilando para WebAssembly</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="graphicssystem.html"><a href="graphicssystem.html"><i class="fa fa-check"></i><b>3</b> Sistemas gráficos</a>
<ul>
<li class="chapter" data-level="3.1" data-path="vectorxraster.html"><a href="vectorxraster.html"><i class="fa fa-check"></i><b>3.1</b> Vetorial <em>x</em> matricial</a>
<ul>
<li class="chapter" data-level="" data-path="vectorxraster.html"><a href="vectorxraster.html#representação-vetorial"><i class="fa fa-check"></i>Representação vetorial</a></li>
<li class="chapter" data-level="" data-path="vectorxraster.html"><a href="vectorxraster.html#representação-matricial"><i class="fa fa-check"></i>Representação matricial</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="es.html"><a href="es.html"><i class="fa fa-check"></i><b>3.2</b> Dispositivos de E/S</a>
<ul>
<li class="chapter" data-level="" data-path="es.html"><a href="es.html#dispositivos-de-entrada"><i class="fa fa-check"></i>Dispositivos de entrada</a></li>
<li class="chapter" data-level="" data-path="es.html"><a href="es.html#dispositivos-de-saída"><i class="fa fa-check"></i>Dispositivos de saída</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="framebuffer.html"><a href="framebuffer.html"><i class="fa fa-check"></i><b>3.3</b> Framebuffer</a>
<ul>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#screen-tearing"><i class="fa fa-check"></i>Screen tearing</a></li>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#vsync"><i class="fa fa-check"></i>Vsync</a></li>
<li class="chapter" data-level="" data-path="framebuffer.html"><a href="framebuffer.html#backbuffering"><i class="fa fa-check"></i>Backbuffering</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="sierpinski.html"><a href="sierpinski.html"><i class="fa fa-check"></i><b>3.4</b> Triângulo de Sierpinski</a>
<ul>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#configuração-inicial-1"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#main.cpp-1"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#openglwindow.hpp-1"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="sierpinski.html"><a href="sierpinski.html#openglwindow.cpp-1"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="pipeline.html"><a href="pipeline.html"><i class="fa fa-check"></i><b>4</b> Pipeline gráfico</a>
<ul>
<li class="chapter" data-level="4.1" data-path="dados-gráficos.html"><a href="dados-gráficos.html"><i class="fa fa-check"></i><b>4.1</b> Dados gráficos</a></li>
<li class="chapter" data-level="4.2" data-path="ray-casting-x-rasterização.html"><a href="ray-casting-x-rasterização.html"><i class="fa fa-check"></i><b>4.2</b> Ray casting <em>x</em> rasterização</a>
<ul>
<li class="chapter" data-level="" data-path="ray-casting-x-rasterização.html"><a href="ray-casting-x-rasterização.html#ray-casting"><i class="fa fa-check"></i>Ray casting</a></li>
<li class="chapter" data-level="" data-path="ray-casting-x-rasterização.html"><a href="ray-casting-x-rasterização.html#rasterização"><i class="fa fa-check"></i>Rasterização</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="glpipeline.html"><a href="glpipeline.html"><i class="fa fa-check"></i><b>4.3</b> Pipeline do OpenGL</a>
<ul>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#aplicação"><i class="fa fa-check"></i>Aplicação</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#vertex-shader"><i class="fa fa-check"></i>Vertex shader</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#montagem-de-primitivas"><i class="fa fa-check"></i>Montagem de primitivas</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#recorte"><i class="fa fa-check"></i>Recorte</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#rasterização-1"><i class="fa fa-check"></i>Rasterização</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#fragment-shader"><i class="fa fa-check"></i>Fragment shader</a></li>
<li class="chapter" data-level="" data-path="glpipeline.html"><a href="glpipeline.html#operações-de-fragmentos"><i class="fa fa-check"></i>Operações de fragmentos</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="coloredtriangles.html"><a href="coloredtriangles.html"><i class="fa fa-check"></i><b>4.4</b> Triângulos coloridos</a>
<ul>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#configuração-inicial-2"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#main.cpp-2"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#openglwindow.hpp-2"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="coloredtriangles.html"><a href="coloredtriangles.html#openglwindow.cpp-2"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="game.html"><a href="game.html"><i class="fa fa-check"></i><b>5</b> Desenvolvendo um jogo 2D</a>
<ul>
<li class="chapter" data-level="5.1" data-path="regularpolygons.html"><a href="regularpolygons.html"><i class="fa fa-check"></i><b>5.1</b> Polígonos regulares</a>
<ul>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#configuração-inicial-3"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#main.cpp-3"><i class="fa fa-check"></i>main.cpp</a></li>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#openglwindow.hpp-3"><i class="fa fa-check"></i>openglwindow.hpp</a></li>
<li class="chapter" data-level="" data-path="regularpolygons.html"><a href="regularpolygons.html#openglwindow.cpp-3"><i class="fa fa-check"></i>openglwindow.cpp</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="asteroids.html"><a href="asteroids.html"><i class="fa fa-check"></i><b>5.2</b> Asteroids</a>
<ul>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#organização-do-projeto"><i class="fa fa-check"></i>Organização do projeto</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#configuração-inicial-4"><i class="fa fa-check"></i>Configuração inicial</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#nave"><i class="fa fa-check"></i>Nave</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#estrelas"><i class="fa fa-check"></i>Estrelas</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#asteroides"><i class="fa fa-check"></i>Asteroides</a></li>
<li class="chapter" data-level="" data-path="asteroids.html"><a href="asteroids.html#tiros-e-colisões"><i class="fa fa-check"></i>Tiros e colisões</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="referências.html"><a href="referências.html"><i class="fa fa-check"></i>Referências</a></li>
<li class="divider"></li>
<li>
<a href="mailto:harlen.batagelo@ufabc.edu.br" target="blank">Harlen Batagelo</a>
<a href="mailto:bruno.marques@ufabc.edu.br" target="blank">Bruno Marques</a>
<br>
</li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">MCTA008-17 Computação Gráfica</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="glpipeline" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Pipeline do OpenGL</h2>
<p>A figura <a href="glpipeline.html#fig:glpipeline">4.7</a> mostra um diagrama dos estágios de processamento do pipeline gráfico do OpenGL (fundo amarelo) e de como os dados gráficos (fundo cinza) interagem com cada estágio. As etapas programáveis são mostradas com fundo preto. No lado esquerdo há uma ilustração do resultado de cada etapa para a renderização de um triângulo colorido.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:glpipeline"></span>
<img src="images/04_pipeline2.svg" alt="Pipeline gráfico do OpenGL." width="80%" />
<p class="caption">
Figura 4.7: Pipeline gráfico do OpenGL.
</p>
</div>
<div class="infobox">
<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1.4em;width:1.4em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#555;overflow:visible;position:relative;"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></svg>
<div class="infoboxtitle">
Observação
</div>
<p>Para simplificar, algumas etapas do pipeline foram omitidas, tais como:</p>
<ul>
<li>O <em>geometry shader</em>, utilizado para o processamento de geometria após a montagem de primitivas;</li>
<li>Os shaders de tesselação (<em>tessellation control shader</em> e <em>tessellation evaluation shader</em>), utilizados para subdivisão de primitivas;</li>
<li>O <em>compute shader</em>, utilizado para processamento de propósito geral (GPGPU).</li>
</ul>
<p>Essas etapas não serão utilizadas nas atividades da disciplina pois, no momento, não fazem parte do subconjunto do OpenGL ES utilizado pelo WebGL. Entretanto, são etapas frequentemente utilizadas em aplicações para OpenGL desktop. Consulte a <a href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf">especificação do OpenGL 4.6</a> para ter acesso ao pipeline completo.</p>
</div>
<div id="aplicação" class="section level3 unnumbered">
<h3>Aplicação</h3>
<p>Antes de iniciar o processamento, a aplicação deve especificar o formato dos dados gráficos e enviar esses dados à memória que será acessada durante a renderização. A aplicação também deve configurar as etapas programáveis do pipeline, compostas pelo <em>vertex shader</em> e <em>fragment shader</em>. Os shaders devem ser compilados, ligados e ativados previamente.</p>
<p>A geometria a ser processada é especificada através de um arranjo ordenado de vértices. O tipo de primitiva que será formada a partir desses vértices é determinado no comando de renderização. As primitivas suportadas pelo OpenGL são descritas a seguir e mostradas na figura <a href="glpipeline.html#fig:glprimitives">4.8</a>:</p>
<ul>
<li><code>GL_POINTS</code>: cada vértice forma um ponto que será desenhado na tela como um pixel ou como um quadrilátero centralizado no vértice. O tamanho do ponto/quadrilátero pode ser definido pelo usuário<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>;</li>
<li><code>GL_LINES</code>: cada grupo de dois vértices forma um segmento de reta;</li>
<li><code>GL_LINE_STRIP</code>: os vértices são conectados em ordem para formar uma polilinha;</li>
<li><code>GL_LINE_LOOP</code>: os vértices são conectados em ordem para formar uma polilinha, e o último vértice forma um segmento com o primeiro vértice, formando um laço;</li>
<li><code>GL_TRIANGLES</code>: cada grupo de três vértices forma um triângulo;</li>
<li><code>GL_TRIANGLE_STRIP</code>: os vértices formam uma faixa de triângulos com arestas compartilhadas;</li>
<li><code>GL_TRIANGLE_FAN</code>: os vértices formam um leque de triângulos de modo que todos os triângulos compartilham o primeiro vértice.</li>
</ul>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:glprimitives"></span>
<img src="images/04_glprimitives.svg" alt="Primitivas do OpenGL." width="80%" />
<p class="caption">
Figura 4.8: Primitivas do OpenGL.
</p>
</div>
<p>Cada vértice do arranjo de vértices de entrada é composto por um conjunto de atributos definidos pela aplicação. Cada atributo pode ser um único valor ou um conjunto de valores. A forma como esses valores são interpretados depende exclusivamente do que é definido no vertex shader. Geralmente, considera-se que cada vértice tem pelo menos uma posição 2D <span class="math inline">\((x,y)\)</span> ou 3D <span class="math inline">\((x,y,z)\)</span>. Outros atributos comuns para cada vértice são o vetor normal, cor e coordenadas de textura.</p>
<p>Para ser utilizado pelo pipeline, o arranjo de vértices deve ser armazenado na memória como um recurso chamado <a href="https://www.khronos.org/opengl/wiki/Vertex_Specification"><em>Vertex Buffer Object</em></a> (VBO). Cada atributo de vértice pode ser armazenado como um VBO separado, mas também é possível deixar todos os atributos em um único VBO (<em>interleaved data</em>). Cabe à aplicação especificar o formato dos dados de cada VBO e como eles serão lidos pelo vertex shader. Isso deve ser feito sempre antes da chamada do comando de renderização, para todos os VBOs. Alternativamente, essa configuração pode ser feita apenas uma vez e armazenada em um <em>Vertex Array Object</em> (VAO), bastando então ativar o VAO antes de cada renderização.</p>
<p>Além da criação dos VBOs, a aplicação pode criar variáveis globais, chamadas de <a href="https://www.khronos.org/opengl/wiki/Uniform_(GLSL)"><em>variáveis uniformes</em></a> (<em>uniform variables</em>), que podem ser lidas pelo vertex shader e fragment shader. Essa é uma outra forma de enviar dados ao pipeline. As variáveis uniformes contêm dados apenas de leitura e que não variam de vértice para vértice, por isso o nome “uniforme.” Por exemplo, uma matriz de transformação geométrica pode ser armazenada como uma variável uniforme pois todos os vértices serão transformados por essa matriz durante o processamento no vertex shader (isto é, a matriz de transformação é a mesma para todos os vértices). Também é possível criar buffers de dados uniformes (<a href="https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object"><em>Uniform Buffer Objects</em></a>, ou UBOs) para enviar arranjos de dados. A especificação do OpenGL garante ser possível enviar pelo menos 16KB de dados no formato de UBOs, mas é comum os drivers oferecerem suporte a até 64KB.</p>
<p>A aplicação também pode enviar dados ao pipeline usando buffers de texturas (<a href="https://www.khronos.org/opengl/wiki/Buffer_Texture"><em>buffer textures</em></a>). Os valores dos <em>texels</em> dessas texturas podem ser lidos no vertex shader e no fragment shader como se fossem valores de arranjos unidimensionais. Esses valores podem ser interpretados como cores RGBA normalizadas entre 0 e 1 ou como valores arbitrários em ponto flutuante de até 32 bits.</p>
<p>Uma forma mais recente e flexível de enviar dados uniformes é através dos <a href="https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object"><em>Shader Storage Buffer Objects</em></a> (SSBOs). O tamanho de um SSBO pode ser de até 128MB segundo a especificação, mas na maioria das implementações pode ser tão grande quanto a memória de vídeo disponível. Além disso, esse recurso pode ser utilizado tanto para leitura quanto escrita.</p>
<p>Há muitas formas de enviar e receber dados da GPU. Entretanto, para deixarmos as coisas mais simples, usaremos neste curso apenas os recursos mais básicos, como VBOs, VAOs e variáveis uniformes.</p>
</div>
<div id="vertex-shader" class="section level3 unnumbered">
<h3>Vertex shader</h3>
<p>Os shaders do OpenGL são programas escritos na linguagem <a href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.pdf">OpenGL Shading Language</a> (GLSL). GLSL é similar à linguagem C, mas utiliza novas palavras-chave, novos tipos de dados, qualificadores e operações.</p>
<p>O vertex shader processa cada vértice individualmente. Entretanto, esse processamento é paralelizado de forma massiva na GPU. Cada execução de um vertex shader acessa apenas os atributos do vértice que está sendo processado. Não há como compartilhar o estado do processamento de um vértice com os demais vértices.</p>
<p>A entrada do vertex shader é um conjunto de atributos de vértice definidos pelo usuário. Esses atributos são alimentados pelo pipeline de acordo com os VBOs atualmente ativos.</p>
<p>A saída do vertex shader é também um conjunto de atributos de vértice definidos pelo usuário. Esses atributos podem ser diferentes dos atributos de entrada. Além de escrever o resultado nos atributos de saída, é esperado (mas não obrigatório) que o vertex shader preencha uma variável embutida <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_Position.xhtml"><code>gl_Position</code></a> com a posição final do vértice em um sistema de coordenadas homogêneas 4D <span class="math inline">\((x, y, z, w)\)</span> chamado de <em>espaço de recorte</em> (<em>clip space</em>). Nos próximos estágios, a geometria das primitivas será determinada com bases nessas coordenadas. Veremos mais detalhes sobre os diferentes sistemas de coordenadas do OpenGL em capítulos futuros.</p>
<div class="infobox">
<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1.4em;width:1.4em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#555;overflow:visible;position:relative;"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></svg>
<div class="infoboxtitle">
Exemplo
</div>
<p>A seguir é exibido o código-fonte de um vertex shader:</p>
<div class="sourceCode" id="cb108" startFrom="1"><pre class="sourceCode numberSource glsl numberLines"><code class="sourceCode glsl"><span id="cb108-1"><a href="glpipeline.html#cb108-1"></a><span class="pp">#version 410</span></span>
<span id="cb108-2"><a href="glpipeline.html#cb108-2"></a></span>
<span id="cb108-3"><a href="glpipeline.html#cb108-3"></a><span class="kw">layout</span>(<span class="dt">location</span> = <span class="dv">0</span>) <span class="dt">in</span> <span class="dt">vec2</span> inPosition;</span>
<span id="cb108-4"><a href="glpipeline.html#cb108-4"></a><span class="kw">layout</span>(<span class="dt">location</span> = <span class="dv">1</span>) <span class="dt">in</span> <span class="dt">vec4</span> inColor;</span>
<span id="cb108-5"><a href="glpipeline.html#cb108-5"></a></span>
<span id="cb108-6"><a href="glpipeline.html#cb108-6"></a><span class="dt">out</span> <span class="dt">vec4</span> fragColor;</span>
<span id="cb108-7"><a href="glpipeline.html#cb108-7"></a></span>
<span id="cb108-8"><a href="glpipeline.html#cb108-8"></a><span class="dt">void</span> <span class="fu">main</span>() {</span>
<span id="cb108-9"><a href="glpipeline.html#cb108-9"></a>  <span class="bu">gl_Position</span> = <span class="dt">vec4</span>(inPosition.<span class="fu">x</span>, inPosition.<span class="fu">y</span> * <span class="fl">1.5</span>, <span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb108-10"><a href="glpipeline.html#cb108-10"></a>  fragColor = inColor / <span class="dv">2</span>;</span>
<span id="cb108-11"><a href="glpipeline.html#cb108-11"></a>}</span></code></pre></div>
<p>A primeira linha do vertex shader é a diretiva de pré-processamento <code>#version</code> que identifica a versão da especificação GLSL utilizada. Neste exemplo, <code>410</code> corresponde à especificação <a href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.10.pdf">GLSL 4.10</a>. Podemos substituir por <code>#version 300 es</code> para restringir os comandos do GLSL à especificação <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf">GLSL 3.0 ES</a> compatível com o WebGL 2.0. Na verdade isso é necessário se quisermos rodar a aplicação em WebAssembly. Felizmente não precisamos nos preocupar com isso pois a ABCg faz esse ajuste automaticamente para nós. Em todos os exemplos que veremos nesta disciplina, usaremos funções do OpenGL/GLSL 4.1 que também são compatíveis com OpenGL ES 3.0.</p>
<p>Nas linhas 3 e 4 são definidas as variáveis que receberão os atributos de entrada. Essas variáveis são identificadas com o qualificador <code>in</code><a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>:</p>
<ul>
<li><code>inPosition</code> é uma tupla de dois elementos (<code>vec2</code>) que recebe uma posição 2D (a posição do vértice).</li>
<li><code>inColor</code> é uma tupla de quatro elementos (<code>vec4</code>) que recebe componentes de cor RGBA (a cor do vértice).</li>
</ul>
<p>O vertex shader tem apenas um atributo de saída, definido na linha 6 através da variável <code>fragColor</code> com o qualificador <code>out</code>.</p>
<p>A função <code>main</code> é chamada para cada vértice processado. Para cada chamada, <code>inPosition</code> e <code>inColor</code> recebem os atributos do vértice.</p>
<p>Na linha 9, a variável embutida <code>gl_Position</code> é preenchida com <span class="math inline">\((x, \frac{3}{2}y,0,1)\)</span>, onde <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> são as coordenadas da posição 2D de entrada. Isso significa que a geometria sofrerá uma escala não uniforme: será “esticada” verticalmente.</p>
<p>Na linha 10, a variável de saída recebe a cor de entrada com a intensidade de cada componente RGBA dividida por dois. Isso significa que a cor de saída terá a metade da intensidade da cor de entrada.</p>
</div>
</div>
<div id="montagem-de-primitivas" class="section level3 unnumbered">
<h3>Montagem de primitivas</h3>
<p>A montagem de primitivas recebe os atributos de vértices processados pelo vertex shader e monta as primitivas de acordo com o que é informado na chamada do comando de renderização.</p>
<p>As primitivas geradas são formadas por pontos, segmentos ou triângulos. As primitivas da figura <a href="glpipeline.html#fig:glprimitives">4.8</a> são sempre decompostas em uma dessas três primitivas básicas. Por exemplo, se a primitiva informada pela aplicação é <code>GL_LINE_STRIP</code>, a polilinha será desmembrada em uma sequência de segmentos individuais.</p>
</div>
<div id="recorte" class="section level3 unnumbered">
<h3>Recorte</h3>
<p>Na etapa de recorte, as primitivas que estão fora do volume de visão (fora do viewport) são descartadas ou recortadas. Por exemplo, se a ponta de um triângulo estiver fora do volume de visão, o triângulo será recortado e formará um quadrilátero, que é então decomposto em dois triângulos. Os atributos dos vértices a mais gerados no recorte são obtidos através da interpolação linear dos atributos dos vértices originais. O recorte também pode operar sobre planos de recorte definidos pelo usuário no vertex shader.</p>
<p>Após o recorte, ocorre a <em>divisão perspectiva</em>, que consiste na conversão das coordenadas homogêneas 4D <span class="math inline">\((x, y, z, w)\)</span> em coordenadas cartesianas 3D <span class="math inline">\((x, y, z)\)</span>. Isso é feito dividindo <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> e <span class="math inline">\(z\)</span> por <span class="math inline">\(w\)</span>. O sistema de coordenadas resultante é chamado de <em>coordenadas normalizadas do dispositivo</em> (<em>normalized device coordinates</em>, ou NDC). Em NDC, todas as primitivas após o recorte estão situadas dentro de um <em>volume de visão canônico</em>: um cubo de <span class="math inline">\((-1, -1, -1)\)</span> a <span class="math inline">\((1, 1, 1)\)</span>.</p>
<p>Ainda nesta etapa, as componentes <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> das coordenadas em NDC são mapeadas para o sistema de coordenadas da janela (chamado de <em>espaço da janela</em>, ou <em>window space</em>), em pixels. Esse mapeamento é configurado pelo comando <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml"><code>glViewport</code></a>. O valor <span class="math inline">\(z\)</span> é mapeado de <span class="math inline">\([-1, 1]\)</span> para <span class="math inline">\([0, 1]\)</span> por padrão, mas isso pode ser configurado com <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthRange.xhtml"><code>glDepthRange</code></a>.</p>
</div>
<div id="rasterização-1" class="section level3 unnumbered">
<h3>Rasterização</h3>
<p>Todas as primitivas contidas no volume de visão canônico passam por uma conversão matricial, na ordem em que foram processadas nas etapas anteriores. O resultado da rasterização de cada primitiva é um conjunto de <em>fragmentos</em> que representam amostras da primitiva no espaço da tela. Um fragmento pode ser interpretado como um pixel em potencial. A cor final de cada pixel no framebuffer poderá ser determinada por um fragmento ou pela combinação de vários fragmentos.</p>
<p>Cada fragmento é descrito por dados como:</p>
<ul>
<li><strong>Posição <span class="math inline">\((x, y, z)\)</span> em coordenadas da janela</strong><a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>, sendo que <span class="math inline">\(z\)</span> é a profundidade do fragmento (por padrão, um valor no intervalo <span class="math inline">\([0, 1]\)</span>). Como cada fragmento tem uma profundidade, é possível determinar qual fragmento está “mais na frente” quando vários fragmentos são mapeados para a mesma posição <span class="math inline">\((x, y)\)</span> da janela. Assim, a cor do pixel pode ser determinada apenas pelo fragmento mais próximo. Os demais podem ser descartados pois estão sendo escondidos pelo fragmento mais próximo.</li>
<li><strong>Atributos interpolados a partir dos vértices da primitiva.</strong> Isso inclui todos os atributos definidos na saída do vertex shader. Por exemplo, se a saída do vertex shader devolve um atributo de cor RGB para cada vértice (uma tupla de três valores), então cada fragmento terá também uma cor RGB, com valores obtidos através da interpolação (geralmente linear) dos atributos definidos nos vértices.</li>
</ul>
</div>
<div id="fragment-shader" class="section level3 unnumbered">
<h3>Fragment shader</h3>
<p>O fragment shader é um programa que processa cada fragmento individualmente após a rasterização. A entrada do fragment shader é o mesmo conjunto de atributos definidos pelo usuário na saída do vertex shader. É possível acessar também outros atributos pré-definidos que compõem o conjunto de dados de cada fragmento. Por exemplo, a posição do fragmento pode ser acessada através de uma variável embutida chamada <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_FragCoord.xhtml"><code>gl_FragCoord</code></a>.</p>
<p>A saída do fragment shader geralmente é uma cor em formato RGBA (uma tupla de quatro valores), mas é possível produzir também mais de uma cor caso o pipeline tenha sido configurado para renderizar simultaneamente em vários buffers de cor. O fragment shader também pode alterar as propriedades do fragmento através de variáveis embutidas. Por exemplo, a profundidade pode ser modificada através de <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_FragDepth.xhtml"><code>gl_FragDepth</code></a>.</p>
<div class="infobox">
<svg aria-hidden="true" role="img" viewBox="0 0 512 512" style="height:1.4em;width:1.4em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#555;overflow:visible;position:relative;"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></svg>
<div class="infoboxtitle">
Exemplo
</div>
<p>A seguir é exibido o código-fonte do fragment shader que acompanha o vertex shader mostrado no exemplo anterior:</p>
<div class="sourceCode" id="cb109" startFrom="1"><pre class="sourceCode numberSource glsl numberLines"><code class="sourceCode glsl"><span id="cb109-1"><a href="glpipeline.html#cb109-1"></a><span class="pp">#version 410</span></span>
<span id="cb109-2"><a href="glpipeline.html#cb109-2"></a></span>
<span id="cb109-3"><a href="glpipeline.html#cb109-3"></a><span class="dt">in</span> <span class="dt">vec4</span> fragColor;</span>
<span id="cb109-4"><a href="glpipeline.html#cb109-4"></a></span>
<span id="cb109-5"><a href="glpipeline.html#cb109-5"></a><span class="dt">out</span> <span class="dt">vec4</span> outColor;</span>
<span id="cb109-6"><a href="glpipeline.html#cb109-6"></a></span>
<span id="cb109-7"><a href="glpipeline.html#cb109-7"></a><span class="dt">void</span> <span class="fu">main</span>() { </span>
<span id="cb109-8"><a href="glpipeline.html#cb109-8"></a>    outColor = <span class="dt">vec4</span>(fragColor.<span class="fu">r</span>, fragColor.<span class="fu">r</span>, fragColor.<span class="fu">r</span>, <span class="dv">1</span>);</span>
<span id="cb109-9"><a href="glpipeline.html#cb109-9"></a>}</span></code></pre></div>
<p>Esse fragment shader só tem um atributo de entrada, definido na linha 3 pela variável <code>fragColor</code>. O atributo de entrada é a cor RGBA correspondente ao atributo de saída do vertex shader. A saída do fragment shader também é uma cor RGBA, definida pela variável <code>outColor</code>.</p>
<p>A função <code>main</code> é chamada para cada fragmento processado. Para cada chamada, <code>fragColor</code> recebe o atributo do fragmento, que é o atributo de saída do vertex shader, mas interpolado entre os vértices da primitiva. Por exemplo, se a primitiva é um segmento formado por um vértice de cor RGB branca <span class="math inline">\((1,1,1)\)</span> e outro vértice de cor preta <span class="math inline">\((0,0,0)\)</span>, o fragmento produzido no ponto médio do segmento terá a cor cinza <span class="math inline">\((0.5, 0.5, 0.5)\)</span>.</p>
<p>Na linha 8, <code>outColor</code> recebe uma cor RGBA na qual as componentes RGB são uma replicação da componente R da cor de entrada. Isso significa que a cor resultante é um tom de cinza que corresponde à intensidade de vermelho da cor original.</p>
<p>Se esse fragment shader e o vertex shader do exemplo anterior fossem utilizados no projeto “Hello, World!” da ABCg (seção <a href="abcg.html#abcg">1.5</a>), o triângulo resultante seria igual ao mostrado à direita na figura <a href="glpipeline.html#fig:helloworldtriangle">4.9</a>. Observe o efeito da mudança de escala da geometria (feita no vertex shader) e modificação das cores (intensidade reduzida pela metade no vertex shader, e conversão para tons de cinza no fragment shader).</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:helloworldtriangle"></span>
<img src="images/04_triangle.png" alt="Renderização do triângulo do projeto &quot;Hello, World!&quot; com os shaders originais (esquerda) e shaders utilizados nos exemplos (direita)." width="80%" />
<p class="caption">
Figura 4.9: Renderização do triângulo do projeto “Hello, World!” com os shaders originais (esquerda) e shaders utilizados nos exemplos (direita).
</p>
</div>
</div>
</div>
<div id="operações-de-fragmentos" class="section level3 unnumbered">
<h3>Operações de fragmentos</h3>
<p>Após o processamento no fragment shader, cada fragmento passa por uma sequência de testes que podem resultar em seu descarte. Se o fragmento falhar em algum desses testes, ele será ignorado e não contribuirá para a cor do pixel final.</p>
<ul>
<li><p>O <em>teste de propriedade de pixel</em> (<em>pixel ownership test</em>) verifica se o fragmento corresponde a um pixel do framebuffer que está de fato visível no sistema de janelas. Por exemplo, se uma outra janela estiver sobrepondo a janela do OpenGL, os fragmentos mapeados para a área sobreposta serão descartados.</p></li>
<li><p>O <em>teste de tesoura</em> (<em>scissor test</em>), quando ativado com <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnable.xhtml"><code>glEnable</code></a>, descarta fragmentos que estão fora de um retângulo definido no espaço da janela pela função <a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glScissor.xml"><code>glScissor</code></a>. Por exemplo, usando o código a seguir, o teste de tesoura será ativado e serão descartados todos os fragmentos que estiverem fora do retângulo definido pelas coordenadas <span class="math inline">\((50,30)\)</span> a <span class="math inline">\((250,130)\)</span> pixels no espaço da janela (o pixel de coordenada <span class="math inline">\((0,0)\)</span> corresponde ao canto inferior esquerdo da janela):</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="glpipeline.html#cb110-1" aria-hidden="true" tabindex="-1"></a>glEnable(GL_SCISSOR_TEST);    </span>
<span id="cb110-2"><a href="glpipeline.html#cb110-2" aria-hidden="true" tabindex="-1"></a>glScissor(<span class="dv">50</span>, <span class="dv">30</span>, <span class="dv">200</span>, <span class="dv">100</span>);</span></code></pre></div></li>
<li><p>O <em>teste de estêncil</em> (<em>stencil test</em>), quando ativado com <code>glEnable</code>, descarta fragmentos que não passam em um teste de comparação entre um <em>valor de estêncil</em> do fragmento (um número inteiro, geralmente de 8 bits) e o valor de estêncil do <em>buffer de estêncil</em> (<em>stencil buffer</em>), que é um dos buffers do framebuffer. Por exemplo, no código a seguir, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml"><code>glStencilFunc</code></a> estabelece que o teste deve comparar se o valor de estêncil do fragmento é maior que 5. Se sim, o fragmento é mantido. Se não, é descartado.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="glpipeline.html#cb111-1" aria-hidden="true" tabindex="-1"></a>glEnable(GL_STENCIL_TEST);  </span>
<span id="cb111-2"><a href="glpipeline.html#cb111-2" aria-hidden="true" tabindex="-1"></a>glStencilFunc(GL_GREATER, <span class="dv">5</span>, <span class="bn">0xFF</span>)</span></code></pre></div></li>
<li><p>O <em>teste de profundidade</em> (<em>depth test</em>), quando ativado com <code>glEnable</code>, descarta fragmentos que não passam em um teste de comparação do valor de profundidade do fragmento (valor <span class="math inline">\(z\)</span> no espaço da janela) com o valor de profundidade armazenado atualmente no <em>buffer de profundidade</em> (<em>depth buffer</em>). Com o teste de profundidade é possível fazer com que só os fragmentos mais próximos sejam exibidos. Por exemplo, no código a seguir, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml"><code>glDepthFunc</code></a> faz com que o teste de profundidade compare se o valor de profundidade do fragmento é menor que o valor do buffer de profundidade (<code>GL_LESS</code> é a comparação padrão). Se sim, o fragmento é mantido. Se não, é descartado.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="glpipeline.html#cb112-1" aria-hidden="true" tabindex="-1"></a>glEnable(GL_DEPTH_TEST);  </span>
<span id="cb112-2"><a href="glpipeline.html#cb112-2" aria-hidden="true" tabindex="-1"></a>glDepthFunc(GL_LESS);</span></code></pre></div></li>
</ul>
<p>Muitos desses testes podem ser realizados antes do fragment shader, em uma otimização chamada de <em>early per-fragment test</em>, suportada pela maioria das GPUs atuais. Por exemplo, se o fragment shader não modificar <code>gl_FragDepth</code>, é possível fazer o teste de profundidade logo após a rasterização, evitando o processamento de um fragmento que já se sabe que não contribuirá para a formação da imagem.</p>
<p>Se o fragmento passou por todos os testes e não foi descartado, sua cor será utilizada para modificar o pixel correspondente no(s) buffer(s) de cor. Mesmo que o fragmento não tenha passado por todos os testes, é possível que o buffer de estêncil e buffer de profundidade sejam modificados. Esse comportamento pode ser determinado pela aplicação. Também é possível usar operações de mascaramento para permitir, por exemplo, que somente as componentes RG da cor RGB sejam escritas no buffer de cor.</p>
<p>Antes do buffer de cor ser modificado, também é possível fazer com que a cor do fragmento seja misturada com a cor atual do buffer de cor, em uma operação de <em>mistura de cor</em> (<em>color blending</em>). Por exemplo, considere o código a seguir:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="glpipeline.html#cb113-1" aria-hidden="true" tabindex="-1"></a>glEnable(GL_BLEND);</span>
<span id="cb113-2"><a href="glpipeline.html#cb113-2" aria-hidden="true" tabindex="-1"></a>glBlendEquation(GL_FUNC_ADD);</span>
<span id="cb113-3"><a href="glpipeline.html#cb113-3" aria-hidden="true" tabindex="-1"></a>glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); </span></code></pre></div>
<p><code>glEnable(GL_BLEND)</code> habilita o modo de mistura de cor. As funções <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml"><code>glBlendEquation</code></a> e <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml"><code>glBlendFunc</code></a> configuram a mistura de cor para que cada componente de cor RGBA do buffer de cor seja calculada como <span class="math inline">\(C=C_sF_s + C_dF_d\)</span>, onde:</p>
<ul>
<li><span class="math inline">\(C_s\)</span> é a componente de cor do fragmento (origem);</li>
<li><span class="math inline">\(C_d\)</span> é a componente de cor do buffer de cor (destino);</li>
<li><span class="math inline">\(F_s\)</span> é um fator de mistura de cor, que nesse caso é a componente A da cor do fragmento (<code>GL_SRC_ALPHA</code>);</li>
<li><span class="math inline">\(F_d\)</span> é um fator de mistura de cor, que nesse caso é 1 menos a componente A da cor do fragmento (<code>GL_ONE_MINUS_SRC_ALPHA</code>).</li>
</ul>
<p>O resultado é a combinação da cor do fragmento com a cor atual do buffer de cor, usando a componente A do fragmento como fator de opacidade (1=totalmente opaco, 0=totalmente transparente).</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="16">
<li id="fn16"><p>O tamanho do ponto pode ser definido através da função <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPointSize.xhtml"><code>glPointSize</code></a> ou pela variável embutida (<em>built-in</em>) <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_PointSize.xhtml"><code>gl_PointSize</code></a> no vertex shader.<a href="glpipeline.html#fnref16" class="footnote-back">↩︎</a></p></li>
<li id="fn17"><p>Neste exemplo, o nome das variáveis de entrada também começa com o prefixo <code>in</code>, mas isso é só uma convenção.<a href="glpipeline.html#fnref17" class="footnote-back">↩︎</a></p></li>
<li id="fn18"><p>A posição de cada fragmento também inclui o valor recíproco da coordenada <span class="math inline">\(w\)</span> no espaço de recorte.<a href="glpipeline.html#fnref18" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="ray-casting-x-rasterização.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="coloredtriangles.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": {}
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": null,
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection",
"scroll_highlight": true
},
"toc_float": true,
"toolbar": {
"position": "fixed"
},
"info": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
